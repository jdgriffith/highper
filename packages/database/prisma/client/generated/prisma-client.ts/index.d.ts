
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Accounts
 * 
 */
export type Accounts = {
  id: string
  name: string
  accountId: string | null
  marketValue: Prisma.Decimal | null
  buyingPower: Prisma.Decimal | null
  cash: Prisma.Decimal | null
  currency: string
  daytradeCount: number
  daytradeBuyingPower: Prisma.Decimal | null
  regulationTBuyingPower: Prisma.Decimal | null
  initialMargin: Prisma.Decimal | null
  lastMaintenanceMargin: Prisma.Decimal | null
  longMarketValue: Prisma.Decimal | null
  shortMarketValue: Prisma.Decimal | null
  maintenanceMargin: Prisma.Decimal | null
  multiplier: Prisma.Decimal | null
  sma: Prisma.Decimal | null
  status: string | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model AmeritradeEvents
 * 
 */
export type AmeritradeEvents = {
  id: string
  message: Prisma.JsonValue
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model AmeritradeTokens
 * 
 */
export type AmeritradeTokens = {
  id: number
  data: Prisma.JsonValue
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model BackTesting
 * 
 */
export type BackTesting = {
  id: string
  strategy: string
  strategyParameters: Prisma.JsonValue | null
  startDate: Date
  endDate: Date
  resultLog: string | null
  marginPercentage: Prisma.Decimal
  averageInterestRate: Prisma.Decimal
  finalBalance: Prisma.Decimal
  profits: Prisma.Decimal
  losses: Prisma.Decimal
  highestInterestDay: Prisma.Decimal
  lowestInterestDay: Prisma.Decimal
  createdAt: Date
  updatedAt: Date | null
  code: string | null
  unrealizedProfit: Prisma.Decimal | null
}

/**
 * Model Exchanges
 * 
 */
export type Exchanges = {
  id: number
  name: string
  description: string | null
  assetClass: string | null
  locale: string | null
  acronym: string | null
  mic: string | null
  operatingMic: string | null
  participantId: string | null
  url: string | null
}

/**
 * Model migrations
 * 
 */
export type migrations = {
  id: number
  timestamp: bigint
  name: string
}

/**
 * Model Orders
 * 
 */
export type Orders = {
  id: string
  securityId: number
  strategyName: string | null
  accountId: string | null
  symbol: string
  name: string | null
  type: string
  timeInForce: string
  quantity: Prisma.Decimal
  filledQuantity: Prisma.Decimal
  filledTime: Date | null
  stopPrice: Prisma.Decimal | null
  limitPrice: Prisma.Decimal | null
  filledAveragePrice: Prisma.Decimal | null
  status: string | null
  orderType: string | null
  trailAmount: Prisma.Decimal | null
  extendedHours: boolean
  submittedAt: Date | null
  expiredAt: Date | null
  canceledAt: Date | null
  failedAt: Date | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Positions
 * 
 */
export type Positions = {
  id: string
  price: Prisma.Decimal
  securityId: number
  strategyName: string | null
  name: string | null
  accountId: string | null
  quantity: Prisma.Decimal
  marketValue: Prisma.Decimal | null
  symbol: string
  exchange: string | null
  positionPercent: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date | null
  status: string | null
  type: string
  sellLock: boolean
}

/**
 * Model PositionOrders
 * 
 */
export type PositionOrders = {
  positionId: string
  orderId: string
  intent: string
  createdAt: Date
}

/**
 * Model Preferences
 * 
 */
export type Preferences = {
  id: number
  singleTradeRiskLevel: Prisma.Decimal | null
  allTradeRiskLevel: Prisma.Decimal | null
  singleTradeVolatilityLevel: Prisma.Decimal | null
  allTradeVolatilityLevel: Prisma.Decimal | null
  lowestStockPrice: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model SectorDaily
 * 
 */
export type SectorDaily = {
  id: number
  sectorId: number
  calendarDate: Date
  realtimeReturn: Prisma.Decimal
  oneDayReturn: Prisma.Decimal
  fiveDayReturn: Prisma.Decimal
  oneMonthReturn: Prisma.Decimal
  threeMonthReturn: Prisma.Decimal
  oneYearReturn: Prisma.Decimal
  threeYearReturn: Prisma.Decimal
  fiveYearReturn: Prisma.Decimal
  tenYearReturn: Prisma.Decimal
  ytdReturn: Prisma.Decimal
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Sectors
 * 
 */
export type Sectors = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Securities
 * 
 */
export type Securities = {
  id: number
  name: string | null
  description: string | null
  symbol: string | null
  cusip: string | null
  exchange: string | null
  securityTypeId: number | null
  createdAt: Date
  updatedAt: Date | null
  marketCap: Prisma.Decimal | null
  companyName: string | null
  sector: string | null
  active: boolean
  delistedCalendarDate: Date | null
  companyDescription: string | null
  url: string | null
  sharesOutstanding: number | null
  numberOfEmployees: number | null
}

/**
 * Model SecurityDaily
 * 
 */
export type SecurityDaily = {
  id: number
  securityId: number
  open: Prisma.Decimal | null
  high: Prisma.Decimal | null
  low: Prisma.Decimal | null
  close: Prisma.Decimal | null
  adjustedClose: Prisma.Decimal | null
  marketCap: Prisma.Decimal | null
  enterpriseValue: Prisma.Decimal | null
  peRatio: Prisma.Decimal | null
  pbRatio: Prisma.Decimal | null
  trailingOneYearPegRatio: Prisma.Decimal | null
  dividendAmount: Prisma.Decimal | null
  splitCoefficient: Prisma.Decimal | null
  volume: number
  adjusted: boolean
  calendarDate: Date
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model SecurityDividends
 * 
 */
export type SecurityDividends = {
  id: number
  securityId: number
  expirationDate: Date | null
  paymentDate: Date
  recordDate: Date
  amount: Prisma.Decimal
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model SecurityIndexTypes
 * 
 */
export type SecurityIndexTypes = {
  id: number
  name: string
  description: string | null
}

/**
 * Model SecurityMinutely
 * 
 */
export type SecurityMinutely = {
  securityId: number
  calendarDate: Date
  minute: string | null
  label: string | null
  open: Prisma.Decimal | null
  close: Prisma.Decimal | null
  high: Prisma.Decimal | null
  low: Prisma.Decimal | null
  average: Prisma.Decimal | null
  volume: bigint | null
  notional: Prisma.Decimal | null
  numberOfTrades: bigint | null
  marketHigh: Prisma.Decimal | null
  marketLow: Prisma.Decimal | null
  marketAverage: Prisma.Decimal | null
  marketVolume: bigint | null
  marketNotional: Prisma.Decimal | null
  marketNumberOfTrades: bigint | null
  marketOpen: Prisma.Decimal | null
  marketClose: Prisma.Decimal | null
  changeOverTime: Prisma.Decimal | null
  marketChangeOverTime: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date | null
  dateTime: Date | null
}

/**
 * Model SecuritySecondly
 * 
 */
export type SecuritySecondly = {
  calendarDate: Date
  securityId: number
  open: Prisma.Decimal | null
  close: Prisma.Decimal | null
  high: Prisma.Decimal | null
  low: Prisma.Decimal | null
  average: Prisma.Decimal | null
  volume: bigint | null
  notional: Prisma.Decimal | null
  numberOfTrades: bigint | null
  changeOverTime: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model SecuritySplits
 * 
 */
export type SecuritySplits = {
  id: number
  securityId: number
  paymentDate: Date
  ratio: Prisma.Decimal
  createdAt: Date
  updatedAt: Date | null
  exercisedDate: Date
  declaredDate: Date
  toFactor: number
  fromFactor: number
  description: string | null
}

/**
 * Model SecurityTypes
 * 
 */
export type SecurityTypes = {
  id: number
  name: string
  description: string | null
}

/**
 * Model Strategies
 * 
 */
export type Strategies = {
  id: number
  name: string
  description: string | null
}

/**
 * Model StrategyParameters
 * 
 */
export type StrategyParameters = {
  id: number
  strategyId: number
  key: string
  value: string
  dataType: string | null
}

/**
 * Model Trades
 * 
 */
export type Trades = {
  id: number
  securityId: number
  exchangeId: number
  tradeDate: Date
  price: Prisma.Decimal
  quantity: Prisma.Decimal
  createdAt: Date
}

/**
 * Model Quotes
 * 
 */
export type Quotes = {
  id: number
  securityId: number
  bidExchangeId: number
  askExchangeId: number
  bidPrice: Prisma.Decimal | null
  askPrice: Prisma.Decimal | null
  bidSize: Prisma.Decimal | null
  askSize: Prisma.Decimal | null
  createdAt: Date
}

/**
 * Model Conditions
 * 
 */
export type Conditions = {
  id: number
  tradeId: number
  quoteId: number
  condition: string
  modifier: number
  SIPMapping: string
  createdAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.accounts.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.accounts.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.accounts`: Exposes CRUD operations for the **Accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.AccountsDelegate<GlobalReject>;

  /**
   * `prisma.ameritradeEvents`: Exposes CRUD operations for the **AmeritradeEvents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmeritradeEvents
    * const ameritradeEvents = await prisma.ameritradeEvents.findMany()
    * ```
    */
  get ameritradeEvents(): Prisma.AmeritradeEventsDelegate<GlobalReject>;

  /**
   * `prisma.ameritradeTokens`: Exposes CRUD operations for the **AmeritradeTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmeritradeTokens
    * const ameritradeTokens = await prisma.ameritradeTokens.findMany()
    * ```
    */
  get ameritradeTokens(): Prisma.AmeritradeTokensDelegate<GlobalReject>;

  /**
   * `prisma.backTesting`: Exposes CRUD operations for the **BackTesting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BackTestings
    * const backTestings = await prisma.backTesting.findMany()
    * ```
    */
  get backTesting(): Prisma.BackTestingDelegate<GlobalReject>;

  /**
   * `prisma.exchanges`: Exposes CRUD operations for the **Exchanges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exchanges
    * const exchanges = await prisma.exchanges.findMany()
    * ```
    */
  get exchanges(): Prisma.ExchangesDelegate<GlobalReject>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<GlobalReject>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **Orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.OrdersDelegate<GlobalReject>;

  /**
   * `prisma.positions`: Exposes CRUD operations for the **Positions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.positions.findMany()
    * ```
    */
  get positions(): Prisma.PositionsDelegate<GlobalReject>;

  /**
   * `prisma.positionOrders`: Exposes CRUD operations for the **PositionOrders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PositionOrders
    * const positionOrders = await prisma.positionOrders.findMany()
    * ```
    */
  get positionOrders(): Prisma.PositionOrdersDelegate<GlobalReject>;

  /**
   * `prisma.preferences`: Exposes CRUD operations for the **Preferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preferences
    * const preferences = await prisma.preferences.findMany()
    * ```
    */
  get preferences(): Prisma.PreferencesDelegate<GlobalReject>;

  /**
   * `prisma.sectorDaily`: Exposes CRUD operations for the **SectorDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SectorDailies
    * const sectorDailies = await prisma.sectorDaily.findMany()
    * ```
    */
  get sectorDaily(): Prisma.SectorDailyDelegate<GlobalReject>;

  /**
   * `prisma.sectors`: Exposes CRUD operations for the **Sectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sectors
    * const sectors = await prisma.sectors.findMany()
    * ```
    */
  get sectors(): Prisma.SectorsDelegate<GlobalReject>;

  /**
   * `prisma.securities`: Exposes CRUD operations for the **Securities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Securities
    * const securities = await prisma.securities.findMany()
    * ```
    */
  get securities(): Prisma.SecuritiesDelegate<GlobalReject>;

  /**
   * `prisma.securityDaily`: Exposes CRUD operations for the **SecurityDaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityDailies
    * const securityDailies = await prisma.securityDaily.findMany()
    * ```
    */
  get securityDaily(): Prisma.SecurityDailyDelegate<GlobalReject>;

  /**
   * `prisma.securityDividends`: Exposes CRUD operations for the **SecurityDividends** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityDividends
    * const securityDividends = await prisma.securityDividends.findMany()
    * ```
    */
  get securityDividends(): Prisma.SecurityDividendsDelegate<GlobalReject>;

  /**
   * `prisma.securityIndexTypes`: Exposes CRUD operations for the **SecurityIndexTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityIndexTypes
    * const securityIndexTypes = await prisma.securityIndexTypes.findMany()
    * ```
    */
  get securityIndexTypes(): Prisma.SecurityIndexTypesDelegate<GlobalReject>;

  /**
   * `prisma.securityMinutely`: Exposes CRUD operations for the **SecurityMinutely** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityMinutelies
    * const securityMinutelies = await prisma.securityMinutely.findMany()
    * ```
    */
  get securityMinutely(): Prisma.SecurityMinutelyDelegate<GlobalReject>;

  /**
   * `prisma.securitySecondly`: Exposes CRUD operations for the **SecuritySecondly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecuritySecondlies
    * const securitySecondlies = await prisma.securitySecondly.findMany()
    * ```
    */
  get securitySecondly(): Prisma.SecuritySecondlyDelegate<GlobalReject>;

  /**
   * `prisma.securitySplits`: Exposes CRUD operations for the **SecuritySplits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecuritySplits
    * const securitySplits = await prisma.securitySplits.findMany()
    * ```
    */
  get securitySplits(): Prisma.SecuritySplitsDelegate<GlobalReject>;

  /**
   * `prisma.securityTypes`: Exposes CRUD operations for the **SecurityTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityTypes
    * const securityTypes = await prisma.securityTypes.findMany()
    * ```
    */
  get securityTypes(): Prisma.SecurityTypesDelegate<GlobalReject>;

  /**
   * `prisma.strategies`: Exposes CRUD operations for the **Strategies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strategies
    * const strategies = await prisma.strategies.findMany()
    * ```
    */
  get strategies(): Prisma.StrategiesDelegate<GlobalReject>;

  /**
   * `prisma.strategyParameters`: Exposes CRUD operations for the **StrategyParameters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StrategyParameters
    * const strategyParameters = await prisma.strategyParameters.findMany()
    * ```
    */
  get strategyParameters(): Prisma.StrategyParametersDelegate<GlobalReject>;

  /**
   * `prisma.trades`: Exposes CRUD operations for the **Trades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trades
    * const trades = await prisma.trades.findMany()
    * ```
    */
  get trades(): Prisma.TradesDelegate<GlobalReject>;

  /**
   * `prisma.quotes`: Exposes CRUD operations for the **Quotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quotes.findMany()
    * ```
    */
  get quotes(): Prisma.QuotesDelegate<GlobalReject>;

  /**
   * `prisma.conditions`: Exposes CRUD operations for the **Conditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conditions
    * const conditions = await prisma.conditions.findMany()
    * ```
    */
  get conditions(): Prisma.ConditionsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.4.0
   * Query Engine version: f352a33b70356f46311da8b00d83386dd9f145d6
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Accounts: 'Accounts',
    AmeritradeEvents: 'AmeritradeEvents',
    AmeritradeTokens: 'AmeritradeTokens',
    BackTesting: 'BackTesting',
    Exchanges: 'Exchanges',
    migrations: 'migrations',
    Orders: 'Orders',
    Positions: 'Positions',
    PositionOrders: 'PositionOrders',
    Preferences: 'Preferences',
    SectorDaily: 'SectorDaily',
    Sectors: 'Sectors',
    Securities: 'Securities',
    SecurityDaily: 'SecurityDaily',
    SecurityDividends: 'SecurityDividends',
    SecurityIndexTypes: 'SecurityIndexTypes',
    SecurityMinutely: 'SecurityMinutely',
    SecuritySecondly: 'SecuritySecondly',
    SecuritySplits: 'SecuritySplits',
    SecurityTypes: 'SecurityTypes',
    Strategies: 'Strategies',
    StrategyParameters: 'StrategyParameters',
    Trades: 'Trades',
    Quotes: 'Quotes',
    Conditions: 'Conditions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountsCountOutputType
   */


  export type AccountsCountOutputType = {
    Orders: number
    Positions: number
  }

  export type AccountsCountOutputTypeSelect = {
    Orders?: boolean
    Positions?: boolean
  }

  export type AccountsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AccountsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AccountsCountOutputType
    : S extends undefined
    ? never
    : S extends AccountsCountOutputTypeArgs
    ?'include' extends U
    ? AccountsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AccountsCountOutputType ? AccountsCountOutputType[P] : never
  } 
    : AccountsCountOutputType
  : AccountsCountOutputType




  // Custom InputTypes

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AccountsCountOutputType
     * 
    **/
    select?: AccountsCountOutputTypeSelect | null
  }



  /**
   * Count Type ExchangesCountOutputType
   */


  export type ExchangesCountOutputType = {
    Trades: number
    AskQuotes: number
    BidQuotes: number
  }

  export type ExchangesCountOutputTypeSelect = {
    Trades?: boolean
    AskQuotes?: boolean
    BidQuotes?: boolean
  }

  export type ExchangesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ExchangesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ExchangesCountOutputType
    : S extends undefined
    ? never
    : S extends ExchangesCountOutputTypeArgs
    ?'include' extends U
    ? ExchangesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ExchangesCountOutputType ? ExchangesCountOutputType[P] : never
  } 
    : ExchangesCountOutputType
  : ExchangesCountOutputType




  // Custom InputTypes

  /**
   * ExchangesCountOutputType without action
   */
  export type ExchangesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ExchangesCountOutputType
     * 
    **/
    select?: ExchangesCountOutputTypeSelect | null
  }



  /**
   * Count Type OrdersCountOutputType
   */


  export type OrdersCountOutputType = {
    PositionOrders: number
  }

  export type OrdersCountOutputTypeSelect = {
    PositionOrders?: boolean
  }

  export type OrdersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrdersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrdersCountOutputType
    : S extends undefined
    ? never
    : S extends OrdersCountOutputTypeArgs
    ?'include' extends U
    ? OrdersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrdersCountOutputType ? OrdersCountOutputType[P] : never
  } 
    : OrdersCountOutputType
  : OrdersCountOutputType




  // Custom InputTypes

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     * 
    **/
    select?: OrdersCountOutputTypeSelect | null
  }



  /**
   * Count Type PositionsCountOutputType
   */


  export type PositionsCountOutputType = {
    PositionOrders: number
  }

  export type PositionsCountOutputTypeSelect = {
    PositionOrders?: boolean
  }

  export type PositionsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PositionsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PositionsCountOutputType
    : S extends undefined
    ? never
    : S extends PositionsCountOutputTypeArgs
    ?'include' extends U
    ? PositionsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PositionsCountOutputType ? PositionsCountOutputType[P] : never
  } 
    : PositionsCountOutputType
  : PositionsCountOutputType




  // Custom InputTypes

  /**
   * PositionsCountOutputType without action
   */
  export type PositionsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PositionsCountOutputType
     * 
    **/
    select?: PositionsCountOutputTypeSelect | null
  }



  /**
   * Count Type SectorsCountOutputType
   */


  export type SectorsCountOutputType = {
    SectorDaily: number
  }

  export type SectorsCountOutputTypeSelect = {
    SectorDaily?: boolean
  }

  export type SectorsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SectorsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SectorsCountOutputType
    : S extends undefined
    ? never
    : S extends SectorsCountOutputTypeArgs
    ?'include' extends U
    ? SectorsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SectorsCountOutputType ? SectorsCountOutputType[P] : never
  } 
    : SectorsCountOutputType
  : SectorsCountOutputType




  // Custom InputTypes

  /**
   * SectorsCountOutputType without action
   */
  export type SectorsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SectorsCountOutputType
     * 
    **/
    select?: SectorsCountOutputTypeSelect | null
  }



  /**
   * Count Type SecuritiesCountOutputType
   */


  export type SecuritiesCountOutputType = {
    SecurityDaily: number
    SecurityDividends: number
    SecurityMinutely: number
    SecuritySecondly: number
    SecuritySplits: number
    Trades: number
    Quotes: number
  }

  export type SecuritiesCountOutputTypeSelect = {
    SecurityDaily?: boolean
    SecurityDividends?: boolean
    SecurityMinutely?: boolean
    SecuritySecondly?: boolean
    SecuritySplits?: boolean
    Trades?: boolean
    Quotes?: boolean
  }

  export type SecuritiesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SecuritiesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SecuritiesCountOutputType
    : S extends undefined
    ? never
    : S extends SecuritiesCountOutputTypeArgs
    ?'include' extends U
    ? SecuritiesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SecuritiesCountOutputType ? SecuritiesCountOutputType[P] : never
  } 
    : SecuritiesCountOutputType
  : SecuritiesCountOutputType




  // Custom InputTypes

  /**
   * SecuritiesCountOutputType without action
   */
  export type SecuritiesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SecuritiesCountOutputType
     * 
    **/
    select?: SecuritiesCountOutputTypeSelect | null
  }



  /**
   * Count Type StrategiesCountOutputType
   */


  export type StrategiesCountOutputType = {
    StrategyParameters: number
  }

  export type StrategiesCountOutputTypeSelect = {
    StrategyParameters?: boolean
  }

  export type StrategiesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | StrategiesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? StrategiesCountOutputType
    : S extends undefined
    ? never
    : S extends StrategiesCountOutputTypeArgs
    ?'include' extends U
    ? StrategiesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof StrategiesCountOutputType ? StrategiesCountOutputType[P] : never
  } 
    : StrategiesCountOutputType
  : StrategiesCountOutputType




  // Custom InputTypes

  /**
   * StrategiesCountOutputType without action
   */
  export type StrategiesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StrategiesCountOutputType
     * 
    **/
    select?: StrategiesCountOutputTypeSelect | null
  }



  /**
   * Count Type TradesCountOutputType
   */


  export type TradesCountOutputType = {
    Conditions: number
  }

  export type TradesCountOutputTypeSelect = {
    Conditions?: boolean
  }

  export type TradesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TradesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TradesCountOutputType
    : S extends undefined
    ? never
    : S extends TradesCountOutputTypeArgs
    ?'include' extends U
    ? TradesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TradesCountOutputType ? TradesCountOutputType[P] : never
  } 
    : TradesCountOutputType
  : TradesCountOutputType




  // Custom InputTypes

  /**
   * TradesCountOutputType without action
   */
  export type TradesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TradesCountOutputType
     * 
    **/
    select?: TradesCountOutputTypeSelect | null
  }



  /**
   * Count Type QuotesCountOutputType
   */


  export type QuotesCountOutputType = {
    Conditions: number
  }

  export type QuotesCountOutputTypeSelect = {
    Conditions?: boolean
  }

  export type QuotesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuotesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuotesCountOutputType
    : S extends undefined
    ? never
    : S extends QuotesCountOutputTypeArgs
    ?'include' extends U
    ? QuotesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuotesCountOutputType ? QuotesCountOutputType[P] : never
  } 
    : QuotesCountOutputType
  : QuotesCountOutputType




  // Custom InputTypes

  /**
   * QuotesCountOutputType without action
   */
  export type QuotesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuotesCountOutputType
     * 
    **/
    select?: QuotesCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Accounts
   */


  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    marketValue: Decimal | null
    buyingPower: Decimal | null
    cash: Decimal | null
    daytradeCount: number | null
    daytradeBuyingPower: Decimal | null
    regulationTBuyingPower: Decimal | null
    initialMargin: Decimal | null
    lastMaintenanceMargin: Decimal | null
    longMarketValue: Decimal | null
    shortMarketValue: Decimal | null
    maintenanceMargin: Decimal | null
    multiplier: Decimal | null
    sma: Decimal | null
  }

  export type AccountsSumAggregateOutputType = {
    marketValue: Decimal | null
    buyingPower: Decimal | null
    cash: Decimal | null
    daytradeCount: number | null
    daytradeBuyingPower: Decimal | null
    regulationTBuyingPower: Decimal | null
    initialMargin: Decimal | null
    lastMaintenanceMargin: Decimal | null
    longMarketValue: Decimal | null
    shortMarketValue: Decimal | null
    maintenanceMargin: Decimal | null
    multiplier: Decimal | null
    sma: Decimal | null
  }

  export type AccountsMinAggregateOutputType = {
    id: string | null
    name: string | null
    accountId: string | null
    marketValue: Decimal | null
    buyingPower: Decimal | null
    cash: Decimal | null
    currency: string | null
    daytradeCount: number | null
    daytradeBuyingPower: Decimal | null
    regulationTBuyingPower: Decimal | null
    initialMargin: Decimal | null
    lastMaintenanceMargin: Decimal | null
    longMarketValue: Decimal | null
    shortMarketValue: Decimal | null
    maintenanceMargin: Decimal | null
    multiplier: Decimal | null
    sma: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    accountId: string | null
    marketValue: Decimal | null
    buyingPower: Decimal | null
    cash: Decimal | null
    currency: string | null
    daytradeCount: number | null
    daytradeBuyingPower: Decimal | null
    regulationTBuyingPower: Decimal | null
    initialMargin: Decimal | null
    lastMaintenanceMargin: Decimal | null
    longMarketValue: Decimal | null
    shortMarketValue: Decimal | null
    maintenanceMargin: Decimal | null
    multiplier: Decimal | null
    sma: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    name: number
    accountId: number
    marketValue: number
    buyingPower: number
    cash: number
    currency: number
    daytradeCount: number
    daytradeBuyingPower: number
    regulationTBuyingPower: number
    initialMargin: number
    lastMaintenanceMargin: number
    longMarketValue: number
    shortMarketValue: number
    maintenanceMargin: number
    multiplier: number
    sma: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    marketValue?: true
    buyingPower?: true
    cash?: true
    daytradeCount?: true
    daytradeBuyingPower?: true
    regulationTBuyingPower?: true
    initialMargin?: true
    lastMaintenanceMargin?: true
    longMarketValue?: true
    shortMarketValue?: true
    maintenanceMargin?: true
    multiplier?: true
    sma?: true
  }

  export type AccountsSumAggregateInputType = {
    marketValue?: true
    buyingPower?: true
    cash?: true
    daytradeCount?: true
    daytradeBuyingPower?: true
    regulationTBuyingPower?: true
    initialMargin?: true
    lastMaintenanceMargin?: true
    longMarketValue?: true
    shortMarketValue?: true
    maintenanceMargin?: true
    multiplier?: true
    sma?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    name?: true
    accountId?: true
    marketValue?: true
    buyingPower?: true
    cash?: true
    currency?: true
    daytradeCount?: true
    daytradeBuyingPower?: true
    regulationTBuyingPower?: true
    initialMargin?: true
    lastMaintenanceMargin?: true
    longMarketValue?: true
    shortMarketValue?: true
    maintenanceMargin?: true
    multiplier?: true
    sma?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    name?: true
    accountId?: true
    marketValue?: true
    buyingPower?: true
    cash?: true
    currency?: true
    daytradeCount?: true
    daytradeBuyingPower?: true
    regulationTBuyingPower?: true
    initialMargin?: true
    lastMaintenanceMargin?: true
    longMarketValue?: true
    shortMarketValue?: true
    maintenanceMargin?: true
    multiplier?: true
    sma?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    name?: true
    accountId?: true
    marketValue?: true
    buyingPower?: true
    cash?: true
    currency?: true
    daytradeCount?: true
    daytradeBuyingPower?: true
    regulationTBuyingPower?: true
    initialMargin?: true
    lastMaintenanceMargin?: true
    longMarketValue?: true
    shortMarketValue?: true
    maintenanceMargin?: true
    multiplier?: true
    sma?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountsAggregateArgs = {
    /**
     * Filter which Accounts to aggregate.
     * 
    **/
    where?: AccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type AccountsGroupByArgs = {
    where?: AccountsWhereInput
    orderBy?: Enumerable<AccountsOrderByWithAggregationInput>
    by: Array<AccountsScalarFieldEnum>
    having?: AccountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }


  export type AccountsGroupByOutputType = {
    id: string
    name: string
    accountId: string | null
    marketValue: Decimal | null
    buyingPower: Decimal | null
    cash: Decimal | null
    currency: string
    daytradeCount: number
    daytradeBuyingPower: Decimal | null
    regulationTBuyingPower: Decimal | null
    initialMargin: Decimal | null
    lastMaintenanceMargin: Decimal | null
    longMarketValue: Decimal | null
    shortMarketValue: Decimal | null
    maintenanceMargin: Decimal | null
    multiplier: Decimal | null
    sma: Decimal | null
    status: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends AccountsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type AccountsSelect = {
    id?: boolean
    name?: boolean
    accountId?: boolean
    marketValue?: boolean
    buyingPower?: boolean
    cash?: boolean
    currency?: boolean
    daytradeCount?: boolean
    daytradeBuyingPower?: boolean
    regulationTBuyingPower?: boolean
    initialMargin?: boolean
    lastMaintenanceMargin?: boolean
    longMarketValue?: boolean
    shortMarketValue?: boolean
    maintenanceMargin?: boolean
    multiplier?: boolean
    sma?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Orders?: boolean | OrdersFindManyArgs
    Positions?: boolean | PositionsFindManyArgs
    _count?: boolean | AccountsCountOutputTypeArgs
  }

  export type AccountsInclude = {
    Orders?: boolean | OrdersFindManyArgs
    Positions?: boolean | PositionsFindManyArgs
    _count?: boolean | AccountsCountOutputTypeArgs
  }

  export type AccountsGetPayload<
    S extends boolean | null | undefined | AccountsArgs,
    U = keyof S
      > = S extends true
        ? Accounts
    : S extends undefined
    ? never
    : S extends AccountsArgs | AccountsFindManyArgs
    ?'include' extends U
    ? Accounts  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Orders' ? Array < OrdersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Positions' ? Array < PositionsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? AccountsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Orders' ? Array < OrdersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Positions' ? Array < PositionsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? AccountsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Accounts ? Accounts[P] : never
  } 
    : Accounts
  : Accounts


  type AccountsCountArgs = Merge<
    Omit<AccountsFindManyArgs, 'select' | 'include'> & {
      select?: AccountsCountAggregateInputType | true
    }
  >

  export interface AccountsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {AccountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Accounts'> extends True ? CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>> : CheckSelect<T, Prisma__AccountsClient<Accounts | null, null>, Prisma__AccountsClient<AccountsGetPayload<T> | null, null>>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Accounts'> extends True ? CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>> : CheckSelect<T, Prisma__AccountsClient<Accounts | null, null>, Prisma__AccountsClient<AccountsGetPayload<T> | null, null>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountsFindManyArgs>(
      args?: SelectSubset<T, AccountsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Accounts>>, PrismaPromise<Array<AccountsGetPayload<T>>>>

    /**
     * Create a Accounts.
     * @param {AccountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
    **/
    create<T extends AccountsCreateArgs>(
      args: SelectSubset<T, AccountsCreateArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Create many Accounts.
     *     @param {AccountsCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const accounts = await prisma.accounts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountsCreateManyArgs>(
      args?: SelectSubset<T, AccountsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Accounts.
     * @param {AccountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
    **/
    delete<T extends AccountsDeleteArgs>(
      args: SelectSubset<T, AccountsDeleteArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Update one Accounts.
     * @param {AccountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountsUpdateArgs>(
      args: SelectSubset<T, AccountsUpdateArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Delete zero or more Accounts.
     * @param {AccountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountsDeleteManyArgs>(
      args?: SelectSubset<T, AccountsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountsUpdateManyArgs>(
      args: SelectSubset<T, AccountsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Accounts.
     * @param {AccountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
    **/
    upsert<T extends AccountsUpsertArgs>(
      args: SelectSubset<T, AccountsUpsertArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Find one Accounts that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AccountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AccountsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Find the first Accounts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AccountsClient<Accounts>, Prisma__AccountsClient<AccountsGetPayload<T>>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountsCountArgs>(
      args?: Subset<T, AccountsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountsGroupByArgs['orderBy'] }
        : { orderBy?: AccountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Orders<T extends OrdersFindManyArgs = {}>(args?: Subset<T, OrdersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Orders>| Null>, PrismaPromise<Array<OrdersGetPayload<T>>| Null>>;

    Positions<T extends PositionsFindManyArgs = {}>(args?: Subset<T, PositionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Positions>| Null>, PrismaPromise<Array<PositionsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Accounts base type for findUnique actions
   */
  export type AccountsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where: AccountsWhereUniqueInput
  }

  /**
   * Accounts: findUnique
   */
  export interface AccountsFindUniqueArgs extends AccountsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Accounts base type for findFirst actions
   */
  export type AccountsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     * 
    **/
    cursor?: AccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     * 
    **/
    distinct?: Enumerable<AccountsScalarFieldEnum>
  }

  /**
   * Accounts: findFirst
   */
  export interface AccountsFindFirstArgs extends AccountsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Accounts findMany
   */
  export type AccountsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * Filter, which Accounts to fetch.
     * 
    **/
    where?: AccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     * 
    **/
    orderBy?: Enumerable<AccountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     * 
    **/
    cursor?: AccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AccountsScalarFieldEnum>
  }


  /**
   * Accounts create
   */
  export type AccountsCreateArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * The data needed to create a Accounts.
     * 
    **/
    data: XOR<AccountsCreateInput, AccountsUncheckedCreateInput>
  }


  /**
   * Accounts createMany
   */
  export type AccountsCreateManyArgs = {
    /**
     * The data used to create many Accounts.
     * 
    **/
    data: Enumerable<AccountsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Accounts update
   */
  export type AccountsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * The data needed to update a Accounts.
     * 
    **/
    data: XOR<AccountsUpdateInput, AccountsUncheckedUpdateInput>
    /**
     * Choose, which Accounts to update.
     * 
    **/
    where: AccountsWhereUniqueInput
  }


  /**
   * Accounts updateMany
   */
  export type AccountsUpdateManyArgs = {
    /**
     * The data used to update Accounts.
     * 
    **/
    data: XOR<AccountsUpdateManyMutationInput, AccountsUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     * 
    **/
    where?: AccountsWhereInput
  }


  /**
   * Accounts upsert
   */
  export type AccountsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * The filter to search for the Accounts to update in case it exists.
     * 
    **/
    where: AccountsWhereUniqueInput
    /**
     * In case the Accounts found by the `where` argument doesn't exist, create a new Accounts with this data.
     * 
    **/
    create: XOR<AccountsCreateInput, AccountsUncheckedCreateInput>
    /**
     * In case the Accounts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AccountsUpdateInput, AccountsUncheckedUpdateInput>
  }


  /**
   * Accounts delete
   */
  export type AccountsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
    /**
     * Filter which Accounts to delete.
     * 
    **/
    where: AccountsWhereUniqueInput
  }


  /**
   * Accounts deleteMany
   */
  export type AccountsDeleteManyArgs = {
    /**
     * Filter which Accounts to delete
     * 
    **/
    where?: AccountsWhereInput
  }


  /**
   * Accounts: findUniqueOrThrow
   */
  export type AccountsFindUniqueOrThrowArgs = AccountsFindUniqueArgsBase
      

  /**
   * Accounts: findFirstOrThrow
   */
  export type AccountsFindFirstOrThrowArgs = AccountsFindFirstArgsBase
      

  /**
   * Accounts without action
   */
  export type AccountsArgs = {
    /**
     * Select specific fields to fetch from the Accounts
     * 
    **/
    select?: AccountsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AccountsInclude | null
  }



  /**
   * Model AmeritradeEvents
   */


  export type AggregateAmeritradeEvents = {
    _count: AmeritradeEventsCountAggregateOutputType | null
    _min: AmeritradeEventsMinAggregateOutputType | null
    _max: AmeritradeEventsMaxAggregateOutputType | null
  }

  export type AmeritradeEventsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmeritradeEventsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmeritradeEventsCountAggregateOutputType = {
    id: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmeritradeEventsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmeritradeEventsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmeritradeEventsCountAggregateInputType = {
    id?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmeritradeEventsAggregateArgs = {
    /**
     * Filter which AmeritradeEvents to aggregate.
     * 
    **/
    where?: AmeritradeEventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmeritradeEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<AmeritradeEventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AmeritradeEventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmeritradeEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmeritradeEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmeritradeEvents
    **/
    _count?: true | AmeritradeEventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmeritradeEventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmeritradeEventsMaxAggregateInputType
  }

  export type GetAmeritradeEventsAggregateType<T extends AmeritradeEventsAggregateArgs> = {
        [P in keyof T & keyof AggregateAmeritradeEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmeritradeEvents[P]>
      : GetScalarType<T[P], AggregateAmeritradeEvents[P]>
  }




  export type AmeritradeEventsGroupByArgs = {
    where?: AmeritradeEventsWhereInput
    orderBy?: Enumerable<AmeritradeEventsOrderByWithAggregationInput>
    by: Array<AmeritradeEventsScalarFieldEnum>
    having?: AmeritradeEventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmeritradeEventsCountAggregateInputType | true
    _min?: AmeritradeEventsMinAggregateInputType
    _max?: AmeritradeEventsMaxAggregateInputType
  }


  export type AmeritradeEventsGroupByOutputType = {
    id: string
    message: JsonValue
    createdAt: Date
    updatedAt: Date | null
    _count: AmeritradeEventsCountAggregateOutputType | null
    _min: AmeritradeEventsMinAggregateOutputType | null
    _max: AmeritradeEventsMaxAggregateOutputType | null
  }

  type GetAmeritradeEventsGroupByPayload<T extends AmeritradeEventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AmeritradeEventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmeritradeEventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmeritradeEventsGroupByOutputType[P]>
            : GetScalarType<T[P], AmeritradeEventsGroupByOutputType[P]>
        }
      >
    >


  export type AmeritradeEventsSelect = {
    id?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmeritradeEventsGetPayload<
    S extends boolean | null | undefined | AmeritradeEventsArgs,
    U = keyof S
      > = S extends true
        ? AmeritradeEvents
    : S extends undefined
    ? never
    : S extends AmeritradeEventsArgs | AmeritradeEventsFindManyArgs
    ?'include' extends U
    ? AmeritradeEvents 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AmeritradeEvents ? AmeritradeEvents[P] : never
  } 
    : AmeritradeEvents
  : AmeritradeEvents


  type AmeritradeEventsCountArgs = Merge<
    Omit<AmeritradeEventsFindManyArgs, 'select' | 'include'> & {
      select?: AmeritradeEventsCountAggregateInputType | true
    }
  >

  export interface AmeritradeEventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AmeritradeEvents that matches the filter.
     * @param {AmeritradeEventsFindUniqueArgs} args - Arguments to find a AmeritradeEvents
     * @example
     * // Get one AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AmeritradeEventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AmeritradeEventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AmeritradeEvents'> extends True ? CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T>>> : CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents | null, null>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T> | null, null>>

    /**
     * Find the first AmeritradeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeEventsFindFirstArgs} args - Arguments to find a AmeritradeEvents
     * @example
     * // Get one AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AmeritradeEventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AmeritradeEventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AmeritradeEvents'> extends True ? CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T>>> : CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents | null, null>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T> | null, null>>

    /**
     * Find zero or more AmeritradeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeEventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.findMany()
     * 
     * // Get first 10 AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ameritradeEventsWithIdOnly = await prisma.ameritradeEvents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AmeritradeEventsFindManyArgs>(
      args?: SelectSubset<T, AmeritradeEventsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AmeritradeEvents>>, PrismaPromise<Array<AmeritradeEventsGetPayload<T>>>>

    /**
     * Create a AmeritradeEvents.
     * @param {AmeritradeEventsCreateArgs} args - Arguments to create a AmeritradeEvents.
     * @example
     * // Create one AmeritradeEvents
     * const AmeritradeEvents = await prisma.ameritradeEvents.create({
     *   data: {
     *     // ... data to create a AmeritradeEvents
     *   }
     * })
     * 
    **/
    create<T extends AmeritradeEventsCreateArgs>(
      args: SelectSubset<T, AmeritradeEventsCreateArgs>
    ): CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T>>>

    /**
     * Create many AmeritradeEvents.
     *     @param {AmeritradeEventsCreateManyArgs} args - Arguments to create many AmeritradeEvents.
     *     @example
     *     // Create many AmeritradeEvents
     *     const ameritradeEvents = await prisma.ameritradeEvents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AmeritradeEventsCreateManyArgs>(
      args?: SelectSubset<T, AmeritradeEventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AmeritradeEvents.
     * @param {AmeritradeEventsDeleteArgs} args - Arguments to delete one AmeritradeEvents.
     * @example
     * // Delete one AmeritradeEvents
     * const AmeritradeEvents = await prisma.ameritradeEvents.delete({
     *   where: {
     *     // ... filter to delete one AmeritradeEvents
     *   }
     * })
     * 
    **/
    delete<T extends AmeritradeEventsDeleteArgs>(
      args: SelectSubset<T, AmeritradeEventsDeleteArgs>
    ): CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T>>>

    /**
     * Update one AmeritradeEvents.
     * @param {AmeritradeEventsUpdateArgs} args - Arguments to update one AmeritradeEvents.
     * @example
     * // Update one AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AmeritradeEventsUpdateArgs>(
      args: SelectSubset<T, AmeritradeEventsUpdateArgs>
    ): CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T>>>

    /**
     * Delete zero or more AmeritradeEvents.
     * @param {AmeritradeEventsDeleteManyArgs} args - Arguments to filter AmeritradeEvents to delete.
     * @example
     * // Delete a few AmeritradeEvents
     * const { count } = await prisma.ameritradeEvents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AmeritradeEventsDeleteManyArgs>(
      args?: SelectSubset<T, AmeritradeEventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmeritradeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeEventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AmeritradeEventsUpdateManyArgs>(
      args: SelectSubset<T, AmeritradeEventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AmeritradeEvents.
     * @param {AmeritradeEventsUpsertArgs} args - Arguments to update or create a AmeritradeEvents.
     * @example
     * // Update or create a AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.upsert({
     *   create: {
     *     // ... data to create a AmeritradeEvents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmeritradeEvents we want to update
     *   }
     * })
    **/
    upsert<T extends AmeritradeEventsUpsertArgs>(
      args: SelectSubset<T, AmeritradeEventsUpsertArgs>
    ): CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T>>>

    /**
     * Find one AmeritradeEvents that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AmeritradeEventsFindUniqueOrThrowArgs} args - Arguments to find a AmeritradeEvents
     * @example
     * // Get one AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AmeritradeEventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AmeritradeEventsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T>>>

    /**
     * Find the first AmeritradeEvents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeEventsFindFirstOrThrowArgs} args - Arguments to find a AmeritradeEvents
     * @example
     * // Get one AmeritradeEvents
     * const ameritradeEvents = await prisma.ameritradeEvents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AmeritradeEventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AmeritradeEventsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AmeritradeEventsClient<AmeritradeEvents>, Prisma__AmeritradeEventsClient<AmeritradeEventsGetPayload<T>>>

    /**
     * Count the number of AmeritradeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeEventsCountArgs} args - Arguments to filter AmeritradeEvents to count.
     * @example
     * // Count the number of AmeritradeEvents
     * const count = await prisma.ameritradeEvents.count({
     *   where: {
     *     // ... the filter for the AmeritradeEvents we want to count
     *   }
     * })
    **/
    count<T extends AmeritradeEventsCountArgs>(
      args?: Subset<T, AmeritradeEventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmeritradeEventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmeritradeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeEventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmeritradeEventsAggregateArgs>(args: Subset<T, AmeritradeEventsAggregateArgs>): PrismaPromise<GetAmeritradeEventsAggregateType<T>>

    /**
     * Group by AmeritradeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeEventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmeritradeEventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmeritradeEventsGroupByArgs['orderBy'] }
        : { orderBy?: AmeritradeEventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmeritradeEventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmeritradeEventsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AmeritradeEvents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AmeritradeEventsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AmeritradeEvents base type for findUnique actions
   */
  export type AmeritradeEventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AmeritradeEvents
     * 
    **/
    select?: AmeritradeEventsSelect | null
    /**
     * Filter, which AmeritradeEvents to fetch.
     * 
    **/
    where: AmeritradeEventsWhereUniqueInput
  }

  /**
   * AmeritradeEvents: findUnique
   */
  export interface AmeritradeEventsFindUniqueArgs extends AmeritradeEventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AmeritradeEvents base type for findFirst actions
   */
  export type AmeritradeEventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AmeritradeEvents
     * 
    **/
    select?: AmeritradeEventsSelect | null
    /**
     * Filter, which AmeritradeEvents to fetch.
     * 
    **/
    where?: AmeritradeEventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmeritradeEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<AmeritradeEventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmeritradeEvents.
     * 
    **/
    cursor?: AmeritradeEventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmeritradeEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmeritradeEvents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmeritradeEvents.
     * 
    **/
    distinct?: Enumerable<AmeritradeEventsScalarFieldEnum>
  }

  /**
   * AmeritradeEvents: findFirst
   */
  export interface AmeritradeEventsFindFirstArgs extends AmeritradeEventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AmeritradeEvents findMany
   */
  export type AmeritradeEventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeEvents
     * 
    **/
    select?: AmeritradeEventsSelect | null
    /**
     * Filter, which AmeritradeEvents to fetch.
     * 
    **/
    where?: AmeritradeEventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmeritradeEvents to fetch.
     * 
    **/
    orderBy?: Enumerable<AmeritradeEventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmeritradeEvents.
     * 
    **/
    cursor?: AmeritradeEventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmeritradeEvents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmeritradeEvents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AmeritradeEventsScalarFieldEnum>
  }


  /**
   * AmeritradeEvents create
   */
  export type AmeritradeEventsCreateArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeEvents
     * 
    **/
    select?: AmeritradeEventsSelect | null
    /**
     * The data needed to create a AmeritradeEvents.
     * 
    **/
    data: XOR<AmeritradeEventsCreateInput, AmeritradeEventsUncheckedCreateInput>
  }


  /**
   * AmeritradeEvents createMany
   */
  export type AmeritradeEventsCreateManyArgs = {
    /**
     * The data used to create many AmeritradeEvents.
     * 
    **/
    data: Enumerable<AmeritradeEventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AmeritradeEvents update
   */
  export type AmeritradeEventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeEvents
     * 
    **/
    select?: AmeritradeEventsSelect | null
    /**
     * The data needed to update a AmeritradeEvents.
     * 
    **/
    data: XOR<AmeritradeEventsUpdateInput, AmeritradeEventsUncheckedUpdateInput>
    /**
     * Choose, which AmeritradeEvents to update.
     * 
    **/
    where: AmeritradeEventsWhereUniqueInput
  }


  /**
   * AmeritradeEvents updateMany
   */
  export type AmeritradeEventsUpdateManyArgs = {
    /**
     * The data used to update AmeritradeEvents.
     * 
    **/
    data: XOR<AmeritradeEventsUpdateManyMutationInput, AmeritradeEventsUncheckedUpdateManyInput>
    /**
     * Filter which AmeritradeEvents to update
     * 
    **/
    where?: AmeritradeEventsWhereInput
  }


  /**
   * AmeritradeEvents upsert
   */
  export type AmeritradeEventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeEvents
     * 
    **/
    select?: AmeritradeEventsSelect | null
    /**
     * The filter to search for the AmeritradeEvents to update in case it exists.
     * 
    **/
    where: AmeritradeEventsWhereUniqueInput
    /**
     * In case the AmeritradeEvents found by the `where` argument doesn't exist, create a new AmeritradeEvents with this data.
     * 
    **/
    create: XOR<AmeritradeEventsCreateInput, AmeritradeEventsUncheckedCreateInput>
    /**
     * In case the AmeritradeEvents was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AmeritradeEventsUpdateInput, AmeritradeEventsUncheckedUpdateInput>
  }


  /**
   * AmeritradeEvents delete
   */
  export type AmeritradeEventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeEvents
     * 
    **/
    select?: AmeritradeEventsSelect | null
    /**
     * Filter which AmeritradeEvents to delete.
     * 
    **/
    where: AmeritradeEventsWhereUniqueInput
  }


  /**
   * AmeritradeEvents deleteMany
   */
  export type AmeritradeEventsDeleteManyArgs = {
    /**
     * Filter which AmeritradeEvents to delete
     * 
    **/
    where?: AmeritradeEventsWhereInput
  }


  /**
   * AmeritradeEvents: findUniqueOrThrow
   */
  export type AmeritradeEventsFindUniqueOrThrowArgs = AmeritradeEventsFindUniqueArgsBase
      

  /**
   * AmeritradeEvents: findFirstOrThrow
   */
  export type AmeritradeEventsFindFirstOrThrowArgs = AmeritradeEventsFindFirstArgsBase
      

  /**
   * AmeritradeEvents without action
   */
  export type AmeritradeEventsArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeEvents
     * 
    **/
    select?: AmeritradeEventsSelect | null
  }



  /**
   * Model AmeritradeTokens
   */


  export type AggregateAmeritradeTokens = {
    _count: AmeritradeTokensCountAggregateOutputType | null
    _avg: AmeritradeTokensAvgAggregateOutputType | null
    _sum: AmeritradeTokensSumAggregateOutputType | null
    _min: AmeritradeTokensMinAggregateOutputType | null
    _max: AmeritradeTokensMaxAggregateOutputType | null
  }

  export type AmeritradeTokensAvgAggregateOutputType = {
    id: number | null
  }

  export type AmeritradeTokensSumAggregateOutputType = {
    id: number | null
  }

  export type AmeritradeTokensMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmeritradeTokensMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmeritradeTokensCountAggregateOutputType = {
    id: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmeritradeTokensAvgAggregateInputType = {
    id?: true
  }

  export type AmeritradeTokensSumAggregateInputType = {
    id?: true
  }

  export type AmeritradeTokensMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmeritradeTokensMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmeritradeTokensCountAggregateInputType = {
    id?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmeritradeTokensAggregateArgs = {
    /**
     * Filter which AmeritradeTokens to aggregate.
     * 
    **/
    where?: AmeritradeTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmeritradeTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<AmeritradeTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AmeritradeTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmeritradeTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmeritradeTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmeritradeTokens
    **/
    _count?: true | AmeritradeTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmeritradeTokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmeritradeTokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmeritradeTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmeritradeTokensMaxAggregateInputType
  }

  export type GetAmeritradeTokensAggregateType<T extends AmeritradeTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateAmeritradeTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmeritradeTokens[P]>
      : GetScalarType<T[P], AggregateAmeritradeTokens[P]>
  }




  export type AmeritradeTokensGroupByArgs = {
    where?: AmeritradeTokensWhereInput
    orderBy?: Enumerable<AmeritradeTokensOrderByWithAggregationInput>
    by: Array<AmeritradeTokensScalarFieldEnum>
    having?: AmeritradeTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmeritradeTokensCountAggregateInputType | true
    _avg?: AmeritradeTokensAvgAggregateInputType
    _sum?: AmeritradeTokensSumAggregateInputType
    _min?: AmeritradeTokensMinAggregateInputType
    _max?: AmeritradeTokensMaxAggregateInputType
  }


  export type AmeritradeTokensGroupByOutputType = {
    id: number
    data: JsonValue
    createdAt: Date
    updatedAt: Date | null
    _count: AmeritradeTokensCountAggregateOutputType | null
    _avg: AmeritradeTokensAvgAggregateOutputType | null
    _sum: AmeritradeTokensSumAggregateOutputType | null
    _min: AmeritradeTokensMinAggregateOutputType | null
    _max: AmeritradeTokensMaxAggregateOutputType | null
  }

  type GetAmeritradeTokensGroupByPayload<T extends AmeritradeTokensGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AmeritradeTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmeritradeTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmeritradeTokensGroupByOutputType[P]>
            : GetScalarType<T[P], AmeritradeTokensGroupByOutputType[P]>
        }
      >
    >


  export type AmeritradeTokensSelect = {
    id?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmeritradeTokensGetPayload<
    S extends boolean | null | undefined | AmeritradeTokensArgs,
    U = keyof S
      > = S extends true
        ? AmeritradeTokens
    : S extends undefined
    ? never
    : S extends AmeritradeTokensArgs | AmeritradeTokensFindManyArgs
    ?'include' extends U
    ? AmeritradeTokens 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AmeritradeTokens ? AmeritradeTokens[P] : never
  } 
    : AmeritradeTokens
  : AmeritradeTokens


  type AmeritradeTokensCountArgs = Merge<
    Omit<AmeritradeTokensFindManyArgs, 'select' | 'include'> & {
      select?: AmeritradeTokensCountAggregateInputType | true
    }
  >

  export interface AmeritradeTokensDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AmeritradeTokens that matches the filter.
     * @param {AmeritradeTokensFindUniqueArgs} args - Arguments to find a AmeritradeTokens
     * @example
     * // Get one AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AmeritradeTokensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AmeritradeTokensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AmeritradeTokens'> extends True ? CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T>>> : CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens | null, null>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T> | null, null>>

    /**
     * Find the first AmeritradeTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeTokensFindFirstArgs} args - Arguments to find a AmeritradeTokens
     * @example
     * // Get one AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AmeritradeTokensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AmeritradeTokensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AmeritradeTokens'> extends True ? CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T>>> : CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens | null, null>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T> | null, null>>

    /**
     * Find zero or more AmeritradeTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeTokensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.findMany()
     * 
     * // Get first 10 AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ameritradeTokensWithIdOnly = await prisma.ameritradeTokens.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AmeritradeTokensFindManyArgs>(
      args?: SelectSubset<T, AmeritradeTokensFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AmeritradeTokens>>, PrismaPromise<Array<AmeritradeTokensGetPayload<T>>>>

    /**
     * Create a AmeritradeTokens.
     * @param {AmeritradeTokensCreateArgs} args - Arguments to create a AmeritradeTokens.
     * @example
     * // Create one AmeritradeTokens
     * const AmeritradeTokens = await prisma.ameritradeTokens.create({
     *   data: {
     *     // ... data to create a AmeritradeTokens
     *   }
     * })
     * 
    **/
    create<T extends AmeritradeTokensCreateArgs>(
      args: SelectSubset<T, AmeritradeTokensCreateArgs>
    ): CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T>>>

    /**
     * Create many AmeritradeTokens.
     *     @param {AmeritradeTokensCreateManyArgs} args - Arguments to create many AmeritradeTokens.
     *     @example
     *     // Create many AmeritradeTokens
     *     const ameritradeTokens = await prisma.ameritradeTokens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AmeritradeTokensCreateManyArgs>(
      args?: SelectSubset<T, AmeritradeTokensCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AmeritradeTokens.
     * @param {AmeritradeTokensDeleteArgs} args - Arguments to delete one AmeritradeTokens.
     * @example
     * // Delete one AmeritradeTokens
     * const AmeritradeTokens = await prisma.ameritradeTokens.delete({
     *   where: {
     *     // ... filter to delete one AmeritradeTokens
     *   }
     * })
     * 
    **/
    delete<T extends AmeritradeTokensDeleteArgs>(
      args: SelectSubset<T, AmeritradeTokensDeleteArgs>
    ): CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T>>>

    /**
     * Update one AmeritradeTokens.
     * @param {AmeritradeTokensUpdateArgs} args - Arguments to update one AmeritradeTokens.
     * @example
     * // Update one AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AmeritradeTokensUpdateArgs>(
      args: SelectSubset<T, AmeritradeTokensUpdateArgs>
    ): CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T>>>

    /**
     * Delete zero or more AmeritradeTokens.
     * @param {AmeritradeTokensDeleteManyArgs} args - Arguments to filter AmeritradeTokens to delete.
     * @example
     * // Delete a few AmeritradeTokens
     * const { count } = await prisma.ameritradeTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AmeritradeTokensDeleteManyArgs>(
      args?: SelectSubset<T, AmeritradeTokensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmeritradeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AmeritradeTokensUpdateManyArgs>(
      args: SelectSubset<T, AmeritradeTokensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AmeritradeTokens.
     * @param {AmeritradeTokensUpsertArgs} args - Arguments to update or create a AmeritradeTokens.
     * @example
     * // Update or create a AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.upsert({
     *   create: {
     *     // ... data to create a AmeritradeTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmeritradeTokens we want to update
     *   }
     * })
    **/
    upsert<T extends AmeritradeTokensUpsertArgs>(
      args: SelectSubset<T, AmeritradeTokensUpsertArgs>
    ): CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T>>>

    /**
     * Find one AmeritradeTokens that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {AmeritradeTokensFindUniqueOrThrowArgs} args - Arguments to find a AmeritradeTokens
     * @example
     * // Get one AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AmeritradeTokensFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AmeritradeTokensFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T>>>

    /**
     * Find the first AmeritradeTokens that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeTokensFindFirstOrThrowArgs} args - Arguments to find a AmeritradeTokens
     * @example
     * // Get one AmeritradeTokens
     * const ameritradeTokens = await prisma.ameritradeTokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AmeritradeTokensFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AmeritradeTokensFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__AmeritradeTokensClient<AmeritradeTokens>, Prisma__AmeritradeTokensClient<AmeritradeTokensGetPayload<T>>>

    /**
     * Count the number of AmeritradeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeTokensCountArgs} args - Arguments to filter AmeritradeTokens to count.
     * @example
     * // Count the number of AmeritradeTokens
     * const count = await prisma.ameritradeTokens.count({
     *   where: {
     *     // ... the filter for the AmeritradeTokens we want to count
     *   }
     * })
    **/
    count<T extends AmeritradeTokensCountArgs>(
      args?: Subset<T, AmeritradeTokensCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmeritradeTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmeritradeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmeritradeTokensAggregateArgs>(args: Subset<T, AmeritradeTokensAggregateArgs>): PrismaPromise<GetAmeritradeTokensAggregateType<T>>

    /**
     * Group by AmeritradeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmeritradeTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmeritradeTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmeritradeTokensGroupByArgs['orderBy'] }
        : { orderBy?: AmeritradeTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmeritradeTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmeritradeTokensGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AmeritradeTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AmeritradeTokensClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AmeritradeTokens base type for findUnique actions
   */
  export type AmeritradeTokensFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AmeritradeTokens
     * 
    **/
    select?: AmeritradeTokensSelect | null
    /**
     * Filter, which AmeritradeTokens to fetch.
     * 
    **/
    where: AmeritradeTokensWhereUniqueInput
  }

  /**
   * AmeritradeTokens: findUnique
   */
  export interface AmeritradeTokensFindUniqueArgs extends AmeritradeTokensFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AmeritradeTokens base type for findFirst actions
   */
  export type AmeritradeTokensFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AmeritradeTokens
     * 
    **/
    select?: AmeritradeTokensSelect | null
    /**
     * Filter, which AmeritradeTokens to fetch.
     * 
    **/
    where?: AmeritradeTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmeritradeTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<AmeritradeTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmeritradeTokens.
     * 
    **/
    cursor?: AmeritradeTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmeritradeTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmeritradeTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmeritradeTokens.
     * 
    **/
    distinct?: Enumerable<AmeritradeTokensScalarFieldEnum>
  }

  /**
   * AmeritradeTokens: findFirst
   */
  export interface AmeritradeTokensFindFirstArgs extends AmeritradeTokensFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AmeritradeTokens findMany
   */
  export type AmeritradeTokensFindManyArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeTokens
     * 
    **/
    select?: AmeritradeTokensSelect | null
    /**
     * Filter, which AmeritradeTokens to fetch.
     * 
    **/
    where?: AmeritradeTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmeritradeTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<AmeritradeTokensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmeritradeTokens.
     * 
    **/
    cursor?: AmeritradeTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmeritradeTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmeritradeTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AmeritradeTokensScalarFieldEnum>
  }


  /**
   * AmeritradeTokens create
   */
  export type AmeritradeTokensCreateArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeTokens
     * 
    **/
    select?: AmeritradeTokensSelect | null
    /**
     * The data needed to create a AmeritradeTokens.
     * 
    **/
    data: XOR<AmeritradeTokensCreateInput, AmeritradeTokensUncheckedCreateInput>
  }


  /**
   * AmeritradeTokens createMany
   */
  export type AmeritradeTokensCreateManyArgs = {
    /**
     * The data used to create many AmeritradeTokens.
     * 
    **/
    data: Enumerable<AmeritradeTokensCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AmeritradeTokens update
   */
  export type AmeritradeTokensUpdateArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeTokens
     * 
    **/
    select?: AmeritradeTokensSelect | null
    /**
     * The data needed to update a AmeritradeTokens.
     * 
    **/
    data: XOR<AmeritradeTokensUpdateInput, AmeritradeTokensUncheckedUpdateInput>
    /**
     * Choose, which AmeritradeTokens to update.
     * 
    **/
    where: AmeritradeTokensWhereUniqueInput
  }


  /**
   * AmeritradeTokens updateMany
   */
  export type AmeritradeTokensUpdateManyArgs = {
    /**
     * The data used to update AmeritradeTokens.
     * 
    **/
    data: XOR<AmeritradeTokensUpdateManyMutationInput, AmeritradeTokensUncheckedUpdateManyInput>
    /**
     * Filter which AmeritradeTokens to update
     * 
    **/
    where?: AmeritradeTokensWhereInput
  }


  /**
   * AmeritradeTokens upsert
   */
  export type AmeritradeTokensUpsertArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeTokens
     * 
    **/
    select?: AmeritradeTokensSelect | null
    /**
     * The filter to search for the AmeritradeTokens to update in case it exists.
     * 
    **/
    where: AmeritradeTokensWhereUniqueInput
    /**
     * In case the AmeritradeTokens found by the `where` argument doesn't exist, create a new AmeritradeTokens with this data.
     * 
    **/
    create: XOR<AmeritradeTokensCreateInput, AmeritradeTokensUncheckedCreateInput>
    /**
     * In case the AmeritradeTokens was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AmeritradeTokensUpdateInput, AmeritradeTokensUncheckedUpdateInput>
  }


  /**
   * AmeritradeTokens delete
   */
  export type AmeritradeTokensDeleteArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeTokens
     * 
    **/
    select?: AmeritradeTokensSelect | null
    /**
     * Filter which AmeritradeTokens to delete.
     * 
    **/
    where: AmeritradeTokensWhereUniqueInput
  }


  /**
   * AmeritradeTokens deleteMany
   */
  export type AmeritradeTokensDeleteManyArgs = {
    /**
     * Filter which AmeritradeTokens to delete
     * 
    **/
    where?: AmeritradeTokensWhereInput
  }


  /**
   * AmeritradeTokens: findUniqueOrThrow
   */
  export type AmeritradeTokensFindUniqueOrThrowArgs = AmeritradeTokensFindUniqueArgsBase
      

  /**
   * AmeritradeTokens: findFirstOrThrow
   */
  export type AmeritradeTokensFindFirstOrThrowArgs = AmeritradeTokensFindFirstArgsBase
      

  /**
   * AmeritradeTokens without action
   */
  export type AmeritradeTokensArgs = {
    /**
     * Select specific fields to fetch from the AmeritradeTokens
     * 
    **/
    select?: AmeritradeTokensSelect | null
  }



  /**
   * Model BackTesting
   */


  export type AggregateBackTesting = {
    _count: BackTestingCountAggregateOutputType | null
    _avg: BackTestingAvgAggregateOutputType | null
    _sum: BackTestingSumAggregateOutputType | null
    _min: BackTestingMinAggregateOutputType | null
    _max: BackTestingMaxAggregateOutputType | null
  }

  export type BackTestingAvgAggregateOutputType = {
    marginPercentage: Decimal | null
    averageInterestRate: Decimal | null
    finalBalance: Decimal | null
    profits: Decimal | null
    losses: Decimal | null
    highestInterestDay: Decimal | null
    lowestInterestDay: Decimal | null
    unrealizedProfit: Decimal | null
  }

  export type BackTestingSumAggregateOutputType = {
    marginPercentage: Decimal | null
    averageInterestRate: Decimal | null
    finalBalance: Decimal | null
    profits: Decimal | null
    losses: Decimal | null
    highestInterestDay: Decimal | null
    lowestInterestDay: Decimal | null
    unrealizedProfit: Decimal | null
  }

  export type BackTestingMinAggregateOutputType = {
    id: string | null
    strategy: string | null
    startDate: Date | null
    endDate: Date | null
    resultLog: string | null
    marginPercentage: Decimal | null
    averageInterestRate: Decimal | null
    finalBalance: Decimal | null
    profits: Decimal | null
    losses: Decimal | null
    highestInterestDay: Decimal | null
    lowestInterestDay: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    unrealizedProfit: Decimal | null
  }

  export type BackTestingMaxAggregateOutputType = {
    id: string | null
    strategy: string | null
    startDate: Date | null
    endDate: Date | null
    resultLog: string | null
    marginPercentage: Decimal | null
    averageInterestRate: Decimal | null
    finalBalance: Decimal | null
    profits: Decimal | null
    losses: Decimal | null
    highestInterestDay: Decimal | null
    lowestInterestDay: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    unrealizedProfit: Decimal | null
  }

  export type BackTestingCountAggregateOutputType = {
    id: number
    strategy: number
    strategyParameters: number
    startDate: number
    endDate: number
    resultLog: number
    marginPercentage: number
    averageInterestRate: number
    finalBalance: number
    profits: number
    losses: number
    highestInterestDay: number
    lowestInterestDay: number
    createdAt: number
    updatedAt: number
    code: number
    unrealizedProfit: number
    _all: number
  }


  export type BackTestingAvgAggregateInputType = {
    marginPercentage?: true
    averageInterestRate?: true
    finalBalance?: true
    profits?: true
    losses?: true
    highestInterestDay?: true
    lowestInterestDay?: true
    unrealizedProfit?: true
  }

  export type BackTestingSumAggregateInputType = {
    marginPercentage?: true
    averageInterestRate?: true
    finalBalance?: true
    profits?: true
    losses?: true
    highestInterestDay?: true
    lowestInterestDay?: true
    unrealizedProfit?: true
  }

  export type BackTestingMinAggregateInputType = {
    id?: true
    strategy?: true
    startDate?: true
    endDate?: true
    resultLog?: true
    marginPercentage?: true
    averageInterestRate?: true
    finalBalance?: true
    profits?: true
    losses?: true
    highestInterestDay?: true
    lowestInterestDay?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    unrealizedProfit?: true
  }

  export type BackTestingMaxAggregateInputType = {
    id?: true
    strategy?: true
    startDate?: true
    endDate?: true
    resultLog?: true
    marginPercentage?: true
    averageInterestRate?: true
    finalBalance?: true
    profits?: true
    losses?: true
    highestInterestDay?: true
    lowestInterestDay?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    unrealizedProfit?: true
  }

  export type BackTestingCountAggregateInputType = {
    id?: true
    strategy?: true
    strategyParameters?: true
    startDate?: true
    endDate?: true
    resultLog?: true
    marginPercentage?: true
    averageInterestRate?: true
    finalBalance?: true
    profits?: true
    losses?: true
    highestInterestDay?: true
    lowestInterestDay?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    unrealizedProfit?: true
    _all?: true
  }

  export type BackTestingAggregateArgs = {
    /**
     * Filter which BackTesting to aggregate.
     * 
    **/
    where?: BackTestingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackTestings to fetch.
     * 
    **/
    orderBy?: Enumerable<BackTestingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BackTestingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackTestings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackTestings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BackTestings
    **/
    _count?: true | BackTestingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BackTestingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BackTestingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackTestingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackTestingMaxAggregateInputType
  }

  export type GetBackTestingAggregateType<T extends BackTestingAggregateArgs> = {
        [P in keyof T & keyof AggregateBackTesting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackTesting[P]>
      : GetScalarType<T[P], AggregateBackTesting[P]>
  }




  export type BackTestingGroupByArgs = {
    where?: BackTestingWhereInput
    orderBy?: Enumerable<BackTestingOrderByWithAggregationInput>
    by: Array<BackTestingScalarFieldEnum>
    having?: BackTestingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackTestingCountAggregateInputType | true
    _avg?: BackTestingAvgAggregateInputType
    _sum?: BackTestingSumAggregateInputType
    _min?: BackTestingMinAggregateInputType
    _max?: BackTestingMaxAggregateInputType
  }


  export type BackTestingGroupByOutputType = {
    id: string
    strategy: string
    strategyParameters: JsonValue | null
    startDate: Date
    endDate: Date
    resultLog: string | null
    marginPercentage: Decimal
    averageInterestRate: Decimal
    finalBalance: Decimal
    profits: Decimal
    losses: Decimal
    highestInterestDay: Decimal
    lowestInterestDay: Decimal
    createdAt: Date
    updatedAt: Date | null
    code: string | null
    unrealizedProfit: Decimal | null
    _count: BackTestingCountAggregateOutputType | null
    _avg: BackTestingAvgAggregateOutputType | null
    _sum: BackTestingSumAggregateOutputType | null
    _min: BackTestingMinAggregateOutputType | null
    _max: BackTestingMaxAggregateOutputType | null
  }

  type GetBackTestingGroupByPayload<T extends BackTestingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BackTestingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackTestingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackTestingGroupByOutputType[P]>
            : GetScalarType<T[P], BackTestingGroupByOutputType[P]>
        }
      >
    >


  export type BackTestingSelect = {
    id?: boolean
    strategy?: boolean
    strategyParameters?: boolean
    startDate?: boolean
    endDate?: boolean
    resultLog?: boolean
    marginPercentage?: boolean
    averageInterestRate?: boolean
    finalBalance?: boolean
    profits?: boolean
    losses?: boolean
    highestInterestDay?: boolean
    lowestInterestDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    unrealizedProfit?: boolean
  }

  export type BackTestingGetPayload<
    S extends boolean | null | undefined | BackTestingArgs,
    U = keyof S
      > = S extends true
        ? BackTesting
    : S extends undefined
    ? never
    : S extends BackTestingArgs | BackTestingFindManyArgs
    ?'include' extends U
    ? BackTesting 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BackTesting ? BackTesting[P] : never
  } 
    : BackTesting
  : BackTesting


  type BackTestingCountArgs = Merge<
    Omit<BackTestingFindManyArgs, 'select' | 'include'> & {
      select?: BackTestingCountAggregateInputType | true
    }
  >

  export interface BackTestingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one BackTesting that matches the filter.
     * @param {BackTestingFindUniqueArgs} args - Arguments to find a BackTesting
     * @example
     * // Get one BackTesting
     * const backTesting = await prisma.backTesting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BackTestingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BackTestingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BackTesting'> extends True ? CheckSelect<T, Prisma__BackTestingClient<BackTesting>, Prisma__BackTestingClient<BackTestingGetPayload<T>>> : CheckSelect<T, Prisma__BackTestingClient<BackTesting | null, null>, Prisma__BackTestingClient<BackTestingGetPayload<T> | null, null>>

    /**
     * Find the first BackTesting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackTestingFindFirstArgs} args - Arguments to find a BackTesting
     * @example
     * // Get one BackTesting
     * const backTesting = await prisma.backTesting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BackTestingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BackTestingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BackTesting'> extends True ? CheckSelect<T, Prisma__BackTestingClient<BackTesting>, Prisma__BackTestingClient<BackTestingGetPayload<T>>> : CheckSelect<T, Prisma__BackTestingClient<BackTesting | null, null>, Prisma__BackTestingClient<BackTestingGetPayload<T> | null, null>>

    /**
     * Find zero or more BackTestings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackTestingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BackTestings
     * const backTestings = await prisma.backTesting.findMany()
     * 
     * // Get first 10 BackTestings
     * const backTestings = await prisma.backTesting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backTestingWithIdOnly = await prisma.backTesting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BackTestingFindManyArgs>(
      args?: SelectSubset<T, BackTestingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<BackTesting>>, PrismaPromise<Array<BackTestingGetPayload<T>>>>

    /**
     * Create a BackTesting.
     * @param {BackTestingCreateArgs} args - Arguments to create a BackTesting.
     * @example
     * // Create one BackTesting
     * const BackTesting = await prisma.backTesting.create({
     *   data: {
     *     // ... data to create a BackTesting
     *   }
     * })
     * 
    **/
    create<T extends BackTestingCreateArgs>(
      args: SelectSubset<T, BackTestingCreateArgs>
    ): CheckSelect<T, Prisma__BackTestingClient<BackTesting>, Prisma__BackTestingClient<BackTestingGetPayload<T>>>

    /**
     * Create many BackTestings.
     *     @param {BackTestingCreateManyArgs} args - Arguments to create many BackTestings.
     *     @example
     *     // Create many BackTestings
     *     const backTesting = await prisma.backTesting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BackTestingCreateManyArgs>(
      args?: SelectSubset<T, BackTestingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BackTesting.
     * @param {BackTestingDeleteArgs} args - Arguments to delete one BackTesting.
     * @example
     * // Delete one BackTesting
     * const BackTesting = await prisma.backTesting.delete({
     *   where: {
     *     // ... filter to delete one BackTesting
     *   }
     * })
     * 
    **/
    delete<T extends BackTestingDeleteArgs>(
      args: SelectSubset<T, BackTestingDeleteArgs>
    ): CheckSelect<T, Prisma__BackTestingClient<BackTesting>, Prisma__BackTestingClient<BackTestingGetPayload<T>>>

    /**
     * Update one BackTesting.
     * @param {BackTestingUpdateArgs} args - Arguments to update one BackTesting.
     * @example
     * // Update one BackTesting
     * const backTesting = await prisma.backTesting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BackTestingUpdateArgs>(
      args: SelectSubset<T, BackTestingUpdateArgs>
    ): CheckSelect<T, Prisma__BackTestingClient<BackTesting>, Prisma__BackTestingClient<BackTestingGetPayload<T>>>

    /**
     * Delete zero or more BackTestings.
     * @param {BackTestingDeleteManyArgs} args - Arguments to filter BackTestings to delete.
     * @example
     * // Delete a few BackTestings
     * const { count } = await prisma.backTesting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BackTestingDeleteManyArgs>(
      args?: SelectSubset<T, BackTestingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackTestings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackTestingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BackTestings
     * const backTesting = await prisma.backTesting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BackTestingUpdateManyArgs>(
      args: SelectSubset<T, BackTestingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BackTesting.
     * @param {BackTestingUpsertArgs} args - Arguments to update or create a BackTesting.
     * @example
     * // Update or create a BackTesting
     * const backTesting = await prisma.backTesting.upsert({
     *   create: {
     *     // ... data to create a BackTesting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BackTesting we want to update
     *   }
     * })
    **/
    upsert<T extends BackTestingUpsertArgs>(
      args: SelectSubset<T, BackTestingUpsertArgs>
    ): CheckSelect<T, Prisma__BackTestingClient<BackTesting>, Prisma__BackTestingClient<BackTestingGetPayload<T>>>

    /**
     * Find one BackTesting that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {BackTestingFindUniqueOrThrowArgs} args - Arguments to find a BackTesting
     * @example
     * // Get one BackTesting
     * const backTesting = await prisma.backTesting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BackTestingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BackTestingFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__BackTestingClient<BackTesting>, Prisma__BackTestingClient<BackTestingGetPayload<T>>>

    /**
     * Find the first BackTesting that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackTestingFindFirstOrThrowArgs} args - Arguments to find a BackTesting
     * @example
     * // Get one BackTesting
     * const backTesting = await prisma.backTesting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BackTestingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BackTestingFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__BackTestingClient<BackTesting>, Prisma__BackTestingClient<BackTestingGetPayload<T>>>

    /**
     * Count the number of BackTestings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackTestingCountArgs} args - Arguments to filter BackTestings to count.
     * @example
     * // Count the number of BackTestings
     * const count = await prisma.backTesting.count({
     *   where: {
     *     // ... the filter for the BackTestings we want to count
     *   }
     * })
    **/
    count<T extends BackTestingCountArgs>(
      args?: Subset<T, BackTestingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackTestingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BackTesting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackTestingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackTestingAggregateArgs>(args: Subset<T, BackTestingAggregateArgs>): PrismaPromise<GetBackTestingAggregateType<T>>

    /**
     * Group by BackTesting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackTestingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackTestingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackTestingGroupByArgs['orderBy'] }
        : { orderBy?: BackTestingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackTestingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackTestingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BackTesting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BackTestingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BackTesting base type for findUnique actions
   */
  export type BackTestingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BackTesting
     * 
    **/
    select?: BackTestingSelect | null
    /**
     * Filter, which BackTesting to fetch.
     * 
    **/
    where: BackTestingWhereUniqueInput
  }

  /**
   * BackTesting: findUnique
   */
  export interface BackTestingFindUniqueArgs extends BackTestingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BackTesting base type for findFirst actions
   */
  export type BackTestingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BackTesting
     * 
    **/
    select?: BackTestingSelect | null
    /**
     * Filter, which BackTesting to fetch.
     * 
    **/
    where?: BackTestingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackTestings to fetch.
     * 
    **/
    orderBy?: Enumerable<BackTestingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackTestings.
     * 
    **/
    cursor?: BackTestingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackTestings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackTestings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackTestings.
     * 
    **/
    distinct?: Enumerable<BackTestingScalarFieldEnum>
  }

  /**
   * BackTesting: findFirst
   */
  export interface BackTestingFindFirstArgs extends BackTestingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BackTesting findMany
   */
  export type BackTestingFindManyArgs = {
    /**
     * Select specific fields to fetch from the BackTesting
     * 
    **/
    select?: BackTestingSelect | null
    /**
     * Filter, which BackTestings to fetch.
     * 
    **/
    where?: BackTestingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackTestings to fetch.
     * 
    **/
    orderBy?: Enumerable<BackTestingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BackTestings.
     * 
    **/
    cursor?: BackTestingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackTestings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackTestings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BackTestingScalarFieldEnum>
  }


  /**
   * BackTesting create
   */
  export type BackTestingCreateArgs = {
    /**
     * Select specific fields to fetch from the BackTesting
     * 
    **/
    select?: BackTestingSelect | null
    /**
     * The data needed to create a BackTesting.
     * 
    **/
    data: XOR<BackTestingCreateInput, BackTestingUncheckedCreateInput>
  }


  /**
   * BackTesting createMany
   */
  export type BackTestingCreateManyArgs = {
    /**
     * The data used to create many BackTestings.
     * 
    **/
    data: Enumerable<BackTestingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BackTesting update
   */
  export type BackTestingUpdateArgs = {
    /**
     * Select specific fields to fetch from the BackTesting
     * 
    **/
    select?: BackTestingSelect | null
    /**
     * The data needed to update a BackTesting.
     * 
    **/
    data: XOR<BackTestingUpdateInput, BackTestingUncheckedUpdateInput>
    /**
     * Choose, which BackTesting to update.
     * 
    **/
    where: BackTestingWhereUniqueInput
  }


  /**
   * BackTesting updateMany
   */
  export type BackTestingUpdateManyArgs = {
    /**
     * The data used to update BackTestings.
     * 
    **/
    data: XOR<BackTestingUpdateManyMutationInput, BackTestingUncheckedUpdateManyInput>
    /**
     * Filter which BackTestings to update
     * 
    **/
    where?: BackTestingWhereInput
  }


  /**
   * BackTesting upsert
   */
  export type BackTestingUpsertArgs = {
    /**
     * Select specific fields to fetch from the BackTesting
     * 
    **/
    select?: BackTestingSelect | null
    /**
     * The filter to search for the BackTesting to update in case it exists.
     * 
    **/
    where: BackTestingWhereUniqueInput
    /**
     * In case the BackTesting found by the `where` argument doesn't exist, create a new BackTesting with this data.
     * 
    **/
    create: XOR<BackTestingCreateInput, BackTestingUncheckedCreateInput>
    /**
     * In case the BackTesting was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BackTestingUpdateInput, BackTestingUncheckedUpdateInput>
  }


  /**
   * BackTesting delete
   */
  export type BackTestingDeleteArgs = {
    /**
     * Select specific fields to fetch from the BackTesting
     * 
    **/
    select?: BackTestingSelect | null
    /**
     * Filter which BackTesting to delete.
     * 
    **/
    where: BackTestingWhereUniqueInput
  }


  /**
   * BackTesting deleteMany
   */
  export type BackTestingDeleteManyArgs = {
    /**
     * Filter which BackTestings to delete
     * 
    **/
    where?: BackTestingWhereInput
  }


  /**
   * BackTesting: findUniqueOrThrow
   */
  export type BackTestingFindUniqueOrThrowArgs = BackTestingFindUniqueArgsBase
      

  /**
   * BackTesting: findFirstOrThrow
   */
  export type BackTestingFindFirstOrThrowArgs = BackTestingFindFirstArgsBase
      

  /**
   * BackTesting without action
   */
  export type BackTestingArgs = {
    /**
     * Select specific fields to fetch from the BackTesting
     * 
    **/
    select?: BackTestingSelect | null
  }



  /**
   * Model Exchanges
   */


  export type AggregateExchanges = {
    _count: ExchangesCountAggregateOutputType | null
    _avg: ExchangesAvgAggregateOutputType | null
    _sum: ExchangesSumAggregateOutputType | null
    _min: ExchangesMinAggregateOutputType | null
    _max: ExchangesMaxAggregateOutputType | null
  }

  export type ExchangesAvgAggregateOutputType = {
    id: number | null
  }

  export type ExchangesSumAggregateOutputType = {
    id: number | null
  }

  export type ExchangesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    assetClass: string | null
    locale: string | null
    acronym: string | null
    mic: string | null
    operatingMic: string | null
    participantId: string | null
    url: string | null
  }

  export type ExchangesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    assetClass: string | null
    locale: string | null
    acronym: string | null
    mic: string | null
    operatingMic: string | null
    participantId: string | null
    url: string | null
  }

  export type ExchangesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    assetClass: number
    locale: number
    acronym: number
    mic: number
    operatingMic: number
    participantId: number
    url: number
    _all: number
  }


  export type ExchangesAvgAggregateInputType = {
    id?: true
  }

  export type ExchangesSumAggregateInputType = {
    id?: true
  }

  export type ExchangesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    assetClass?: true
    locale?: true
    acronym?: true
    mic?: true
    operatingMic?: true
    participantId?: true
    url?: true
  }

  export type ExchangesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    assetClass?: true
    locale?: true
    acronym?: true
    mic?: true
    operatingMic?: true
    participantId?: true
    url?: true
  }

  export type ExchangesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    assetClass?: true
    locale?: true
    acronym?: true
    mic?: true
    operatingMic?: true
    participantId?: true
    url?: true
    _all?: true
  }

  export type ExchangesAggregateArgs = {
    /**
     * Filter which Exchanges to aggregate.
     * 
    **/
    where?: ExchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exchanges to fetch.
     * 
    **/
    orderBy?: Enumerable<ExchangesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exchanges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exchanges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exchanges
    **/
    _count?: true | ExchangesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangesMaxAggregateInputType
  }

  export type GetExchangesAggregateType<T extends ExchangesAggregateArgs> = {
        [P in keyof T & keyof AggregateExchanges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchanges[P]>
      : GetScalarType<T[P], AggregateExchanges[P]>
  }




  export type ExchangesGroupByArgs = {
    where?: ExchangesWhereInput
    orderBy?: Enumerable<ExchangesOrderByWithAggregationInput>
    by: Array<ExchangesScalarFieldEnum>
    having?: ExchangesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangesCountAggregateInputType | true
    _avg?: ExchangesAvgAggregateInputType
    _sum?: ExchangesSumAggregateInputType
    _min?: ExchangesMinAggregateInputType
    _max?: ExchangesMaxAggregateInputType
  }


  export type ExchangesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    assetClass: string | null
    locale: string | null
    acronym: string | null
    mic: string | null
    operatingMic: string | null
    participantId: string | null
    url: string | null
    _count: ExchangesCountAggregateOutputType | null
    _avg: ExchangesAvgAggregateOutputType | null
    _sum: ExchangesSumAggregateOutputType | null
    _min: ExchangesMinAggregateOutputType | null
    _max: ExchangesMaxAggregateOutputType | null
  }

  type GetExchangesGroupByPayload<T extends ExchangesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExchangesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangesGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangesGroupByOutputType[P]>
        }
      >
    >


  export type ExchangesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    assetClass?: boolean
    locale?: boolean
    acronym?: boolean
    mic?: boolean
    operatingMic?: boolean
    participantId?: boolean
    url?: boolean
    Trades?: boolean | TradesFindManyArgs
    AskQuotes?: boolean | QuotesFindManyArgs
    BidQuotes?: boolean | QuotesFindManyArgs
    _count?: boolean | ExchangesCountOutputTypeArgs
  }

  export type ExchangesInclude = {
    Trades?: boolean | TradesFindManyArgs
    AskQuotes?: boolean | QuotesFindManyArgs
    BidQuotes?: boolean | QuotesFindManyArgs
    _count?: boolean | ExchangesCountOutputTypeArgs
  }

  export type ExchangesGetPayload<
    S extends boolean | null | undefined | ExchangesArgs,
    U = keyof S
      > = S extends true
        ? Exchanges
    : S extends undefined
    ? never
    : S extends ExchangesArgs | ExchangesFindManyArgs
    ?'include' extends U
    ? Exchanges  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Trades' ? Array < TradesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'AskQuotes' ? Array < QuotesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'BidQuotes' ? Array < QuotesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ExchangesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Trades' ? Array < TradesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'AskQuotes' ? Array < QuotesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'BidQuotes' ? Array < QuotesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ExchangesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Exchanges ? Exchanges[P] : never
  } 
    : Exchanges
  : Exchanges


  type ExchangesCountArgs = Merge<
    Omit<ExchangesFindManyArgs, 'select' | 'include'> & {
      select?: ExchangesCountAggregateInputType | true
    }
  >

  export interface ExchangesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Exchanges that matches the filter.
     * @param {ExchangesFindUniqueArgs} args - Arguments to find a Exchanges
     * @example
     * // Get one Exchanges
     * const exchanges = await prisma.exchanges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExchangesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExchangesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Exchanges'> extends True ? CheckSelect<T, Prisma__ExchangesClient<Exchanges>, Prisma__ExchangesClient<ExchangesGetPayload<T>>> : CheckSelect<T, Prisma__ExchangesClient<Exchanges | null, null>, Prisma__ExchangesClient<ExchangesGetPayload<T> | null, null>>

    /**
     * Find the first Exchanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesFindFirstArgs} args - Arguments to find a Exchanges
     * @example
     * // Get one Exchanges
     * const exchanges = await prisma.exchanges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExchangesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExchangesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Exchanges'> extends True ? CheckSelect<T, Prisma__ExchangesClient<Exchanges>, Prisma__ExchangesClient<ExchangesGetPayload<T>>> : CheckSelect<T, Prisma__ExchangesClient<Exchanges | null, null>, Prisma__ExchangesClient<ExchangesGetPayload<T> | null, null>>

    /**
     * Find zero or more Exchanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exchanges
     * const exchanges = await prisma.exchanges.findMany()
     * 
     * // Get first 10 Exchanges
     * const exchanges = await prisma.exchanges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangesWithIdOnly = await prisma.exchanges.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExchangesFindManyArgs>(
      args?: SelectSubset<T, ExchangesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Exchanges>>, PrismaPromise<Array<ExchangesGetPayload<T>>>>

    /**
     * Create a Exchanges.
     * @param {ExchangesCreateArgs} args - Arguments to create a Exchanges.
     * @example
     * // Create one Exchanges
     * const Exchanges = await prisma.exchanges.create({
     *   data: {
     *     // ... data to create a Exchanges
     *   }
     * })
     * 
    **/
    create<T extends ExchangesCreateArgs>(
      args: SelectSubset<T, ExchangesCreateArgs>
    ): CheckSelect<T, Prisma__ExchangesClient<Exchanges>, Prisma__ExchangesClient<ExchangesGetPayload<T>>>

    /**
     * Create many Exchanges.
     *     @param {ExchangesCreateManyArgs} args - Arguments to create many Exchanges.
     *     @example
     *     // Create many Exchanges
     *     const exchanges = await prisma.exchanges.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExchangesCreateManyArgs>(
      args?: SelectSubset<T, ExchangesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Exchanges.
     * @param {ExchangesDeleteArgs} args - Arguments to delete one Exchanges.
     * @example
     * // Delete one Exchanges
     * const Exchanges = await prisma.exchanges.delete({
     *   where: {
     *     // ... filter to delete one Exchanges
     *   }
     * })
     * 
    **/
    delete<T extends ExchangesDeleteArgs>(
      args: SelectSubset<T, ExchangesDeleteArgs>
    ): CheckSelect<T, Prisma__ExchangesClient<Exchanges>, Prisma__ExchangesClient<ExchangesGetPayload<T>>>

    /**
     * Update one Exchanges.
     * @param {ExchangesUpdateArgs} args - Arguments to update one Exchanges.
     * @example
     * // Update one Exchanges
     * const exchanges = await prisma.exchanges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExchangesUpdateArgs>(
      args: SelectSubset<T, ExchangesUpdateArgs>
    ): CheckSelect<T, Prisma__ExchangesClient<Exchanges>, Prisma__ExchangesClient<ExchangesGetPayload<T>>>

    /**
     * Delete zero or more Exchanges.
     * @param {ExchangesDeleteManyArgs} args - Arguments to filter Exchanges to delete.
     * @example
     * // Delete a few Exchanges
     * const { count } = await prisma.exchanges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExchangesDeleteManyArgs>(
      args?: SelectSubset<T, ExchangesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exchanges
     * const exchanges = await prisma.exchanges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExchangesUpdateManyArgs>(
      args: SelectSubset<T, ExchangesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Exchanges.
     * @param {ExchangesUpsertArgs} args - Arguments to update or create a Exchanges.
     * @example
     * // Update or create a Exchanges
     * const exchanges = await prisma.exchanges.upsert({
     *   create: {
     *     // ... data to create a Exchanges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exchanges we want to update
     *   }
     * })
    **/
    upsert<T extends ExchangesUpsertArgs>(
      args: SelectSubset<T, ExchangesUpsertArgs>
    ): CheckSelect<T, Prisma__ExchangesClient<Exchanges>, Prisma__ExchangesClient<ExchangesGetPayload<T>>>

    /**
     * Find one Exchanges that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ExchangesFindUniqueOrThrowArgs} args - Arguments to find a Exchanges
     * @example
     * // Get one Exchanges
     * const exchanges = await prisma.exchanges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExchangesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ExchangesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ExchangesClient<Exchanges>, Prisma__ExchangesClient<ExchangesGetPayload<T>>>

    /**
     * Find the first Exchanges that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesFindFirstOrThrowArgs} args - Arguments to find a Exchanges
     * @example
     * // Get one Exchanges
     * const exchanges = await prisma.exchanges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExchangesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExchangesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ExchangesClient<Exchanges>, Prisma__ExchangesClient<ExchangesGetPayload<T>>>

    /**
     * Count the number of Exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesCountArgs} args - Arguments to filter Exchanges to count.
     * @example
     * // Count the number of Exchanges
     * const count = await prisma.exchanges.count({
     *   where: {
     *     // ... the filter for the Exchanges we want to count
     *   }
     * })
    **/
    count<T extends ExchangesCountArgs>(
      args?: Subset<T, ExchangesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangesAggregateArgs>(args: Subset<T, ExchangesAggregateArgs>): PrismaPromise<GetExchangesAggregateType<T>>

    /**
     * Group by Exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangesGroupByArgs['orderBy'] }
        : { orderBy?: ExchangesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Exchanges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExchangesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Trades<T extends TradesFindManyArgs = {}>(args?: Subset<T, TradesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Trades>| Null>, PrismaPromise<Array<TradesGetPayload<T>>| Null>>;

    AskQuotes<T extends QuotesFindManyArgs = {}>(args?: Subset<T, QuotesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Quotes>| Null>, PrismaPromise<Array<QuotesGetPayload<T>>| Null>>;

    BidQuotes<T extends QuotesFindManyArgs = {}>(args?: Subset<T, QuotesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Quotes>| Null>, PrismaPromise<Array<QuotesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Exchanges base type for findUnique actions
   */
  export type ExchangesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Exchanges
     * 
    **/
    select?: ExchangesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExchangesInclude | null
    /**
     * Filter, which Exchanges to fetch.
     * 
    **/
    where: ExchangesWhereUniqueInput
  }

  /**
   * Exchanges: findUnique
   */
  export interface ExchangesFindUniqueArgs extends ExchangesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Exchanges base type for findFirst actions
   */
  export type ExchangesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Exchanges
     * 
    **/
    select?: ExchangesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExchangesInclude | null
    /**
     * Filter, which Exchanges to fetch.
     * 
    **/
    where?: ExchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exchanges to fetch.
     * 
    **/
    orderBy?: Enumerable<ExchangesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exchanges.
     * 
    **/
    cursor?: ExchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exchanges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exchanges.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exchanges.
     * 
    **/
    distinct?: Enumerable<ExchangesScalarFieldEnum>
  }

  /**
   * Exchanges: findFirst
   */
  export interface ExchangesFindFirstArgs extends ExchangesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Exchanges findMany
   */
  export type ExchangesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Exchanges
     * 
    **/
    select?: ExchangesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExchangesInclude | null
    /**
     * Filter, which Exchanges to fetch.
     * 
    **/
    where?: ExchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exchanges to fetch.
     * 
    **/
    orderBy?: Enumerable<ExchangesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exchanges.
     * 
    **/
    cursor?: ExchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exchanges from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exchanges.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExchangesScalarFieldEnum>
  }


  /**
   * Exchanges create
   */
  export type ExchangesCreateArgs = {
    /**
     * Select specific fields to fetch from the Exchanges
     * 
    **/
    select?: ExchangesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExchangesInclude | null
    /**
     * The data needed to create a Exchanges.
     * 
    **/
    data: XOR<ExchangesCreateInput, ExchangesUncheckedCreateInput>
  }


  /**
   * Exchanges createMany
   */
  export type ExchangesCreateManyArgs = {
    /**
     * The data used to create many Exchanges.
     * 
    **/
    data: Enumerable<ExchangesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Exchanges update
   */
  export type ExchangesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Exchanges
     * 
    **/
    select?: ExchangesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExchangesInclude | null
    /**
     * The data needed to update a Exchanges.
     * 
    **/
    data: XOR<ExchangesUpdateInput, ExchangesUncheckedUpdateInput>
    /**
     * Choose, which Exchanges to update.
     * 
    **/
    where: ExchangesWhereUniqueInput
  }


  /**
   * Exchanges updateMany
   */
  export type ExchangesUpdateManyArgs = {
    /**
     * The data used to update Exchanges.
     * 
    **/
    data: XOR<ExchangesUpdateManyMutationInput, ExchangesUncheckedUpdateManyInput>
    /**
     * Filter which Exchanges to update
     * 
    **/
    where?: ExchangesWhereInput
  }


  /**
   * Exchanges upsert
   */
  export type ExchangesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Exchanges
     * 
    **/
    select?: ExchangesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExchangesInclude | null
    /**
     * The filter to search for the Exchanges to update in case it exists.
     * 
    **/
    where: ExchangesWhereUniqueInput
    /**
     * In case the Exchanges found by the `where` argument doesn't exist, create a new Exchanges with this data.
     * 
    **/
    create: XOR<ExchangesCreateInput, ExchangesUncheckedCreateInput>
    /**
     * In case the Exchanges was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExchangesUpdateInput, ExchangesUncheckedUpdateInput>
  }


  /**
   * Exchanges delete
   */
  export type ExchangesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Exchanges
     * 
    **/
    select?: ExchangesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExchangesInclude | null
    /**
     * Filter which Exchanges to delete.
     * 
    **/
    where: ExchangesWhereUniqueInput
  }


  /**
   * Exchanges deleteMany
   */
  export type ExchangesDeleteManyArgs = {
    /**
     * Filter which Exchanges to delete
     * 
    **/
    where?: ExchangesWhereInput
  }


  /**
   * Exchanges: findUniqueOrThrow
   */
  export type ExchangesFindUniqueOrThrowArgs = ExchangesFindUniqueArgsBase
      

  /**
   * Exchanges: findFirstOrThrow
   */
  export type ExchangesFindFirstOrThrowArgs = ExchangesFindFirstArgsBase
      

  /**
   * Exchanges without action
   */
  export type ExchangesArgs = {
    /**
     * Select specific fields to fetch from the Exchanges
     * 
    **/
    select?: ExchangesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExchangesInclude | null
  }



  /**
   * Model migrations
   */


  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    name: string | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    name: string | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    timestamp: number
    name: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
    _all?: true
  }

  export type MigrationsAggregateArgs = {
    /**
     * Filter which migrations to aggregate.
     * 
    **/
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     * 
    **/
    orderBy?: Enumerable<migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type MigrationsGroupByArgs = {
    where?: migrationsWhereInput
    orderBy?: Enumerable<migrationsOrderByWithAggregationInput>
    by: Array<MigrationsScalarFieldEnum>
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }


  export type MigrationsGroupByOutputType = {
    id: number
    timestamp: bigint
    name: string
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends MigrationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect = {
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }

  export type migrationsGetPayload<
    S extends boolean | null | undefined | migrationsArgs,
    U = keyof S
      > = S extends true
        ? migrations
    : S extends undefined
    ? never
    : S extends migrationsArgs | migrationsFindManyArgs
    ?'include' extends U
    ? migrations 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof migrations ? migrations[P] : never
  } 
    : migrations
  : migrations


  type migrationsCountArgs = Merge<
    Omit<migrationsFindManyArgs, 'select' | 'include'> & {
      select?: MigrationsCountAggregateInputType | true
    }
  >

  export interface migrationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends migrationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, migrationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'migrations'> extends True ? CheckSelect<T, Prisma__migrationsClient<migrations>, Prisma__migrationsClient<migrationsGetPayload<T>>> : CheckSelect<T, Prisma__migrationsClient<migrations | null, null>, Prisma__migrationsClient<migrationsGetPayload<T> | null, null>>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends migrationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, migrationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'migrations'> extends True ? CheckSelect<T, Prisma__migrationsClient<migrations>, Prisma__migrationsClient<migrationsGetPayload<T>>> : CheckSelect<T, Prisma__migrationsClient<migrations | null, null>, Prisma__migrationsClient<migrationsGetPayload<T> | null, null>>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends migrationsFindManyArgs>(
      args?: SelectSubset<T, migrationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<migrations>>, PrismaPromise<Array<migrationsGetPayload<T>>>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
    **/
    create<T extends migrationsCreateArgs>(
      args: SelectSubset<T, migrationsCreateArgs>
    ): CheckSelect<T, Prisma__migrationsClient<migrations>, Prisma__migrationsClient<migrationsGetPayload<T>>>

    /**
     * Create many Migrations.
     *     @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     *     @example
     *     // Create many Migrations
     *     const migrations = await prisma.migrations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends migrationsCreateManyArgs>(
      args?: SelectSubset<T, migrationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
    **/
    delete<T extends migrationsDeleteArgs>(
      args: SelectSubset<T, migrationsDeleteArgs>
    ): CheckSelect<T, Prisma__migrationsClient<migrations>, Prisma__migrationsClient<migrationsGetPayload<T>>>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends migrationsUpdateArgs>(
      args: SelectSubset<T, migrationsUpdateArgs>
    ): CheckSelect<T, Prisma__migrationsClient<migrations>, Prisma__migrationsClient<migrationsGetPayload<T>>>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends migrationsDeleteManyArgs>(
      args?: SelectSubset<T, migrationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends migrationsUpdateManyArgs>(
      args: SelectSubset<T, migrationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
    **/
    upsert<T extends migrationsUpsertArgs>(
      args: SelectSubset<T, migrationsUpsertArgs>
    ): CheckSelect<T, Prisma__migrationsClient<migrations>, Prisma__migrationsClient<migrationsGetPayload<T>>>

    /**
     * Find one Migrations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, migrationsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__migrationsClient<migrations>, Prisma__migrationsClient<migrationsGetPayload<T>>>

    /**
     * Find the first Migrations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, migrationsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__migrationsClient<migrations>, Prisma__migrationsClient<migrationsGetPayload<T>>>

    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MigrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MigrationsGroupByArgs['orderBy'] }
        : { orderBy?: MigrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MigrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__migrationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * migrations base type for findUnique actions
   */
  export type migrationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the migrations
     * 
    **/
    select?: migrationsSelect | null
    /**
     * Filter, which migrations to fetch.
     * 
    **/
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations: findUnique
   */
  export interface migrationsFindUniqueArgs extends migrationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * migrations base type for findFirst actions
   */
  export type migrationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the migrations
     * 
    **/
    select?: migrationsSelect | null
    /**
     * Filter, which migrations to fetch.
     * 
    **/
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     * 
    **/
    orderBy?: Enumerable<migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     * 
    **/
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     * 
    **/
    distinct?: Enumerable<MigrationsScalarFieldEnum>
  }

  /**
   * migrations: findFirst
   */
  export interface migrationsFindFirstArgs extends migrationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the migrations
     * 
    **/
    select?: migrationsSelect | null
    /**
     * Filter, which migrations to fetch.
     * 
    **/
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     * 
    **/
    orderBy?: Enumerable<migrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     * 
    **/
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MigrationsScalarFieldEnum>
  }


  /**
   * migrations create
   */
  export type migrationsCreateArgs = {
    /**
     * Select specific fields to fetch from the migrations
     * 
    **/
    select?: migrationsSelect | null
    /**
     * The data needed to create a migrations.
     * 
    **/
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }


  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs = {
    /**
     * The data used to create many migrations.
     * 
    **/
    data: Enumerable<migrationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * migrations update
   */
  export type migrationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the migrations
     * 
    **/
    select?: migrationsSelect | null
    /**
     * The data needed to update a migrations.
     * 
    **/
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     * 
    **/
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs = {
    /**
     * The data used to update migrations.
     * 
    **/
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     * 
    **/
    where?: migrationsWhereInput
  }


  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the migrations
     * 
    **/
    select?: migrationsSelect | null
    /**
     * The filter to search for the migrations to update in case it exists.
     * 
    **/
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     * 
    **/
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }


  /**
   * migrations delete
   */
  export type migrationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the migrations
     * 
    **/
    select?: migrationsSelect | null
    /**
     * Filter which migrations to delete.
     * 
    **/
    where: migrationsWhereUniqueInput
  }


  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs = {
    /**
     * Filter which migrations to delete
     * 
    **/
    where?: migrationsWhereInput
  }


  /**
   * migrations: findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs = migrationsFindUniqueArgsBase
      

  /**
   * migrations: findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs = migrationsFindFirstArgsBase
      

  /**
   * migrations without action
   */
  export type migrationsArgs = {
    /**
     * Select specific fields to fetch from the migrations
     * 
    **/
    select?: migrationsSelect | null
  }



  /**
   * Model Orders
   */


  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    securityId: number | null
    quantity: Decimal | null
    filledQuantity: Decimal | null
    stopPrice: Decimal | null
    limitPrice: Decimal | null
    filledAveragePrice: Decimal | null
    trailAmount: Decimal | null
  }

  export type OrdersSumAggregateOutputType = {
    securityId: number | null
    quantity: Decimal | null
    filledQuantity: Decimal | null
    stopPrice: Decimal | null
    limitPrice: Decimal | null
    filledAveragePrice: Decimal | null
    trailAmount: Decimal | null
  }

  export type OrdersMinAggregateOutputType = {
    id: string | null
    securityId: number | null
    strategyName: string | null
    accountId: string | null
    symbol: string | null
    name: string | null
    type: string | null
    timeInForce: string | null
    quantity: Decimal | null
    filledQuantity: Decimal | null
    filledTime: Date | null
    stopPrice: Decimal | null
    limitPrice: Decimal | null
    filledAveragePrice: Decimal | null
    status: string | null
    orderType: string | null
    trailAmount: Decimal | null
    extendedHours: boolean | null
    submittedAt: Date | null
    expiredAt: Date | null
    canceledAt: Date | null
    failedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: string | null
    securityId: number | null
    strategyName: string | null
    accountId: string | null
    symbol: string | null
    name: string | null
    type: string | null
    timeInForce: string | null
    quantity: Decimal | null
    filledQuantity: Decimal | null
    filledTime: Date | null
    stopPrice: Decimal | null
    limitPrice: Decimal | null
    filledAveragePrice: Decimal | null
    status: string | null
    orderType: string | null
    trailAmount: Decimal | null
    extendedHours: boolean | null
    submittedAt: Date | null
    expiredAt: Date | null
    canceledAt: Date | null
    failedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    securityId: number
    strategyName: number
    accountId: number
    symbol: number
    name: number
    type: number
    timeInForce: number
    quantity: number
    filledQuantity: number
    filledTime: number
    stopPrice: number
    limitPrice: number
    filledAveragePrice: number
    status: number
    orderType: number
    trailAmount: number
    extendedHours: number
    submittedAt: number
    expiredAt: number
    canceledAt: number
    failedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    securityId?: true
    quantity?: true
    filledQuantity?: true
    stopPrice?: true
    limitPrice?: true
    filledAveragePrice?: true
    trailAmount?: true
  }

  export type OrdersSumAggregateInputType = {
    securityId?: true
    quantity?: true
    filledQuantity?: true
    stopPrice?: true
    limitPrice?: true
    filledAveragePrice?: true
    trailAmount?: true
  }

  export type OrdersMinAggregateInputType = {
    id?: true
    securityId?: true
    strategyName?: true
    accountId?: true
    symbol?: true
    name?: true
    type?: true
    timeInForce?: true
    quantity?: true
    filledQuantity?: true
    filledTime?: true
    stopPrice?: true
    limitPrice?: true
    filledAveragePrice?: true
    status?: true
    orderType?: true
    trailAmount?: true
    extendedHours?: true
    submittedAt?: true
    expiredAt?: true
    canceledAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    securityId?: true
    strategyName?: true
    accountId?: true
    symbol?: true
    name?: true
    type?: true
    timeInForce?: true
    quantity?: true
    filledQuantity?: true
    filledTime?: true
    stopPrice?: true
    limitPrice?: true
    filledAveragePrice?: true
    status?: true
    orderType?: true
    trailAmount?: true
    extendedHours?: true
    submittedAt?: true
    expiredAt?: true
    canceledAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    securityId?: true
    strategyName?: true
    accountId?: true
    symbol?: true
    name?: true
    type?: true
    timeInForce?: true
    quantity?: true
    filledQuantity?: true
    filledTime?: true
    stopPrice?: true
    limitPrice?: true
    filledAveragePrice?: true
    status?: true
    orderType?: true
    trailAmount?: true
    extendedHours?: true
    submittedAt?: true
    expiredAt?: true
    canceledAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrdersAggregateArgs = {
    /**
     * Filter which Orders to aggregate.
     * 
    **/
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type OrdersGroupByArgs = {
    where?: OrdersWhereInput
    orderBy?: Enumerable<OrdersOrderByWithAggregationInput>
    by: Array<OrdersScalarFieldEnum>
    having?: OrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }


  export type OrdersGroupByOutputType = {
    id: string
    securityId: number
    strategyName: string | null
    accountId: string | null
    symbol: string
    name: string | null
    type: string
    timeInForce: string
    quantity: Decimal
    filledQuantity: Decimal
    filledTime: Date | null
    stopPrice: Decimal | null
    limitPrice: Decimal | null
    filledAveragePrice: Decimal | null
    status: string | null
    orderType: string | null
    trailAmount: Decimal | null
    extendedHours: boolean
    submittedAt: Date | null
    expiredAt: Date | null
    canceledAt: Date | null
    failedAt: Date | null
    createdAt: Date
    updatedAt: Date | null
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends OrdersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type OrdersSelect = {
    id?: boolean
    securityId?: boolean
    strategyName?: boolean
    accountId?: boolean
    symbol?: boolean
    name?: boolean
    type?: boolean
    timeInForce?: boolean
    quantity?: boolean
    filledQuantity?: boolean
    filledTime?: boolean
    stopPrice?: boolean
    limitPrice?: boolean
    filledAveragePrice?: boolean
    status?: boolean
    orderType?: boolean
    trailAmount?: boolean
    extendedHours?: boolean
    submittedAt?: boolean
    expiredAt?: boolean
    canceledAt?: boolean
    failedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Account?: boolean | AccountsArgs
    PositionOrders?: boolean | PositionOrdersFindManyArgs
    _count?: boolean | OrdersCountOutputTypeArgs
  }

  export type OrdersInclude = {
    Account?: boolean | AccountsArgs
    PositionOrders?: boolean | PositionOrdersFindManyArgs
    _count?: boolean | OrdersCountOutputTypeArgs
  }

  export type OrdersGetPayload<
    S extends boolean | null | undefined | OrdersArgs,
    U = keyof S
      > = S extends true
        ? Orders
    : S extends undefined
    ? never
    : S extends OrdersArgs | OrdersFindManyArgs
    ?'include' extends U
    ? Orders  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Account' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'PositionOrders' ? Array < PositionOrdersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OrdersCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Account' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'PositionOrders' ? Array < PositionOrdersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OrdersCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Orders ? Orders[P] : never
  } 
    : Orders
  : Orders


  type OrdersCountArgs = Merge<
    Omit<OrdersFindManyArgs, 'select' | 'include'> & {
      select?: OrdersCountAggregateInputType | true
    }
  >

  export interface OrdersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Orders that matches the filter.
     * @param {OrdersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrdersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrdersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Orders'> extends True ? CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>> : CheckSelect<T, Prisma__OrdersClient<Orders | null, null>, Prisma__OrdersClient<OrdersGetPayload<T> | null, null>>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrdersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrdersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Orders'> extends True ? CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>> : CheckSelect<T, Prisma__OrdersClient<Orders | null, null>, Prisma__OrdersClient<OrdersGetPayload<T> | null, null>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrdersFindManyArgs>(
      args?: SelectSubset<T, OrdersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Orders>>, PrismaPromise<Array<OrdersGetPayload<T>>>>

    /**
     * Create a Orders.
     * @param {OrdersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
    **/
    create<T extends OrdersCreateArgs>(
      args: SelectSubset<T, OrdersCreateArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrdersCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const orders = await prisma.orders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrdersCreateManyArgs>(
      args?: SelectSubset<T, OrdersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Orders.
     * @param {OrdersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
    **/
    delete<T extends OrdersDeleteArgs>(
      args: SelectSubset<T, OrdersDeleteArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Update one Orders.
     * @param {OrdersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrdersUpdateArgs>(
      args: SelectSubset<T, OrdersUpdateArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrdersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrdersDeleteManyArgs>(
      args?: SelectSubset<T, OrdersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrdersUpdateManyArgs>(
      args: SelectSubset<T, OrdersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Orders.
     * @param {OrdersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
    **/
    upsert<T extends OrdersUpsertArgs>(
      args: SelectSubset<T, OrdersUpsertArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Find one Orders that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {OrdersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrdersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrdersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Find the first Orders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrdersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrdersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__OrdersClient<Orders>, Prisma__OrdersClient<OrdersGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrdersCountArgs>(
      args?: Subset<T, OrdersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersGroupByArgs['orderBy'] }
        : { orderBy?: OrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrdersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Account<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    PositionOrders<T extends PositionOrdersFindManyArgs = {}>(args?: Subset<T, PositionOrdersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PositionOrders>| Null>, PrismaPromise<Array<PositionOrdersGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Orders base type for findUnique actions
   */
  export type OrdersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders: findUnique
   */
  export interface OrdersFindUniqueArgs extends OrdersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Orders base type for findFirst actions
   */
  export type OrdersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }

  /**
   * Orders: findFirst
   */
  export interface OrdersFindFirstArgs extends OrdersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Orders findMany
   */
  export type OrdersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }


  /**
   * Orders create
   */
  export type OrdersCreateArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * The data needed to create a Orders.
     * 
    **/
    data: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
  }


  /**
   * Orders createMany
   */
  export type OrdersCreateManyArgs = {
    /**
     * The data used to create many Orders.
     * 
    **/
    data: Enumerable<OrdersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Orders update
   */
  export type OrdersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * The data needed to update a Orders.
     * 
    **/
    data: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
    /**
     * Choose, which Orders to update.
     * 
    **/
    where: OrdersWhereUniqueInput
  }


  /**
   * Orders updateMany
   */
  export type OrdersUpdateManyArgs = {
    /**
     * The data used to update Orders.
     * 
    **/
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     * 
    **/
    where?: OrdersWhereInput
  }


  /**
   * Orders upsert
   */
  export type OrdersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * The filter to search for the Orders to update in case it exists.
     * 
    **/
    where: OrdersWhereUniqueInput
    /**
     * In case the Orders found by the `where` argument doesn't exist, create a new Orders with this data.
     * 
    **/
    create: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
    /**
     * In case the Orders was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
  }


  /**
   * Orders delete
   */
  export type OrdersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
    /**
     * Filter which Orders to delete.
     * 
    **/
    where: OrdersWhereUniqueInput
  }


  /**
   * Orders deleteMany
   */
  export type OrdersDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     * 
    **/
    where?: OrdersWhereInput
  }


  /**
   * Orders: findUniqueOrThrow
   */
  export type OrdersFindUniqueOrThrowArgs = OrdersFindUniqueArgsBase
      

  /**
   * Orders: findFirstOrThrow
   */
  export type OrdersFindFirstOrThrowArgs = OrdersFindFirstArgsBase
      

  /**
   * Orders without action
   */
  export type OrdersArgs = {
    /**
     * Select specific fields to fetch from the Orders
     * 
    **/
    select?: OrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrdersInclude | null
  }



  /**
   * Model Positions
   */


  export type AggregatePositions = {
    _count: PositionsCountAggregateOutputType | null
    _avg: PositionsAvgAggregateOutputType | null
    _sum: PositionsSumAggregateOutputType | null
    _min: PositionsMinAggregateOutputType | null
    _max: PositionsMaxAggregateOutputType | null
  }

  export type PositionsAvgAggregateOutputType = {
    price: Decimal | null
    securityId: number | null
    quantity: Decimal | null
    marketValue: Decimal | null
    positionPercent: Decimal | null
  }

  export type PositionsSumAggregateOutputType = {
    price: Decimal | null
    securityId: number | null
    quantity: Decimal | null
    marketValue: Decimal | null
    positionPercent: Decimal | null
  }

  export type PositionsMinAggregateOutputType = {
    id: string | null
    price: Decimal | null
    securityId: number | null
    strategyName: string | null
    name: string | null
    accountId: string | null
    quantity: Decimal | null
    marketValue: Decimal | null
    symbol: string | null
    exchange: string | null
    positionPercent: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    type: string | null
    sellLock: boolean | null
  }

  export type PositionsMaxAggregateOutputType = {
    id: string | null
    price: Decimal | null
    securityId: number | null
    strategyName: string | null
    name: string | null
    accountId: string | null
    quantity: Decimal | null
    marketValue: Decimal | null
    symbol: string | null
    exchange: string | null
    positionPercent: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    type: string | null
    sellLock: boolean | null
  }

  export type PositionsCountAggregateOutputType = {
    id: number
    price: number
    securityId: number
    strategyName: number
    name: number
    accountId: number
    quantity: number
    marketValue: number
    symbol: number
    exchange: number
    positionPercent: number
    createdAt: number
    updatedAt: number
    status: number
    type: number
    sellLock: number
    _all: number
  }


  export type PositionsAvgAggregateInputType = {
    price?: true
    securityId?: true
    quantity?: true
    marketValue?: true
    positionPercent?: true
  }

  export type PositionsSumAggregateInputType = {
    price?: true
    securityId?: true
    quantity?: true
    marketValue?: true
    positionPercent?: true
  }

  export type PositionsMinAggregateInputType = {
    id?: true
    price?: true
    securityId?: true
    strategyName?: true
    name?: true
    accountId?: true
    quantity?: true
    marketValue?: true
    symbol?: true
    exchange?: true
    positionPercent?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    type?: true
    sellLock?: true
  }

  export type PositionsMaxAggregateInputType = {
    id?: true
    price?: true
    securityId?: true
    strategyName?: true
    name?: true
    accountId?: true
    quantity?: true
    marketValue?: true
    symbol?: true
    exchange?: true
    positionPercent?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    type?: true
    sellLock?: true
  }

  export type PositionsCountAggregateInputType = {
    id?: true
    price?: true
    securityId?: true
    strategyName?: true
    name?: true
    accountId?: true
    quantity?: true
    marketValue?: true
    symbol?: true
    exchange?: true
    positionPercent?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    type?: true
    sellLock?: true
    _all?: true
  }

  export type PositionsAggregateArgs = {
    /**
     * Filter which Positions to aggregate.
     * 
    **/
    where?: PositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionsMaxAggregateInputType
  }

  export type GetPositionsAggregateType<T extends PositionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePositions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePositions[P]>
      : GetScalarType<T[P], AggregatePositions[P]>
  }




  export type PositionsGroupByArgs = {
    where?: PositionsWhereInput
    orderBy?: Enumerable<PositionsOrderByWithAggregationInput>
    by: Array<PositionsScalarFieldEnum>
    having?: PositionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionsCountAggregateInputType | true
    _avg?: PositionsAvgAggregateInputType
    _sum?: PositionsSumAggregateInputType
    _min?: PositionsMinAggregateInputType
    _max?: PositionsMaxAggregateInputType
  }


  export type PositionsGroupByOutputType = {
    id: string
    price: Decimal
    securityId: number
    strategyName: string | null
    name: string | null
    accountId: string | null
    quantity: Decimal
    marketValue: Decimal | null
    symbol: string
    exchange: string | null
    positionPercent: Decimal | null
    createdAt: Date
    updatedAt: Date | null
    status: string | null
    type: string
    sellLock: boolean
    _count: PositionsCountAggregateOutputType | null
    _avg: PositionsAvgAggregateOutputType | null
    _sum: PositionsSumAggregateOutputType | null
    _min: PositionsMinAggregateOutputType | null
    _max: PositionsMaxAggregateOutputType | null
  }

  type GetPositionsGroupByPayload<T extends PositionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PositionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionsGroupByOutputType[P]>
            : GetScalarType<T[P], PositionsGroupByOutputType[P]>
        }
      >
    >


  export type PositionsSelect = {
    id?: boolean
    price?: boolean
    securityId?: boolean
    strategyName?: boolean
    name?: boolean
    accountId?: boolean
    quantity?: boolean
    marketValue?: boolean
    symbol?: boolean
    exchange?: boolean
    positionPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    type?: boolean
    sellLock?: boolean
    Account?: boolean | AccountsArgs
    PositionOrders?: boolean | PositionOrdersFindManyArgs
    _count?: boolean | PositionsCountOutputTypeArgs
  }

  export type PositionsInclude = {
    Account?: boolean | AccountsArgs
    PositionOrders?: boolean | PositionOrdersFindManyArgs
    _count?: boolean | PositionsCountOutputTypeArgs
  }

  export type PositionsGetPayload<
    S extends boolean | null | undefined | PositionsArgs,
    U = keyof S
      > = S extends true
        ? Positions
    : S extends undefined
    ? never
    : S extends PositionsArgs | PositionsFindManyArgs
    ?'include' extends U
    ? Positions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Account' ? AccountsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'PositionOrders' ? Array < PositionOrdersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PositionsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Account' ? AccountsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'PositionOrders' ? Array < PositionOrdersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PositionsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Positions ? Positions[P] : never
  } 
    : Positions
  : Positions


  type PositionsCountArgs = Merge<
    Omit<PositionsFindManyArgs, 'select' | 'include'> & {
      select?: PositionsCountAggregateInputType | true
    }
  >

  export interface PositionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Positions that matches the filter.
     * @param {PositionsFindUniqueArgs} args - Arguments to find a Positions
     * @example
     * // Get one Positions
     * const positions = await prisma.positions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PositionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PositionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Positions'> extends True ? CheckSelect<T, Prisma__PositionsClient<Positions>, Prisma__PositionsClient<PositionsGetPayload<T>>> : CheckSelect<T, Prisma__PositionsClient<Positions | null, null>, Prisma__PositionsClient<PositionsGetPayload<T> | null, null>>

    /**
     * Find the first Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionsFindFirstArgs} args - Arguments to find a Positions
     * @example
     * // Get one Positions
     * const positions = await prisma.positions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PositionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PositionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Positions'> extends True ? CheckSelect<T, Prisma__PositionsClient<Positions>, Prisma__PositionsClient<PositionsGetPayload<T>>> : CheckSelect<T, Prisma__PositionsClient<Positions | null, null>, Prisma__PositionsClient<PositionsGetPayload<T> | null, null>>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.positions.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.positions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionsWithIdOnly = await prisma.positions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PositionsFindManyArgs>(
      args?: SelectSubset<T, PositionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Positions>>, PrismaPromise<Array<PositionsGetPayload<T>>>>

    /**
     * Create a Positions.
     * @param {PositionsCreateArgs} args - Arguments to create a Positions.
     * @example
     * // Create one Positions
     * const Positions = await prisma.positions.create({
     *   data: {
     *     // ... data to create a Positions
     *   }
     * })
     * 
    **/
    create<T extends PositionsCreateArgs>(
      args: SelectSubset<T, PositionsCreateArgs>
    ): CheckSelect<T, Prisma__PositionsClient<Positions>, Prisma__PositionsClient<PositionsGetPayload<T>>>

    /**
     * Create many Positions.
     *     @param {PositionsCreateManyArgs} args - Arguments to create many Positions.
     *     @example
     *     // Create many Positions
     *     const positions = await prisma.positions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PositionsCreateManyArgs>(
      args?: SelectSubset<T, PositionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Positions.
     * @param {PositionsDeleteArgs} args - Arguments to delete one Positions.
     * @example
     * // Delete one Positions
     * const Positions = await prisma.positions.delete({
     *   where: {
     *     // ... filter to delete one Positions
     *   }
     * })
     * 
    **/
    delete<T extends PositionsDeleteArgs>(
      args: SelectSubset<T, PositionsDeleteArgs>
    ): CheckSelect<T, Prisma__PositionsClient<Positions>, Prisma__PositionsClient<PositionsGetPayload<T>>>

    /**
     * Update one Positions.
     * @param {PositionsUpdateArgs} args - Arguments to update one Positions.
     * @example
     * // Update one Positions
     * const positions = await prisma.positions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PositionsUpdateArgs>(
      args: SelectSubset<T, PositionsUpdateArgs>
    ): CheckSelect<T, Prisma__PositionsClient<Positions>, Prisma__PositionsClient<PositionsGetPayload<T>>>

    /**
     * Delete zero or more Positions.
     * @param {PositionsDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.positions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PositionsDeleteManyArgs>(
      args?: SelectSubset<T, PositionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const positions = await prisma.positions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PositionsUpdateManyArgs>(
      args: SelectSubset<T, PositionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Positions.
     * @param {PositionsUpsertArgs} args - Arguments to update or create a Positions.
     * @example
     * // Update or create a Positions
     * const positions = await prisma.positions.upsert({
     *   create: {
     *     // ... data to create a Positions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Positions we want to update
     *   }
     * })
    **/
    upsert<T extends PositionsUpsertArgs>(
      args: SelectSubset<T, PositionsUpsertArgs>
    ): CheckSelect<T, Prisma__PositionsClient<Positions>, Prisma__PositionsClient<PositionsGetPayload<T>>>

    /**
     * Find one Positions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PositionsFindUniqueOrThrowArgs} args - Arguments to find a Positions
     * @example
     * // Get one Positions
     * const positions = await prisma.positions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PositionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PositionsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PositionsClient<Positions>, Prisma__PositionsClient<PositionsGetPayload<T>>>

    /**
     * Find the first Positions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionsFindFirstOrThrowArgs} args - Arguments to find a Positions
     * @example
     * // Get one Positions
     * const positions = await prisma.positions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PositionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PositionsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PositionsClient<Positions>, Prisma__PositionsClient<PositionsGetPayload<T>>>

    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionsCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.positions.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionsCountArgs>(
      args?: Subset<T, PositionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionsAggregateArgs>(args: Subset<T, PositionsAggregateArgs>): PrismaPromise<GetPositionsAggregateType<T>>

    /**
     * Group by Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionsGroupByArgs['orderBy'] }
        : { orderBy?: PositionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Positions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PositionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Account<T extends AccountsArgs = {}>(args?: Subset<T, AccountsArgs>): CheckSelect<T, Prisma__AccountsClient<Accounts | Null>, Prisma__AccountsClient<AccountsGetPayload<T> | Null>>;

    PositionOrders<T extends PositionOrdersFindManyArgs = {}>(args?: Subset<T, PositionOrdersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PositionOrders>| Null>, PrismaPromise<Array<PositionOrdersGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Positions base type for findUnique actions
   */
  export type PositionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Positions
     * 
    **/
    select?: PositionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionsInclude | null
    /**
     * Filter, which Positions to fetch.
     * 
    **/
    where: PositionsWhereUniqueInput
  }

  /**
   * Positions: findUnique
   */
  export interface PositionsFindUniqueArgs extends PositionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Positions base type for findFirst actions
   */
  export type PositionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Positions
     * 
    **/
    select?: PositionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionsInclude | null
    /**
     * Filter, which Positions to fetch.
     * 
    **/
    where?: PositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     * 
    **/
    cursor?: PositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     * 
    **/
    distinct?: Enumerable<PositionsScalarFieldEnum>
  }

  /**
   * Positions: findFirst
   */
  export interface PositionsFindFirstArgs extends PositionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Positions findMany
   */
  export type PositionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Positions
     * 
    **/
    select?: PositionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionsInclude | null
    /**
     * Filter, which Positions to fetch.
     * 
    **/
    where?: PositionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     * 
    **/
    cursor?: PositionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PositionsScalarFieldEnum>
  }


  /**
   * Positions create
   */
  export type PositionsCreateArgs = {
    /**
     * Select specific fields to fetch from the Positions
     * 
    **/
    select?: PositionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionsInclude | null
    /**
     * The data needed to create a Positions.
     * 
    **/
    data: XOR<PositionsCreateInput, PositionsUncheckedCreateInput>
  }


  /**
   * Positions createMany
   */
  export type PositionsCreateManyArgs = {
    /**
     * The data used to create many Positions.
     * 
    **/
    data: Enumerable<PositionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Positions update
   */
  export type PositionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Positions
     * 
    **/
    select?: PositionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionsInclude | null
    /**
     * The data needed to update a Positions.
     * 
    **/
    data: XOR<PositionsUpdateInput, PositionsUncheckedUpdateInput>
    /**
     * Choose, which Positions to update.
     * 
    **/
    where: PositionsWhereUniqueInput
  }


  /**
   * Positions updateMany
   */
  export type PositionsUpdateManyArgs = {
    /**
     * The data used to update Positions.
     * 
    **/
    data: XOR<PositionsUpdateManyMutationInput, PositionsUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     * 
    **/
    where?: PositionsWhereInput
  }


  /**
   * Positions upsert
   */
  export type PositionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Positions
     * 
    **/
    select?: PositionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionsInclude | null
    /**
     * The filter to search for the Positions to update in case it exists.
     * 
    **/
    where: PositionsWhereUniqueInput
    /**
     * In case the Positions found by the `where` argument doesn't exist, create a new Positions with this data.
     * 
    **/
    create: XOR<PositionsCreateInput, PositionsUncheckedCreateInput>
    /**
     * In case the Positions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PositionsUpdateInput, PositionsUncheckedUpdateInput>
  }


  /**
   * Positions delete
   */
  export type PositionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Positions
     * 
    **/
    select?: PositionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionsInclude | null
    /**
     * Filter which Positions to delete.
     * 
    **/
    where: PositionsWhereUniqueInput
  }


  /**
   * Positions deleteMany
   */
  export type PositionsDeleteManyArgs = {
    /**
     * Filter which Positions to delete
     * 
    **/
    where?: PositionsWhereInput
  }


  /**
   * Positions: findUniqueOrThrow
   */
  export type PositionsFindUniqueOrThrowArgs = PositionsFindUniqueArgsBase
      

  /**
   * Positions: findFirstOrThrow
   */
  export type PositionsFindFirstOrThrowArgs = PositionsFindFirstArgsBase
      

  /**
   * Positions without action
   */
  export type PositionsArgs = {
    /**
     * Select specific fields to fetch from the Positions
     * 
    **/
    select?: PositionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionsInclude | null
  }



  /**
   * Model PositionOrders
   */


  export type AggregatePositionOrders = {
    _count: PositionOrdersCountAggregateOutputType | null
    _min: PositionOrdersMinAggregateOutputType | null
    _max: PositionOrdersMaxAggregateOutputType | null
  }

  export type PositionOrdersMinAggregateOutputType = {
    positionId: string | null
    orderId: string | null
    intent: string | null
    createdAt: Date | null
  }

  export type PositionOrdersMaxAggregateOutputType = {
    positionId: string | null
    orderId: string | null
    intent: string | null
    createdAt: Date | null
  }

  export type PositionOrdersCountAggregateOutputType = {
    positionId: number
    orderId: number
    intent: number
    createdAt: number
    _all: number
  }


  export type PositionOrdersMinAggregateInputType = {
    positionId?: true
    orderId?: true
    intent?: true
    createdAt?: true
  }

  export type PositionOrdersMaxAggregateInputType = {
    positionId?: true
    orderId?: true
    intent?: true
    createdAt?: true
  }

  export type PositionOrdersCountAggregateInputType = {
    positionId?: true
    orderId?: true
    intent?: true
    createdAt?: true
    _all?: true
  }

  export type PositionOrdersAggregateArgs = {
    /**
     * Filter which PositionOrders to aggregate.
     * 
    **/
    where?: PositionOrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionOrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PositionOrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionOrders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PositionOrders
    **/
    _count?: true | PositionOrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionOrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionOrdersMaxAggregateInputType
  }

  export type GetPositionOrdersAggregateType<T extends PositionOrdersAggregateArgs> = {
        [P in keyof T & keyof AggregatePositionOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePositionOrders[P]>
      : GetScalarType<T[P], AggregatePositionOrders[P]>
  }




  export type PositionOrdersGroupByArgs = {
    where?: PositionOrdersWhereInput
    orderBy?: Enumerable<PositionOrdersOrderByWithAggregationInput>
    by: Array<PositionOrdersScalarFieldEnum>
    having?: PositionOrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionOrdersCountAggregateInputType | true
    _min?: PositionOrdersMinAggregateInputType
    _max?: PositionOrdersMaxAggregateInputType
  }


  export type PositionOrdersGroupByOutputType = {
    positionId: string
    orderId: string
    intent: string
    createdAt: Date
    _count: PositionOrdersCountAggregateOutputType | null
    _min: PositionOrdersMinAggregateOutputType | null
    _max: PositionOrdersMaxAggregateOutputType | null
  }

  type GetPositionOrdersGroupByPayload<T extends PositionOrdersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PositionOrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionOrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionOrdersGroupByOutputType[P]>
            : GetScalarType<T[P], PositionOrdersGroupByOutputType[P]>
        }
      >
    >


  export type PositionOrdersSelect = {
    positionId?: boolean
    orderId?: boolean
    intent?: boolean
    createdAt?: boolean
    Position?: boolean | PositionsArgs
    Order?: boolean | OrdersArgs
  }

  export type PositionOrdersInclude = {
    Position?: boolean | PositionsArgs
    Order?: boolean | OrdersArgs
  }

  export type PositionOrdersGetPayload<
    S extends boolean | null | undefined | PositionOrdersArgs,
    U = keyof S
      > = S extends true
        ? PositionOrders
    : S extends undefined
    ? never
    : S extends PositionOrdersArgs | PositionOrdersFindManyArgs
    ?'include' extends U
    ? PositionOrders  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Position' ? PositionsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'Order' ? OrdersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Position' ? PositionsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'Order' ? OrdersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof PositionOrders ? PositionOrders[P] : never
  } 
    : PositionOrders
  : PositionOrders


  type PositionOrdersCountArgs = Merge<
    Omit<PositionOrdersFindManyArgs, 'select' | 'include'> & {
      select?: PositionOrdersCountAggregateInputType | true
    }
  >

  export interface PositionOrdersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PositionOrders that matches the filter.
     * @param {PositionOrdersFindUniqueArgs} args - Arguments to find a PositionOrders
     * @example
     * // Get one PositionOrders
     * const positionOrders = await prisma.positionOrders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PositionOrdersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PositionOrdersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PositionOrders'> extends True ? CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T>>> : CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders | null, null>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T> | null, null>>

    /**
     * Find the first PositionOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOrdersFindFirstArgs} args - Arguments to find a PositionOrders
     * @example
     * // Get one PositionOrders
     * const positionOrders = await prisma.positionOrders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PositionOrdersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PositionOrdersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PositionOrders'> extends True ? CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T>>> : CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders | null, null>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T> | null, null>>

    /**
     * Find zero or more PositionOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOrdersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PositionOrders
     * const positionOrders = await prisma.positionOrders.findMany()
     * 
     * // Get first 10 PositionOrders
     * const positionOrders = await prisma.positionOrders.findMany({ take: 10 })
     * 
     * // Only select the `positionId`
     * const positionOrdersWithPositionIdOnly = await prisma.positionOrders.findMany({ select: { positionId: true } })
     * 
    **/
    findMany<T extends PositionOrdersFindManyArgs>(
      args?: SelectSubset<T, PositionOrdersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PositionOrders>>, PrismaPromise<Array<PositionOrdersGetPayload<T>>>>

    /**
     * Create a PositionOrders.
     * @param {PositionOrdersCreateArgs} args - Arguments to create a PositionOrders.
     * @example
     * // Create one PositionOrders
     * const PositionOrders = await prisma.positionOrders.create({
     *   data: {
     *     // ... data to create a PositionOrders
     *   }
     * })
     * 
    **/
    create<T extends PositionOrdersCreateArgs>(
      args: SelectSubset<T, PositionOrdersCreateArgs>
    ): CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T>>>

    /**
     * Create many PositionOrders.
     *     @param {PositionOrdersCreateManyArgs} args - Arguments to create many PositionOrders.
     *     @example
     *     // Create many PositionOrders
     *     const positionOrders = await prisma.positionOrders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PositionOrdersCreateManyArgs>(
      args?: SelectSubset<T, PositionOrdersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PositionOrders.
     * @param {PositionOrdersDeleteArgs} args - Arguments to delete one PositionOrders.
     * @example
     * // Delete one PositionOrders
     * const PositionOrders = await prisma.positionOrders.delete({
     *   where: {
     *     // ... filter to delete one PositionOrders
     *   }
     * })
     * 
    **/
    delete<T extends PositionOrdersDeleteArgs>(
      args: SelectSubset<T, PositionOrdersDeleteArgs>
    ): CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T>>>

    /**
     * Update one PositionOrders.
     * @param {PositionOrdersUpdateArgs} args - Arguments to update one PositionOrders.
     * @example
     * // Update one PositionOrders
     * const positionOrders = await prisma.positionOrders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PositionOrdersUpdateArgs>(
      args: SelectSubset<T, PositionOrdersUpdateArgs>
    ): CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T>>>

    /**
     * Delete zero or more PositionOrders.
     * @param {PositionOrdersDeleteManyArgs} args - Arguments to filter PositionOrders to delete.
     * @example
     * // Delete a few PositionOrders
     * const { count } = await prisma.positionOrders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PositionOrdersDeleteManyArgs>(
      args?: SelectSubset<T, PositionOrdersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PositionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PositionOrders
     * const positionOrders = await prisma.positionOrders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PositionOrdersUpdateManyArgs>(
      args: SelectSubset<T, PositionOrdersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PositionOrders.
     * @param {PositionOrdersUpsertArgs} args - Arguments to update or create a PositionOrders.
     * @example
     * // Update or create a PositionOrders
     * const positionOrders = await prisma.positionOrders.upsert({
     *   create: {
     *     // ... data to create a PositionOrders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PositionOrders we want to update
     *   }
     * })
    **/
    upsert<T extends PositionOrdersUpsertArgs>(
      args: SelectSubset<T, PositionOrdersUpsertArgs>
    ): CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T>>>

    /**
     * Find one PositionOrders that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PositionOrdersFindUniqueOrThrowArgs} args - Arguments to find a PositionOrders
     * @example
     * // Get one PositionOrders
     * const positionOrders = await prisma.positionOrders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PositionOrdersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PositionOrdersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T>>>

    /**
     * Find the first PositionOrders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOrdersFindFirstOrThrowArgs} args - Arguments to find a PositionOrders
     * @example
     * // Get one PositionOrders
     * const positionOrders = await prisma.positionOrders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PositionOrdersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PositionOrdersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PositionOrdersClient<PositionOrders>, Prisma__PositionOrdersClient<PositionOrdersGetPayload<T>>>

    /**
     * Count the number of PositionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOrdersCountArgs} args - Arguments to filter PositionOrders to count.
     * @example
     * // Count the number of PositionOrders
     * const count = await prisma.positionOrders.count({
     *   where: {
     *     // ... the filter for the PositionOrders we want to count
     *   }
     * })
    **/
    count<T extends PositionOrdersCountArgs>(
      args?: Subset<T, PositionOrdersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionOrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PositionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionOrdersAggregateArgs>(args: Subset<T, PositionOrdersAggregateArgs>): PrismaPromise<GetPositionOrdersAggregateType<T>>

    /**
     * Group by PositionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionOrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionOrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionOrdersGroupByArgs['orderBy'] }
        : { orderBy?: PositionOrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionOrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionOrdersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PositionOrders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PositionOrdersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Position<T extends PositionsArgs = {}>(args?: Subset<T, PositionsArgs>): CheckSelect<T, Prisma__PositionsClient<Positions | Null>, Prisma__PositionsClient<PositionsGetPayload<T> | Null>>;

    Order<T extends OrdersArgs = {}>(args?: Subset<T, OrdersArgs>): CheckSelect<T, Prisma__OrdersClient<Orders | Null>, Prisma__OrdersClient<OrdersGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PositionOrders base type for findUnique actions
   */
  export type PositionOrdersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PositionOrders
     * 
    **/
    select?: PositionOrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionOrdersInclude | null
    /**
     * Filter, which PositionOrders to fetch.
     * 
    **/
    where: PositionOrdersWhereUniqueInput
  }

  /**
   * PositionOrders: findUnique
   */
  export interface PositionOrdersFindUniqueArgs extends PositionOrdersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PositionOrders base type for findFirst actions
   */
  export type PositionOrdersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PositionOrders
     * 
    **/
    select?: PositionOrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionOrdersInclude | null
    /**
     * Filter, which PositionOrders to fetch.
     * 
    **/
    where?: PositionOrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionOrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PositionOrders.
     * 
    **/
    cursor?: PositionOrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionOrders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PositionOrders.
     * 
    **/
    distinct?: Enumerable<PositionOrdersScalarFieldEnum>
  }

  /**
   * PositionOrders: findFirst
   */
  export interface PositionOrdersFindFirstArgs extends PositionOrdersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PositionOrders findMany
   */
  export type PositionOrdersFindManyArgs = {
    /**
     * Select specific fields to fetch from the PositionOrders
     * 
    **/
    select?: PositionOrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionOrdersInclude | null
    /**
     * Filter, which PositionOrders to fetch.
     * 
    **/
    where?: PositionOrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<PositionOrdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PositionOrders.
     * 
    **/
    cursor?: PositionOrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionOrders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PositionOrdersScalarFieldEnum>
  }


  /**
   * PositionOrders create
   */
  export type PositionOrdersCreateArgs = {
    /**
     * Select specific fields to fetch from the PositionOrders
     * 
    **/
    select?: PositionOrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionOrdersInclude | null
    /**
     * The data needed to create a PositionOrders.
     * 
    **/
    data: XOR<PositionOrdersCreateInput, PositionOrdersUncheckedCreateInput>
  }


  /**
   * PositionOrders createMany
   */
  export type PositionOrdersCreateManyArgs = {
    /**
     * The data used to create many PositionOrders.
     * 
    **/
    data: Enumerable<PositionOrdersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PositionOrders update
   */
  export type PositionOrdersUpdateArgs = {
    /**
     * Select specific fields to fetch from the PositionOrders
     * 
    **/
    select?: PositionOrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionOrdersInclude | null
    /**
     * The data needed to update a PositionOrders.
     * 
    **/
    data: XOR<PositionOrdersUpdateInput, PositionOrdersUncheckedUpdateInput>
    /**
     * Choose, which PositionOrders to update.
     * 
    **/
    where: PositionOrdersWhereUniqueInput
  }


  /**
   * PositionOrders updateMany
   */
  export type PositionOrdersUpdateManyArgs = {
    /**
     * The data used to update PositionOrders.
     * 
    **/
    data: XOR<PositionOrdersUpdateManyMutationInput, PositionOrdersUncheckedUpdateManyInput>
    /**
     * Filter which PositionOrders to update
     * 
    **/
    where?: PositionOrdersWhereInput
  }


  /**
   * PositionOrders upsert
   */
  export type PositionOrdersUpsertArgs = {
    /**
     * Select specific fields to fetch from the PositionOrders
     * 
    **/
    select?: PositionOrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionOrdersInclude | null
    /**
     * The filter to search for the PositionOrders to update in case it exists.
     * 
    **/
    where: PositionOrdersWhereUniqueInput
    /**
     * In case the PositionOrders found by the `where` argument doesn't exist, create a new PositionOrders with this data.
     * 
    **/
    create: XOR<PositionOrdersCreateInput, PositionOrdersUncheckedCreateInput>
    /**
     * In case the PositionOrders was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PositionOrdersUpdateInput, PositionOrdersUncheckedUpdateInput>
  }


  /**
   * PositionOrders delete
   */
  export type PositionOrdersDeleteArgs = {
    /**
     * Select specific fields to fetch from the PositionOrders
     * 
    **/
    select?: PositionOrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionOrdersInclude | null
    /**
     * Filter which PositionOrders to delete.
     * 
    **/
    where: PositionOrdersWhereUniqueInput
  }


  /**
   * PositionOrders deleteMany
   */
  export type PositionOrdersDeleteManyArgs = {
    /**
     * Filter which PositionOrders to delete
     * 
    **/
    where?: PositionOrdersWhereInput
  }


  /**
   * PositionOrders: findUniqueOrThrow
   */
  export type PositionOrdersFindUniqueOrThrowArgs = PositionOrdersFindUniqueArgsBase
      

  /**
   * PositionOrders: findFirstOrThrow
   */
  export type PositionOrdersFindFirstOrThrowArgs = PositionOrdersFindFirstArgsBase
      

  /**
   * PositionOrders without action
   */
  export type PositionOrdersArgs = {
    /**
     * Select specific fields to fetch from the PositionOrders
     * 
    **/
    select?: PositionOrdersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PositionOrdersInclude | null
  }



  /**
   * Model Preferences
   */


  export type AggregatePreferences = {
    _count: PreferencesCountAggregateOutputType | null
    _avg: PreferencesAvgAggregateOutputType | null
    _sum: PreferencesSumAggregateOutputType | null
    _min: PreferencesMinAggregateOutputType | null
    _max: PreferencesMaxAggregateOutputType | null
  }

  export type PreferencesAvgAggregateOutputType = {
    id: number | null
    singleTradeRiskLevel: Decimal | null
    allTradeRiskLevel: Decimal | null
    singleTradeVolatilityLevel: Decimal | null
    allTradeVolatilityLevel: Decimal | null
    lowestStockPrice: Decimal | null
  }

  export type PreferencesSumAggregateOutputType = {
    id: number | null
    singleTradeRiskLevel: Decimal | null
    allTradeRiskLevel: Decimal | null
    singleTradeVolatilityLevel: Decimal | null
    allTradeVolatilityLevel: Decimal | null
    lowestStockPrice: Decimal | null
  }

  export type PreferencesMinAggregateOutputType = {
    id: number | null
    singleTradeRiskLevel: Decimal | null
    allTradeRiskLevel: Decimal | null
    singleTradeVolatilityLevel: Decimal | null
    allTradeVolatilityLevel: Decimal | null
    lowestStockPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreferencesMaxAggregateOutputType = {
    id: number | null
    singleTradeRiskLevel: Decimal | null
    allTradeRiskLevel: Decimal | null
    singleTradeVolatilityLevel: Decimal | null
    allTradeVolatilityLevel: Decimal | null
    lowestStockPrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PreferencesCountAggregateOutputType = {
    id: number
    singleTradeRiskLevel: number
    allTradeRiskLevel: number
    singleTradeVolatilityLevel: number
    allTradeVolatilityLevel: number
    lowestStockPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PreferencesAvgAggregateInputType = {
    id?: true
    singleTradeRiskLevel?: true
    allTradeRiskLevel?: true
    singleTradeVolatilityLevel?: true
    allTradeVolatilityLevel?: true
    lowestStockPrice?: true
  }

  export type PreferencesSumAggregateInputType = {
    id?: true
    singleTradeRiskLevel?: true
    allTradeRiskLevel?: true
    singleTradeVolatilityLevel?: true
    allTradeVolatilityLevel?: true
    lowestStockPrice?: true
  }

  export type PreferencesMinAggregateInputType = {
    id?: true
    singleTradeRiskLevel?: true
    allTradeRiskLevel?: true
    singleTradeVolatilityLevel?: true
    allTradeVolatilityLevel?: true
    lowestStockPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreferencesMaxAggregateInputType = {
    id?: true
    singleTradeRiskLevel?: true
    allTradeRiskLevel?: true
    singleTradeVolatilityLevel?: true
    allTradeVolatilityLevel?: true
    lowestStockPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PreferencesCountAggregateInputType = {
    id?: true
    singleTradeRiskLevel?: true
    allTradeRiskLevel?: true
    singleTradeVolatilityLevel?: true
    allTradeVolatilityLevel?: true
    lowestStockPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PreferencesAggregateArgs = {
    /**
     * Filter which Preferences to aggregate.
     * 
    **/
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     * 
    **/
    orderBy?: Enumerable<PreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Preferences
    **/
    _count?: true | PreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferencesMaxAggregateInputType
  }

  export type GetPreferencesAggregateType<T extends PreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferences[P]>
      : GetScalarType<T[P], AggregatePreferences[P]>
  }




  export type PreferencesGroupByArgs = {
    where?: PreferencesWhereInput
    orderBy?: Enumerable<PreferencesOrderByWithAggregationInput>
    by: Array<PreferencesScalarFieldEnum>
    having?: PreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferencesCountAggregateInputType | true
    _avg?: PreferencesAvgAggregateInputType
    _sum?: PreferencesSumAggregateInputType
    _min?: PreferencesMinAggregateInputType
    _max?: PreferencesMaxAggregateInputType
  }


  export type PreferencesGroupByOutputType = {
    id: number
    singleTradeRiskLevel: Decimal | null
    allTradeRiskLevel: Decimal | null
    singleTradeVolatilityLevel: Decimal | null
    allTradeVolatilityLevel: Decimal | null
    lowestStockPrice: Decimal | null
    createdAt: Date
    updatedAt: Date | null
    _count: PreferencesCountAggregateOutputType | null
    _avg: PreferencesAvgAggregateOutputType | null
    _sum: PreferencesSumAggregateOutputType | null
    _min: PreferencesMinAggregateOutputType | null
    _max: PreferencesMaxAggregateOutputType | null
  }

  type GetPreferencesGroupByPayload<T extends PreferencesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], PreferencesGroupByOutputType[P]>
        }
      >
    >


  export type PreferencesSelect = {
    id?: boolean
    singleTradeRiskLevel?: boolean
    allTradeRiskLevel?: boolean
    singleTradeVolatilityLevel?: boolean
    allTradeVolatilityLevel?: boolean
    lowestStockPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PreferencesGetPayload<
    S extends boolean | null | undefined | PreferencesArgs,
    U = keyof S
      > = S extends true
        ? Preferences
    : S extends undefined
    ? never
    : S extends PreferencesArgs | PreferencesFindManyArgs
    ?'include' extends U
    ? Preferences 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Preferences ? Preferences[P] : never
  } 
    : Preferences
  : Preferences


  type PreferencesCountArgs = Merge<
    Omit<PreferencesFindManyArgs, 'select' | 'include'> & {
      select?: PreferencesCountAggregateInputType | true
    }
  >

  export interface PreferencesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Preferences that matches the filter.
     * @param {PreferencesFindUniqueArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PreferencesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PreferencesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Preferences'> extends True ? CheckSelect<T, Prisma__PreferencesClient<Preferences>, Prisma__PreferencesClient<PreferencesGetPayload<T>>> : CheckSelect<T, Prisma__PreferencesClient<Preferences | null, null>, Prisma__PreferencesClient<PreferencesGetPayload<T> | null, null>>

    /**
     * Find the first Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindFirstArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PreferencesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PreferencesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Preferences'> extends True ? CheckSelect<T, Prisma__PreferencesClient<Preferences>, Prisma__PreferencesClient<PreferencesGetPayload<T>>> : CheckSelect<T, Prisma__PreferencesClient<Preferences | null, null>, Prisma__PreferencesClient<PreferencesGetPayload<T> | null, null>>

    /**
     * Find zero or more Preferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preferences
     * const preferences = await prisma.preferences.findMany()
     * 
     * // Get first 10 Preferences
     * const preferences = await prisma.preferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preferencesWithIdOnly = await prisma.preferences.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PreferencesFindManyArgs>(
      args?: SelectSubset<T, PreferencesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Preferences>>, PrismaPromise<Array<PreferencesGetPayload<T>>>>

    /**
     * Create a Preferences.
     * @param {PreferencesCreateArgs} args - Arguments to create a Preferences.
     * @example
     * // Create one Preferences
     * const Preferences = await prisma.preferences.create({
     *   data: {
     *     // ... data to create a Preferences
     *   }
     * })
     * 
    **/
    create<T extends PreferencesCreateArgs>(
      args: SelectSubset<T, PreferencesCreateArgs>
    ): CheckSelect<T, Prisma__PreferencesClient<Preferences>, Prisma__PreferencesClient<PreferencesGetPayload<T>>>

    /**
     * Create many Preferences.
     *     @param {PreferencesCreateManyArgs} args - Arguments to create many Preferences.
     *     @example
     *     // Create many Preferences
     *     const preferences = await prisma.preferences.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PreferencesCreateManyArgs>(
      args?: SelectSubset<T, PreferencesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Preferences.
     * @param {PreferencesDeleteArgs} args - Arguments to delete one Preferences.
     * @example
     * // Delete one Preferences
     * const Preferences = await prisma.preferences.delete({
     *   where: {
     *     // ... filter to delete one Preferences
     *   }
     * })
     * 
    **/
    delete<T extends PreferencesDeleteArgs>(
      args: SelectSubset<T, PreferencesDeleteArgs>
    ): CheckSelect<T, Prisma__PreferencesClient<Preferences>, Prisma__PreferencesClient<PreferencesGetPayload<T>>>

    /**
     * Update one Preferences.
     * @param {PreferencesUpdateArgs} args - Arguments to update one Preferences.
     * @example
     * // Update one Preferences
     * const preferences = await prisma.preferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PreferencesUpdateArgs>(
      args: SelectSubset<T, PreferencesUpdateArgs>
    ): CheckSelect<T, Prisma__PreferencesClient<Preferences>, Prisma__PreferencesClient<PreferencesGetPayload<T>>>

    /**
     * Delete zero or more Preferences.
     * @param {PreferencesDeleteManyArgs} args - Arguments to filter Preferences to delete.
     * @example
     * // Delete a few Preferences
     * const { count } = await prisma.preferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PreferencesDeleteManyArgs>(
      args?: SelectSubset<T, PreferencesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preferences
     * const preferences = await prisma.preferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PreferencesUpdateManyArgs>(
      args: SelectSubset<T, PreferencesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Preferences.
     * @param {PreferencesUpsertArgs} args - Arguments to update or create a Preferences.
     * @example
     * // Update or create a Preferences
     * const preferences = await prisma.preferences.upsert({
     *   create: {
     *     // ... data to create a Preferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preferences we want to update
     *   }
     * })
    **/
    upsert<T extends PreferencesUpsertArgs>(
      args: SelectSubset<T, PreferencesUpsertArgs>
    ): CheckSelect<T, Prisma__PreferencesClient<Preferences>, Prisma__PreferencesClient<PreferencesGetPayload<T>>>

    /**
     * Find one Preferences that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PreferencesFindUniqueOrThrowArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PreferencesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PreferencesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PreferencesClient<Preferences>, Prisma__PreferencesClient<PreferencesGetPayload<T>>>

    /**
     * Find the first Preferences that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesFindFirstOrThrowArgs} args - Arguments to find a Preferences
     * @example
     * // Get one Preferences
     * const preferences = await prisma.preferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PreferencesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PreferencesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PreferencesClient<Preferences>, Prisma__PreferencesClient<PreferencesGetPayload<T>>>

    /**
     * Count the number of Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesCountArgs} args - Arguments to filter Preferences to count.
     * @example
     * // Count the number of Preferences
     * const count = await prisma.preferences.count({
     *   where: {
     *     // ... the filter for the Preferences we want to count
     *   }
     * })
    **/
    count<T extends PreferencesCountArgs>(
      args?: Subset<T, PreferencesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferencesAggregateArgs>(args: Subset<T, PreferencesAggregateArgs>): PrismaPromise<GetPreferencesAggregateType<T>>

    /**
     * Group by Preferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferencesGroupByArgs['orderBy'] }
        : { orderBy?: PreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferencesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Preferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PreferencesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Preferences base type for findUnique actions
   */
  export type PreferencesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Preferences
     * 
    **/
    select?: PreferencesSelect | null
    /**
     * Filter, which Preferences to fetch.
     * 
    **/
    where: PreferencesWhereUniqueInput
  }

  /**
   * Preferences: findUnique
   */
  export interface PreferencesFindUniqueArgs extends PreferencesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Preferences base type for findFirst actions
   */
  export type PreferencesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Preferences
     * 
    **/
    select?: PreferencesSelect | null
    /**
     * Filter, which Preferences to fetch.
     * 
    **/
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     * 
    **/
    orderBy?: Enumerable<PreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preferences.
     * 
    **/
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preferences.
     * 
    **/
    distinct?: Enumerable<PreferencesScalarFieldEnum>
  }

  /**
   * Preferences: findFirst
   */
  export interface PreferencesFindFirstArgs extends PreferencesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Preferences findMany
   */
  export type PreferencesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Preferences
     * 
    **/
    select?: PreferencesSelect | null
    /**
     * Filter, which Preferences to fetch.
     * 
    **/
    where?: PreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preferences to fetch.
     * 
    **/
    orderBy?: Enumerable<PreferencesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Preferences.
     * 
    **/
    cursor?: PreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preferences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PreferencesScalarFieldEnum>
  }


  /**
   * Preferences create
   */
  export type PreferencesCreateArgs = {
    /**
     * Select specific fields to fetch from the Preferences
     * 
    **/
    select?: PreferencesSelect | null
    /**
     * The data needed to create a Preferences.
     * 
    **/
    data: XOR<PreferencesCreateInput, PreferencesUncheckedCreateInput>
  }


  /**
   * Preferences createMany
   */
  export type PreferencesCreateManyArgs = {
    /**
     * The data used to create many Preferences.
     * 
    **/
    data: Enumerable<PreferencesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Preferences update
   */
  export type PreferencesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Preferences
     * 
    **/
    select?: PreferencesSelect | null
    /**
     * The data needed to update a Preferences.
     * 
    **/
    data: XOR<PreferencesUpdateInput, PreferencesUncheckedUpdateInput>
    /**
     * Choose, which Preferences to update.
     * 
    **/
    where: PreferencesWhereUniqueInput
  }


  /**
   * Preferences updateMany
   */
  export type PreferencesUpdateManyArgs = {
    /**
     * The data used to update Preferences.
     * 
    **/
    data: XOR<PreferencesUpdateManyMutationInput, PreferencesUncheckedUpdateManyInput>
    /**
     * Filter which Preferences to update
     * 
    **/
    where?: PreferencesWhereInput
  }


  /**
   * Preferences upsert
   */
  export type PreferencesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Preferences
     * 
    **/
    select?: PreferencesSelect | null
    /**
     * The filter to search for the Preferences to update in case it exists.
     * 
    **/
    where: PreferencesWhereUniqueInput
    /**
     * In case the Preferences found by the `where` argument doesn't exist, create a new Preferences with this data.
     * 
    **/
    create: XOR<PreferencesCreateInput, PreferencesUncheckedCreateInput>
    /**
     * In case the Preferences was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PreferencesUpdateInput, PreferencesUncheckedUpdateInput>
  }


  /**
   * Preferences delete
   */
  export type PreferencesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Preferences
     * 
    **/
    select?: PreferencesSelect | null
    /**
     * Filter which Preferences to delete.
     * 
    **/
    where: PreferencesWhereUniqueInput
  }


  /**
   * Preferences deleteMany
   */
  export type PreferencesDeleteManyArgs = {
    /**
     * Filter which Preferences to delete
     * 
    **/
    where?: PreferencesWhereInput
  }


  /**
   * Preferences: findUniqueOrThrow
   */
  export type PreferencesFindUniqueOrThrowArgs = PreferencesFindUniqueArgsBase
      

  /**
   * Preferences: findFirstOrThrow
   */
  export type PreferencesFindFirstOrThrowArgs = PreferencesFindFirstArgsBase
      

  /**
   * Preferences without action
   */
  export type PreferencesArgs = {
    /**
     * Select specific fields to fetch from the Preferences
     * 
    **/
    select?: PreferencesSelect | null
  }



  /**
   * Model SectorDaily
   */


  export type AggregateSectorDaily = {
    _count: SectorDailyCountAggregateOutputType | null
    _avg: SectorDailyAvgAggregateOutputType | null
    _sum: SectorDailySumAggregateOutputType | null
    _min: SectorDailyMinAggregateOutputType | null
    _max: SectorDailyMaxAggregateOutputType | null
  }

  export type SectorDailyAvgAggregateOutputType = {
    id: number | null
    sectorId: number | null
    realtimeReturn: Decimal | null
    oneDayReturn: Decimal | null
    fiveDayReturn: Decimal | null
    oneMonthReturn: Decimal | null
    threeMonthReturn: Decimal | null
    oneYearReturn: Decimal | null
    threeYearReturn: Decimal | null
    fiveYearReturn: Decimal | null
    tenYearReturn: Decimal | null
    ytdReturn: Decimal | null
  }

  export type SectorDailySumAggregateOutputType = {
    id: number | null
    sectorId: number | null
    realtimeReturn: Decimal | null
    oneDayReturn: Decimal | null
    fiveDayReturn: Decimal | null
    oneMonthReturn: Decimal | null
    threeMonthReturn: Decimal | null
    oneYearReturn: Decimal | null
    threeYearReturn: Decimal | null
    fiveYearReturn: Decimal | null
    tenYearReturn: Decimal | null
    ytdReturn: Decimal | null
  }

  export type SectorDailyMinAggregateOutputType = {
    id: number | null
    sectorId: number | null
    calendarDate: Date | null
    realtimeReturn: Decimal | null
    oneDayReturn: Decimal | null
    fiveDayReturn: Decimal | null
    oneMonthReturn: Decimal | null
    threeMonthReturn: Decimal | null
    oneYearReturn: Decimal | null
    threeYearReturn: Decimal | null
    fiveYearReturn: Decimal | null
    tenYearReturn: Decimal | null
    ytdReturn: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectorDailyMaxAggregateOutputType = {
    id: number | null
    sectorId: number | null
    calendarDate: Date | null
    realtimeReturn: Decimal | null
    oneDayReturn: Decimal | null
    fiveDayReturn: Decimal | null
    oneMonthReturn: Decimal | null
    threeMonthReturn: Decimal | null
    oneYearReturn: Decimal | null
    threeYearReturn: Decimal | null
    fiveYearReturn: Decimal | null
    tenYearReturn: Decimal | null
    ytdReturn: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectorDailyCountAggregateOutputType = {
    id: number
    sectorId: number
    calendarDate: number
    realtimeReturn: number
    oneDayReturn: number
    fiveDayReturn: number
    oneMonthReturn: number
    threeMonthReturn: number
    oneYearReturn: number
    threeYearReturn: number
    fiveYearReturn: number
    tenYearReturn: number
    ytdReturn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectorDailyAvgAggregateInputType = {
    id?: true
    sectorId?: true
    realtimeReturn?: true
    oneDayReturn?: true
    fiveDayReturn?: true
    oneMonthReturn?: true
    threeMonthReturn?: true
    oneYearReturn?: true
    threeYearReturn?: true
    fiveYearReturn?: true
    tenYearReturn?: true
    ytdReturn?: true
  }

  export type SectorDailySumAggregateInputType = {
    id?: true
    sectorId?: true
    realtimeReturn?: true
    oneDayReturn?: true
    fiveDayReturn?: true
    oneMonthReturn?: true
    threeMonthReturn?: true
    oneYearReturn?: true
    threeYearReturn?: true
    fiveYearReturn?: true
    tenYearReturn?: true
    ytdReturn?: true
  }

  export type SectorDailyMinAggregateInputType = {
    id?: true
    sectorId?: true
    calendarDate?: true
    realtimeReturn?: true
    oneDayReturn?: true
    fiveDayReturn?: true
    oneMonthReturn?: true
    threeMonthReturn?: true
    oneYearReturn?: true
    threeYearReturn?: true
    fiveYearReturn?: true
    tenYearReturn?: true
    ytdReturn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectorDailyMaxAggregateInputType = {
    id?: true
    sectorId?: true
    calendarDate?: true
    realtimeReturn?: true
    oneDayReturn?: true
    fiveDayReturn?: true
    oneMonthReturn?: true
    threeMonthReturn?: true
    oneYearReturn?: true
    threeYearReturn?: true
    fiveYearReturn?: true
    tenYearReturn?: true
    ytdReturn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectorDailyCountAggregateInputType = {
    id?: true
    sectorId?: true
    calendarDate?: true
    realtimeReturn?: true
    oneDayReturn?: true
    fiveDayReturn?: true
    oneMonthReturn?: true
    threeMonthReturn?: true
    oneYearReturn?: true
    threeYearReturn?: true
    fiveYearReturn?: true
    tenYearReturn?: true
    ytdReturn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectorDailyAggregateArgs = {
    /**
     * Filter which SectorDaily to aggregate.
     * 
    **/
    where?: SectorDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectorDailies to fetch.
     * 
    **/
    orderBy?: Enumerable<SectorDailyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SectorDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectorDailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectorDailies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SectorDailies
    **/
    _count?: true | SectorDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectorDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectorDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectorDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectorDailyMaxAggregateInputType
  }

  export type GetSectorDailyAggregateType<T extends SectorDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateSectorDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectorDaily[P]>
      : GetScalarType<T[P], AggregateSectorDaily[P]>
  }




  export type SectorDailyGroupByArgs = {
    where?: SectorDailyWhereInput
    orderBy?: Enumerable<SectorDailyOrderByWithAggregationInput>
    by: Array<SectorDailyScalarFieldEnum>
    having?: SectorDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectorDailyCountAggregateInputType | true
    _avg?: SectorDailyAvgAggregateInputType
    _sum?: SectorDailySumAggregateInputType
    _min?: SectorDailyMinAggregateInputType
    _max?: SectorDailyMaxAggregateInputType
  }


  export type SectorDailyGroupByOutputType = {
    id: number
    sectorId: number
    calendarDate: Date
    realtimeReturn: Decimal
    oneDayReturn: Decimal
    fiveDayReturn: Decimal
    oneMonthReturn: Decimal
    threeMonthReturn: Decimal
    oneYearReturn: Decimal
    threeYearReturn: Decimal
    fiveYearReturn: Decimal
    tenYearReturn: Decimal
    ytdReturn: Decimal
    createdAt: Date
    updatedAt: Date | null
    _count: SectorDailyCountAggregateOutputType | null
    _avg: SectorDailyAvgAggregateOutputType | null
    _sum: SectorDailySumAggregateOutputType | null
    _min: SectorDailyMinAggregateOutputType | null
    _max: SectorDailyMaxAggregateOutputType | null
  }

  type GetSectorDailyGroupByPayload<T extends SectorDailyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SectorDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectorDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectorDailyGroupByOutputType[P]>
            : GetScalarType<T[P], SectorDailyGroupByOutputType[P]>
        }
      >
    >


  export type SectorDailySelect = {
    id?: boolean
    sectorId?: boolean
    calendarDate?: boolean
    realtimeReturn?: boolean
    oneDayReturn?: boolean
    fiveDayReturn?: boolean
    oneMonthReturn?: boolean
    threeMonthReturn?: boolean
    oneYearReturn?: boolean
    threeYearReturn?: boolean
    fiveYearReturn?: boolean
    tenYearReturn?: boolean
    ytdReturn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Sector?: boolean | SectorsArgs
  }

  export type SectorDailyInclude = {
    Sector?: boolean | SectorsArgs
  }

  export type SectorDailyGetPayload<
    S extends boolean | null | undefined | SectorDailyArgs,
    U = keyof S
      > = S extends true
        ? SectorDaily
    : S extends undefined
    ? never
    : S extends SectorDailyArgs | SectorDailyFindManyArgs
    ?'include' extends U
    ? SectorDaily  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Sector' ? SectorsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Sector' ? SectorsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SectorDaily ? SectorDaily[P] : never
  } 
    : SectorDaily
  : SectorDaily


  type SectorDailyCountArgs = Merge<
    Omit<SectorDailyFindManyArgs, 'select' | 'include'> & {
      select?: SectorDailyCountAggregateInputType | true
    }
  >

  export interface SectorDailyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SectorDaily that matches the filter.
     * @param {SectorDailyFindUniqueArgs} args - Arguments to find a SectorDaily
     * @example
     * // Get one SectorDaily
     * const sectorDaily = await prisma.sectorDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SectorDailyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SectorDailyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SectorDaily'> extends True ? CheckSelect<T, Prisma__SectorDailyClient<SectorDaily>, Prisma__SectorDailyClient<SectorDailyGetPayload<T>>> : CheckSelect<T, Prisma__SectorDailyClient<SectorDaily | null, null>, Prisma__SectorDailyClient<SectorDailyGetPayload<T> | null, null>>

    /**
     * Find the first SectorDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorDailyFindFirstArgs} args - Arguments to find a SectorDaily
     * @example
     * // Get one SectorDaily
     * const sectorDaily = await prisma.sectorDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SectorDailyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SectorDailyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SectorDaily'> extends True ? CheckSelect<T, Prisma__SectorDailyClient<SectorDaily>, Prisma__SectorDailyClient<SectorDailyGetPayload<T>>> : CheckSelect<T, Prisma__SectorDailyClient<SectorDaily | null, null>, Prisma__SectorDailyClient<SectorDailyGetPayload<T> | null, null>>

    /**
     * Find zero or more SectorDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorDailyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SectorDailies
     * const sectorDailies = await prisma.sectorDaily.findMany()
     * 
     * // Get first 10 SectorDailies
     * const sectorDailies = await prisma.sectorDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectorDailyWithIdOnly = await prisma.sectorDaily.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SectorDailyFindManyArgs>(
      args?: SelectSubset<T, SectorDailyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SectorDaily>>, PrismaPromise<Array<SectorDailyGetPayload<T>>>>

    /**
     * Create a SectorDaily.
     * @param {SectorDailyCreateArgs} args - Arguments to create a SectorDaily.
     * @example
     * // Create one SectorDaily
     * const SectorDaily = await prisma.sectorDaily.create({
     *   data: {
     *     // ... data to create a SectorDaily
     *   }
     * })
     * 
    **/
    create<T extends SectorDailyCreateArgs>(
      args: SelectSubset<T, SectorDailyCreateArgs>
    ): CheckSelect<T, Prisma__SectorDailyClient<SectorDaily>, Prisma__SectorDailyClient<SectorDailyGetPayload<T>>>

    /**
     * Create many SectorDailies.
     *     @param {SectorDailyCreateManyArgs} args - Arguments to create many SectorDailies.
     *     @example
     *     // Create many SectorDailies
     *     const sectorDaily = await prisma.sectorDaily.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SectorDailyCreateManyArgs>(
      args?: SelectSubset<T, SectorDailyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SectorDaily.
     * @param {SectorDailyDeleteArgs} args - Arguments to delete one SectorDaily.
     * @example
     * // Delete one SectorDaily
     * const SectorDaily = await prisma.sectorDaily.delete({
     *   where: {
     *     // ... filter to delete one SectorDaily
     *   }
     * })
     * 
    **/
    delete<T extends SectorDailyDeleteArgs>(
      args: SelectSubset<T, SectorDailyDeleteArgs>
    ): CheckSelect<T, Prisma__SectorDailyClient<SectorDaily>, Prisma__SectorDailyClient<SectorDailyGetPayload<T>>>

    /**
     * Update one SectorDaily.
     * @param {SectorDailyUpdateArgs} args - Arguments to update one SectorDaily.
     * @example
     * // Update one SectorDaily
     * const sectorDaily = await prisma.sectorDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SectorDailyUpdateArgs>(
      args: SelectSubset<T, SectorDailyUpdateArgs>
    ): CheckSelect<T, Prisma__SectorDailyClient<SectorDaily>, Prisma__SectorDailyClient<SectorDailyGetPayload<T>>>

    /**
     * Delete zero or more SectorDailies.
     * @param {SectorDailyDeleteManyArgs} args - Arguments to filter SectorDailies to delete.
     * @example
     * // Delete a few SectorDailies
     * const { count } = await prisma.sectorDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SectorDailyDeleteManyArgs>(
      args?: SelectSubset<T, SectorDailyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectorDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SectorDailies
     * const sectorDaily = await prisma.sectorDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SectorDailyUpdateManyArgs>(
      args: SelectSubset<T, SectorDailyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SectorDaily.
     * @param {SectorDailyUpsertArgs} args - Arguments to update or create a SectorDaily.
     * @example
     * // Update or create a SectorDaily
     * const sectorDaily = await prisma.sectorDaily.upsert({
     *   create: {
     *     // ... data to create a SectorDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SectorDaily we want to update
     *   }
     * })
    **/
    upsert<T extends SectorDailyUpsertArgs>(
      args: SelectSubset<T, SectorDailyUpsertArgs>
    ): CheckSelect<T, Prisma__SectorDailyClient<SectorDaily>, Prisma__SectorDailyClient<SectorDailyGetPayload<T>>>

    /**
     * Find one SectorDaily that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SectorDailyFindUniqueOrThrowArgs} args - Arguments to find a SectorDaily
     * @example
     * // Get one SectorDaily
     * const sectorDaily = await prisma.sectorDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SectorDailyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SectorDailyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SectorDailyClient<SectorDaily>, Prisma__SectorDailyClient<SectorDailyGetPayload<T>>>

    /**
     * Find the first SectorDaily that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorDailyFindFirstOrThrowArgs} args - Arguments to find a SectorDaily
     * @example
     * // Get one SectorDaily
     * const sectorDaily = await prisma.sectorDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SectorDailyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SectorDailyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SectorDailyClient<SectorDaily>, Prisma__SectorDailyClient<SectorDailyGetPayload<T>>>

    /**
     * Count the number of SectorDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorDailyCountArgs} args - Arguments to filter SectorDailies to count.
     * @example
     * // Count the number of SectorDailies
     * const count = await prisma.sectorDaily.count({
     *   where: {
     *     // ... the filter for the SectorDailies we want to count
     *   }
     * })
    **/
    count<T extends SectorDailyCountArgs>(
      args?: Subset<T, SectorDailyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectorDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SectorDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectorDailyAggregateArgs>(args: Subset<T, SectorDailyAggregateArgs>): PrismaPromise<GetSectorDailyAggregateType<T>>

    /**
     * Group by SectorDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectorDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectorDailyGroupByArgs['orderBy'] }
        : { orderBy?: SectorDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectorDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectorDailyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SectorDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SectorDailyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Sector<T extends SectorsArgs = {}>(args?: Subset<T, SectorsArgs>): CheckSelect<T, Prisma__SectorsClient<Sectors | Null>, Prisma__SectorsClient<SectorsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SectorDaily base type for findUnique actions
   */
  export type SectorDailyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SectorDaily
     * 
    **/
    select?: SectorDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorDailyInclude | null
    /**
     * Filter, which SectorDaily to fetch.
     * 
    **/
    where: SectorDailyWhereUniqueInput
  }

  /**
   * SectorDaily: findUnique
   */
  export interface SectorDailyFindUniqueArgs extends SectorDailyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SectorDaily base type for findFirst actions
   */
  export type SectorDailyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SectorDaily
     * 
    **/
    select?: SectorDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorDailyInclude | null
    /**
     * Filter, which SectorDaily to fetch.
     * 
    **/
    where?: SectorDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectorDailies to fetch.
     * 
    **/
    orderBy?: Enumerable<SectorDailyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectorDailies.
     * 
    **/
    cursor?: SectorDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectorDailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectorDailies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectorDailies.
     * 
    **/
    distinct?: Enumerable<SectorDailyScalarFieldEnum>
  }

  /**
   * SectorDaily: findFirst
   */
  export interface SectorDailyFindFirstArgs extends SectorDailyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SectorDaily findMany
   */
  export type SectorDailyFindManyArgs = {
    /**
     * Select specific fields to fetch from the SectorDaily
     * 
    **/
    select?: SectorDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorDailyInclude | null
    /**
     * Filter, which SectorDailies to fetch.
     * 
    **/
    where?: SectorDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectorDailies to fetch.
     * 
    **/
    orderBy?: Enumerable<SectorDailyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SectorDailies.
     * 
    **/
    cursor?: SectorDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectorDailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectorDailies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SectorDailyScalarFieldEnum>
  }


  /**
   * SectorDaily create
   */
  export type SectorDailyCreateArgs = {
    /**
     * Select specific fields to fetch from the SectorDaily
     * 
    **/
    select?: SectorDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorDailyInclude | null
    /**
     * The data needed to create a SectorDaily.
     * 
    **/
    data: XOR<SectorDailyCreateInput, SectorDailyUncheckedCreateInput>
  }


  /**
   * SectorDaily createMany
   */
  export type SectorDailyCreateManyArgs = {
    /**
     * The data used to create many SectorDailies.
     * 
    **/
    data: Enumerable<SectorDailyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SectorDaily update
   */
  export type SectorDailyUpdateArgs = {
    /**
     * Select specific fields to fetch from the SectorDaily
     * 
    **/
    select?: SectorDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorDailyInclude | null
    /**
     * The data needed to update a SectorDaily.
     * 
    **/
    data: XOR<SectorDailyUpdateInput, SectorDailyUncheckedUpdateInput>
    /**
     * Choose, which SectorDaily to update.
     * 
    **/
    where: SectorDailyWhereUniqueInput
  }


  /**
   * SectorDaily updateMany
   */
  export type SectorDailyUpdateManyArgs = {
    /**
     * The data used to update SectorDailies.
     * 
    **/
    data: XOR<SectorDailyUpdateManyMutationInput, SectorDailyUncheckedUpdateManyInput>
    /**
     * Filter which SectorDailies to update
     * 
    **/
    where?: SectorDailyWhereInput
  }


  /**
   * SectorDaily upsert
   */
  export type SectorDailyUpsertArgs = {
    /**
     * Select specific fields to fetch from the SectorDaily
     * 
    **/
    select?: SectorDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorDailyInclude | null
    /**
     * The filter to search for the SectorDaily to update in case it exists.
     * 
    **/
    where: SectorDailyWhereUniqueInput
    /**
     * In case the SectorDaily found by the `where` argument doesn't exist, create a new SectorDaily with this data.
     * 
    **/
    create: XOR<SectorDailyCreateInput, SectorDailyUncheckedCreateInput>
    /**
     * In case the SectorDaily was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SectorDailyUpdateInput, SectorDailyUncheckedUpdateInput>
  }


  /**
   * SectorDaily delete
   */
  export type SectorDailyDeleteArgs = {
    /**
     * Select specific fields to fetch from the SectorDaily
     * 
    **/
    select?: SectorDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorDailyInclude | null
    /**
     * Filter which SectorDaily to delete.
     * 
    **/
    where: SectorDailyWhereUniqueInput
  }


  /**
   * SectorDaily deleteMany
   */
  export type SectorDailyDeleteManyArgs = {
    /**
     * Filter which SectorDailies to delete
     * 
    **/
    where?: SectorDailyWhereInput
  }


  /**
   * SectorDaily: findUniqueOrThrow
   */
  export type SectorDailyFindUniqueOrThrowArgs = SectorDailyFindUniqueArgsBase
      

  /**
   * SectorDaily: findFirstOrThrow
   */
  export type SectorDailyFindFirstOrThrowArgs = SectorDailyFindFirstArgsBase
      

  /**
   * SectorDaily without action
   */
  export type SectorDailyArgs = {
    /**
     * Select specific fields to fetch from the SectorDaily
     * 
    **/
    select?: SectorDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorDailyInclude | null
  }



  /**
   * Model Sectors
   */


  export type AggregateSectors = {
    _count: SectorsCountAggregateOutputType | null
    _avg: SectorsAvgAggregateOutputType | null
    _sum: SectorsSumAggregateOutputType | null
    _min: SectorsMinAggregateOutputType | null
    _max: SectorsMaxAggregateOutputType | null
  }

  export type SectorsAvgAggregateOutputType = {
    id: number | null
  }

  export type SectorsSumAggregateOutputType = {
    id: number | null
  }

  export type SectorsMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectorsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectorsAvgAggregateInputType = {
    id?: true
  }

  export type SectorsSumAggregateInputType = {
    id?: true
  }

  export type SectorsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectorsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectorsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectorsAggregateArgs = {
    /**
     * Filter which Sectors to aggregate.
     * 
    **/
    where?: SectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     * 
    **/
    orderBy?: Enumerable<SectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sectors
    **/
    _count?: true | SectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectorsMaxAggregateInputType
  }

  export type GetSectorsAggregateType<T extends SectorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSectors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectors[P]>
      : GetScalarType<T[P], AggregateSectors[P]>
  }




  export type SectorsGroupByArgs = {
    where?: SectorsWhereInput
    orderBy?: Enumerable<SectorsOrderByWithAggregationInput>
    by: Array<SectorsScalarFieldEnum>
    having?: SectorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectorsCountAggregateInputType | true
    _avg?: SectorsAvgAggregateInputType
    _sum?: SectorsSumAggregateInputType
    _min?: SectorsMinAggregateInputType
    _max?: SectorsMaxAggregateInputType
  }


  export type SectorsGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date | null
    _count: SectorsCountAggregateOutputType | null
    _avg: SectorsAvgAggregateOutputType | null
    _sum: SectorsSumAggregateOutputType | null
    _min: SectorsMinAggregateOutputType | null
    _max: SectorsMaxAggregateOutputType | null
  }

  type GetSectorsGroupByPayload<T extends SectorsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SectorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectorsGroupByOutputType[P]>
            : GetScalarType<T[P], SectorsGroupByOutputType[P]>
        }
      >
    >


  export type SectorsSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SectorDaily?: boolean | SectorDailyFindManyArgs
    _count?: boolean | SectorsCountOutputTypeArgs
  }

  export type SectorsInclude = {
    SectorDaily?: boolean | SectorDailyFindManyArgs
    _count?: boolean | SectorsCountOutputTypeArgs
  }

  export type SectorsGetPayload<
    S extends boolean | null | undefined | SectorsArgs,
    U = keyof S
      > = S extends true
        ? Sectors
    : S extends undefined
    ? never
    : S extends SectorsArgs | SectorsFindManyArgs
    ?'include' extends U
    ? Sectors  & {
    [P in TrueKeys<S['include']>]:
        P extends 'SectorDaily' ? Array < SectorDailyGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SectorsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'SectorDaily' ? Array < SectorDailyGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SectorsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Sectors ? Sectors[P] : never
  } 
    : Sectors
  : Sectors


  type SectorsCountArgs = Merge<
    Omit<SectorsFindManyArgs, 'select' | 'include'> & {
      select?: SectorsCountAggregateInputType | true
    }
  >

  export interface SectorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Sectors that matches the filter.
     * @param {SectorsFindUniqueArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SectorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SectorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sectors'> extends True ? CheckSelect<T, Prisma__SectorsClient<Sectors>, Prisma__SectorsClient<SectorsGetPayload<T>>> : CheckSelect<T, Prisma__SectorsClient<Sectors | null, null>, Prisma__SectorsClient<SectorsGetPayload<T> | null, null>>

    /**
     * Find the first Sectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorsFindFirstArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SectorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SectorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sectors'> extends True ? CheckSelect<T, Prisma__SectorsClient<Sectors>, Prisma__SectorsClient<SectorsGetPayload<T>>> : CheckSelect<T, Prisma__SectorsClient<Sectors | null, null>, Prisma__SectorsClient<SectorsGetPayload<T> | null, null>>

    /**
     * Find zero or more Sectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sectors
     * const sectors = await prisma.sectors.findMany()
     * 
     * // Get first 10 Sectors
     * const sectors = await prisma.sectors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectorsWithIdOnly = await prisma.sectors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SectorsFindManyArgs>(
      args?: SelectSubset<T, SectorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Sectors>>, PrismaPromise<Array<SectorsGetPayload<T>>>>

    /**
     * Create a Sectors.
     * @param {SectorsCreateArgs} args - Arguments to create a Sectors.
     * @example
     * // Create one Sectors
     * const Sectors = await prisma.sectors.create({
     *   data: {
     *     // ... data to create a Sectors
     *   }
     * })
     * 
    **/
    create<T extends SectorsCreateArgs>(
      args: SelectSubset<T, SectorsCreateArgs>
    ): CheckSelect<T, Prisma__SectorsClient<Sectors>, Prisma__SectorsClient<SectorsGetPayload<T>>>

    /**
     * Create many Sectors.
     *     @param {SectorsCreateManyArgs} args - Arguments to create many Sectors.
     *     @example
     *     // Create many Sectors
     *     const sectors = await prisma.sectors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SectorsCreateManyArgs>(
      args?: SelectSubset<T, SectorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sectors.
     * @param {SectorsDeleteArgs} args - Arguments to delete one Sectors.
     * @example
     * // Delete one Sectors
     * const Sectors = await prisma.sectors.delete({
     *   where: {
     *     // ... filter to delete one Sectors
     *   }
     * })
     * 
    **/
    delete<T extends SectorsDeleteArgs>(
      args: SelectSubset<T, SectorsDeleteArgs>
    ): CheckSelect<T, Prisma__SectorsClient<Sectors>, Prisma__SectorsClient<SectorsGetPayload<T>>>

    /**
     * Update one Sectors.
     * @param {SectorsUpdateArgs} args - Arguments to update one Sectors.
     * @example
     * // Update one Sectors
     * const sectors = await prisma.sectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SectorsUpdateArgs>(
      args: SelectSubset<T, SectorsUpdateArgs>
    ): CheckSelect<T, Prisma__SectorsClient<Sectors>, Prisma__SectorsClient<SectorsGetPayload<T>>>

    /**
     * Delete zero or more Sectors.
     * @param {SectorsDeleteManyArgs} args - Arguments to filter Sectors to delete.
     * @example
     * // Delete a few Sectors
     * const { count } = await prisma.sectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SectorsDeleteManyArgs>(
      args?: SelectSubset<T, SectorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sectors
     * const sectors = await prisma.sectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SectorsUpdateManyArgs>(
      args: SelectSubset<T, SectorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sectors.
     * @param {SectorsUpsertArgs} args - Arguments to update or create a Sectors.
     * @example
     * // Update or create a Sectors
     * const sectors = await prisma.sectors.upsert({
     *   create: {
     *     // ... data to create a Sectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sectors we want to update
     *   }
     * })
    **/
    upsert<T extends SectorsUpsertArgs>(
      args: SelectSubset<T, SectorsUpsertArgs>
    ): CheckSelect<T, Prisma__SectorsClient<Sectors>, Prisma__SectorsClient<SectorsGetPayload<T>>>

    /**
     * Find one Sectors that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SectorsFindUniqueOrThrowArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SectorsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SectorsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SectorsClient<Sectors>, Prisma__SectorsClient<SectorsGetPayload<T>>>

    /**
     * Find the first Sectors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorsFindFirstOrThrowArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SectorsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SectorsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SectorsClient<Sectors>, Prisma__SectorsClient<SectorsGetPayload<T>>>

    /**
     * Count the number of Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorsCountArgs} args - Arguments to filter Sectors to count.
     * @example
     * // Count the number of Sectors
     * const count = await prisma.sectors.count({
     *   where: {
     *     // ... the filter for the Sectors we want to count
     *   }
     * })
    **/
    count<T extends SectorsCountArgs>(
      args?: Subset<T, SectorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectorsAggregateArgs>(args: Subset<T, SectorsAggregateArgs>): PrismaPromise<GetSectorsAggregateType<T>>

    /**
     * Group by Sectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectorsGroupByArgs['orderBy'] }
        : { orderBy?: SectorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectorsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Sectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SectorsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    SectorDaily<T extends SectorDailyFindManyArgs = {}>(args?: Subset<T, SectorDailyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SectorDaily>| Null>, PrismaPromise<Array<SectorDailyGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Sectors base type for findUnique actions
   */
  export type SectorsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Sectors
     * 
    **/
    select?: SectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorsInclude | null
    /**
     * Filter, which Sectors to fetch.
     * 
    **/
    where: SectorsWhereUniqueInput
  }

  /**
   * Sectors: findUnique
   */
  export interface SectorsFindUniqueArgs extends SectorsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sectors base type for findFirst actions
   */
  export type SectorsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Sectors
     * 
    **/
    select?: SectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorsInclude | null
    /**
     * Filter, which Sectors to fetch.
     * 
    **/
    where?: SectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     * 
    **/
    orderBy?: Enumerable<SectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sectors.
     * 
    **/
    cursor?: SectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sectors.
     * 
    **/
    distinct?: Enumerable<SectorsScalarFieldEnum>
  }

  /**
   * Sectors: findFirst
   */
  export interface SectorsFindFirstArgs extends SectorsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Sectors findMany
   */
  export type SectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Sectors
     * 
    **/
    select?: SectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorsInclude | null
    /**
     * Filter, which Sectors to fetch.
     * 
    **/
    where?: SectorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sectors to fetch.
     * 
    **/
    orderBy?: Enumerable<SectorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sectors.
     * 
    **/
    cursor?: SectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sectors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sectors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SectorsScalarFieldEnum>
  }


  /**
   * Sectors create
   */
  export type SectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the Sectors
     * 
    **/
    select?: SectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorsInclude | null
    /**
     * The data needed to create a Sectors.
     * 
    **/
    data: XOR<SectorsCreateInput, SectorsUncheckedCreateInput>
  }


  /**
   * Sectors createMany
   */
  export type SectorsCreateManyArgs = {
    /**
     * The data used to create many Sectors.
     * 
    **/
    data: Enumerable<SectorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Sectors update
   */
  export type SectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Sectors
     * 
    **/
    select?: SectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorsInclude | null
    /**
     * The data needed to update a Sectors.
     * 
    **/
    data: XOR<SectorsUpdateInput, SectorsUncheckedUpdateInput>
    /**
     * Choose, which Sectors to update.
     * 
    **/
    where: SectorsWhereUniqueInput
  }


  /**
   * Sectors updateMany
   */
  export type SectorsUpdateManyArgs = {
    /**
     * The data used to update Sectors.
     * 
    **/
    data: XOR<SectorsUpdateManyMutationInput, SectorsUncheckedUpdateManyInput>
    /**
     * Filter which Sectors to update
     * 
    **/
    where?: SectorsWhereInput
  }


  /**
   * Sectors upsert
   */
  export type SectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Sectors
     * 
    **/
    select?: SectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorsInclude | null
    /**
     * The filter to search for the Sectors to update in case it exists.
     * 
    **/
    where: SectorsWhereUniqueInput
    /**
     * In case the Sectors found by the `where` argument doesn't exist, create a new Sectors with this data.
     * 
    **/
    create: XOR<SectorsCreateInput, SectorsUncheckedCreateInput>
    /**
     * In case the Sectors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SectorsUpdateInput, SectorsUncheckedUpdateInput>
  }


  /**
   * Sectors delete
   */
  export type SectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Sectors
     * 
    **/
    select?: SectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorsInclude | null
    /**
     * Filter which Sectors to delete.
     * 
    **/
    where: SectorsWhereUniqueInput
  }


  /**
   * Sectors deleteMany
   */
  export type SectorsDeleteManyArgs = {
    /**
     * Filter which Sectors to delete
     * 
    **/
    where?: SectorsWhereInput
  }


  /**
   * Sectors: findUniqueOrThrow
   */
  export type SectorsFindUniqueOrThrowArgs = SectorsFindUniqueArgsBase
      

  /**
   * Sectors: findFirstOrThrow
   */
  export type SectorsFindFirstOrThrowArgs = SectorsFindFirstArgsBase
      

  /**
   * Sectors without action
   */
  export type SectorsArgs = {
    /**
     * Select specific fields to fetch from the Sectors
     * 
    **/
    select?: SectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SectorsInclude | null
  }



  /**
   * Model Securities
   */


  export type AggregateSecurities = {
    _count: SecuritiesCountAggregateOutputType | null
    _avg: SecuritiesAvgAggregateOutputType | null
    _sum: SecuritiesSumAggregateOutputType | null
    _min: SecuritiesMinAggregateOutputType | null
    _max: SecuritiesMaxAggregateOutputType | null
  }

  export type SecuritiesAvgAggregateOutputType = {
    id: number | null
    securityTypeId: number | null
    marketCap: Decimal | null
    sharesOutstanding: number | null
    numberOfEmployees: number | null
  }

  export type SecuritiesSumAggregateOutputType = {
    id: number | null
    securityTypeId: number | null
    marketCap: Decimal | null
    sharesOutstanding: number | null
    numberOfEmployees: number | null
  }

  export type SecuritiesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    symbol: string | null
    cusip: string | null
    exchange: string | null
    securityTypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    marketCap: Decimal | null
    companyName: string | null
    sector: string | null
    active: boolean | null
    delistedCalendarDate: Date | null
    companyDescription: string | null
    url: string | null
    sharesOutstanding: number | null
    numberOfEmployees: number | null
  }

  export type SecuritiesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    symbol: string | null
    cusip: string | null
    exchange: string | null
    securityTypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    marketCap: Decimal | null
    companyName: string | null
    sector: string | null
    active: boolean | null
    delistedCalendarDate: Date | null
    companyDescription: string | null
    url: string | null
    sharesOutstanding: number | null
    numberOfEmployees: number | null
  }

  export type SecuritiesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    symbol: number
    cusip: number
    exchange: number
    securityTypeId: number
    createdAt: number
    updatedAt: number
    marketCap: number
    companyName: number
    sector: number
    active: number
    delistedCalendarDate: number
    companyDescription: number
    url: number
    sharesOutstanding: number
    numberOfEmployees: number
    _all: number
  }


  export type SecuritiesAvgAggregateInputType = {
    id?: true
    securityTypeId?: true
    marketCap?: true
    sharesOutstanding?: true
    numberOfEmployees?: true
  }

  export type SecuritiesSumAggregateInputType = {
    id?: true
    securityTypeId?: true
    marketCap?: true
    sharesOutstanding?: true
    numberOfEmployees?: true
  }

  export type SecuritiesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    symbol?: true
    cusip?: true
    exchange?: true
    securityTypeId?: true
    createdAt?: true
    updatedAt?: true
    marketCap?: true
    companyName?: true
    sector?: true
    active?: true
    delistedCalendarDate?: true
    companyDescription?: true
    url?: true
    sharesOutstanding?: true
    numberOfEmployees?: true
  }

  export type SecuritiesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    symbol?: true
    cusip?: true
    exchange?: true
    securityTypeId?: true
    createdAt?: true
    updatedAt?: true
    marketCap?: true
    companyName?: true
    sector?: true
    active?: true
    delistedCalendarDate?: true
    companyDescription?: true
    url?: true
    sharesOutstanding?: true
    numberOfEmployees?: true
  }

  export type SecuritiesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    symbol?: true
    cusip?: true
    exchange?: true
    securityTypeId?: true
    createdAt?: true
    updatedAt?: true
    marketCap?: true
    companyName?: true
    sector?: true
    active?: true
    delistedCalendarDate?: true
    companyDescription?: true
    url?: true
    sharesOutstanding?: true
    numberOfEmployees?: true
    _all?: true
  }

  export type SecuritiesAggregateArgs = {
    /**
     * Filter which Securities to aggregate.
     * 
    **/
    where?: SecuritiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Securities to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SecuritiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Securities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Securities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Securities
    **/
    _count?: true | SecuritiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecuritiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecuritiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecuritiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecuritiesMaxAggregateInputType
  }

  export type GetSecuritiesAggregateType<T extends SecuritiesAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurities[P]>
      : GetScalarType<T[P], AggregateSecurities[P]>
  }




  export type SecuritiesGroupByArgs = {
    where?: SecuritiesWhereInput
    orderBy?: Enumerable<SecuritiesOrderByWithAggregationInput>
    by: Array<SecuritiesScalarFieldEnum>
    having?: SecuritiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecuritiesCountAggregateInputType | true
    _avg?: SecuritiesAvgAggregateInputType
    _sum?: SecuritiesSumAggregateInputType
    _min?: SecuritiesMinAggregateInputType
    _max?: SecuritiesMaxAggregateInputType
  }


  export type SecuritiesGroupByOutputType = {
    id: number
    name: string | null
    description: string | null
    symbol: string | null
    cusip: string | null
    exchange: string | null
    securityTypeId: number | null
    createdAt: Date
    updatedAt: Date | null
    marketCap: Decimal | null
    companyName: string | null
    sector: string | null
    active: boolean
    delistedCalendarDate: Date | null
    companyDescription: string | null
    url: string | null
    sharesOutstanding: number | null
    numberOfEmployees: number | null
    _count: SecuritiesCountAggregateOutputType | null
    _avg: SecuritiesAvgAggregateOutputType | null
    _sum: SecuritiesSumAggregateOutputType | null
    _min: SecuritiesMinAggregateOutputType | null
    _max: SecuritiesMaxAggregateOutputType | null
  }

  type GetSecuritiesGroupByPayload<T extends SecuritiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SecuritiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecuritiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecuritiesGroupByOutputType[P]>
            : GetScalarType<T[P], SecuritiesGroupByOutputType[P]>
        }
      >
    >


  export type SecuritiesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    symbol?: boolean
    cusip?: boolean
    exchange?: boolean
    securityTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marketCap?: boolean
    companyName?: boolean
    sector?: boolean
    active?: boolean
    delistedCalendarDate?: boolean
    companyDescription?: boolean
    url?: boolean
    sharesOutstanding?: boolean
    numberOfEmployees?: boolean
    SecurityDaily?: boolean | SecurityDailyFindManyArgs
    SecurityDividends?: boolean | SecurityDividendsFindManyArgs
    SecurityMinutely?: boolean | SecurityMinutelyFindManyArgs
    SecuritySecondly?: boolean | SecuritySecondlyFindManyArgs
    SecuritySplits?: boolean | SecuritySplitsFindManyArgs
    Trades?: boolean | TradesFindManyArgs
    Quotes?: boolean | QuotesFindManyArgs
    _count?: boolean | SecuritiesCountOutputTypeArgs
  }

  export type SecuritiesInclude = {
    SecurityDaily?: boolean | SecurityDailyFindManyArgs
    SecurityDividends?: boolean | SecurityDividendsFindManyArgs
    SecurityMinutely?: boolean | SecurityMinutelyFindManyArgs
    SecuritySecondly?: boolean | SecuritySecondlyFindManyArgs
    SecuritySplits?: boolean | SecuritySplitsFindManyArgs
    Trades?: boolean | TradesFindManyArgs
    Quotes?: boolean | QuotesFindManyArgs
    _count?: boolean | SecuritiesCountOutputTypeArgs
  }

  export type SecuritiesGetPayload<
    S extends boolean | null | undefined | SecuritiesArgs,
    U = keyof S
      > = S extends true
        ? Securities
    : S extends undefined
    ? never
    : S extends SecuritiesArgs | SecuritiesFindManyArgs
    ?'include' extends U
    ? Securities  & {
    [P in TrueKeys<S['include']>]:
        P extends 'SecurityDaily' ? Array < SecurityDailyGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'SecurityDividends' ? Array < SecurityDividendsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'SecurityMinutely' ? Array < SecurityMinutelyGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'SecuritySecondly' ? Array < SecuritySecondlyGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'SecuritySplits' ? Array < SecuritySplitsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Trades' ? Array < TradesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'Quotes' ? Array < QuotesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SecuritiesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'SecurityDaily' ? Array < SecurityDailyGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'SecurityDividends' ? Array < SecurityDividendsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'SecurityMinutely' ? Array < SecurityMinutelyGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'SecuritySecondly' ? Array < SecuritySecondlyGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'SecuritySplits' ? Array < SecuritySplitsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Trades' ? Array < TradesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'Quotes' ? Array < QuotesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SecuritiesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Securities ? Securities[P] : never
  } 
    : Securities
  : Securities


  type SecuritiesCountArgs = Merge<
    Omit<SecuritiesFindManyArgs, 'select' | 'include'> & {
      select?: SecuritiesCountAggregateInputType | true
    }
  >

  export interface SecuritiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Securities that matches the filter.
     * @param {SecuritiesFindUniqueArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecuritiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SecuritiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Securities'> extends True ? CheckSelect<T, Prisma__SecuritiesClient<Securities>, Prisma__SecuritiesClient<SecuritiesGetPayload<T>>> : CheckSelect<T, Prisma__SecuritiesClient<Securities | null, null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | null, null>>

    /**
     * Find the first Securities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesFindFirstArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecuritiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SecuritiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Securities'> extends True ? CheckSelect<T, Prisma__SecuritiesClient<Securities>, Prisma__SecuritiesClient<SecuritiesGetPayload<T>>> : CheckSelect<T, Prisma__SecuritiesClient<Securities | null, null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | null, null>>

    /**
     * Find zero or more Securities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Securities
     * const securities = await prisma.securities.findMany()
     * 
     * // Get first 10 Securities
     * const securities = await prisma.securities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securitiesWithIdOnly = await prisma.securities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecuritiesFindManyArgs>(
      args?: SelectSubset<T, SecuritiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Securities>>, PrismaPromise<Array<SecuritiesGetPayload<T>>>>

    /**
     * Create a Securities.
     * @param {SecuritiesCreateArgs} args - Arguments to create a Securities.
     * @example
     * // Create one Securities
     * const Securities = await prisma.securities.create({
     *   data: {
     *     // ... data to create a Securities
     *   }
     * })
     * 
    **/
    create<T extends SecuritiesCreateArgs>(
      args: SelectSubset<T, SecuritiesCreateArgs>
    ): CheckSelect<T, Prisma__SecuritiesClient<Securities>, Prisma__SecuritiesClient<SecuritiesGetPayload<T>>>

    /**
     * Create many Securities.
     *     @param {SecuritiesCreateManyArgs} args - Arguments to create many Securities.
     *     @example
     *     // Create many Securities
     *     const securities = await prisma.securities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecuritiesCreateManyArgs>(
      args?: SelectSubset<T, SecuritiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Securities.
     * @param {SecuritiesDeleteArgs} args - Arguments to delete one Securities.
     * @example
     * // Delete one Securities
     * const Securities = await prisma.securities.delete({
     *   where: {
     *     // ... filter to delete one Securities
     *   }
     * })
     * 
    **/
    delete<T extends SecuritiesDeleteArgs>(
      args: SelectSubset<T, SecuritiesDeleteArgs>
    ): CheckSelect<T, Prisma__SecuritiesClient<Securities>, Prisma__SecuritiesClient<SecuritiesGetPayload<T>>>

    /**
     * Update one Securities.
     * @param {SecuritiesUpdateArgs} args - Arguments to update one Securities.
     * @example
     * // Update one Securities
     * const securities = await prisma.securities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecuritiesUpdateArgs>(
      args: SelectSubset<T, SecuritiesUpdateArgs>
    ): CheckSelect<T, Prisma__SecuritiesClient<Securities>, Prisma__SecuritiesClient<SecuritiesGetPayload<T>>>

    /**
     * Delete zero or more Securities.
     * @param {SecuritiesDeleteManyArgs} args - Arguments to filter Securities to delete.
     * @example
     * // Delete a few Securities
     * const { count } = await prisma.securities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecuritiesDeleteManyArgs>(
      args?: SelectSubset<T, SecuritiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Securities
     * const securities = await prisma.securities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecuritiesUpdateManyArgs>(
      args: SelectSubset<T, SecuritiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Securities.
     * @param {SecuritiesUpsertArgs} args - Arguments to update or create a Securities.
     * @example
     * // Update or create a Securities
     * const securities = await prisma.securities.upsert({
     *   create: {
     *     // ... data to create a Securities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Securities we want to update
     *   }
     * })
    **/
    upsert<T extends SecuritiesUpsertArgs>(
      args: SelectSubset<T, SecuritiesUpsertArgs>
    ): CheckSelect<T, Prisma__SecuritiesClient<Securities>, Prisma__SecuritiesClient<SecuritiesGetPayload<T>>>

    /**
     * Find one Securities that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SecuritiesFindUniqueOrThrowArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecuritiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SecuritiesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SecuritiesClient<Securities>, Prisma__SecuritiesClient<SecuritiesGetPayload<T>>>

    /**
     * Find the first Securities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesFindFirstOrThrowArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecuritiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SecuritiesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SecuritiesClient<Securities>, Prisma__SecuritiesClient<SecuritiesGetPayload<T>>>

    /**
     * Count the number of Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesCountArgs} args - Arguments to filter Securities to count.
     * @example
     * // Count the number of Securities
     * const count = await prisma.securities.count({
     *   where: {
     *     // ... the filter for the Securities we want to count
     *   }
     * })
    **/
    count<T extends SecuritiesCountArgs>(
      args?: Subset<T, SecuritiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecuritiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecuritiesAggregateArgs>(args: Subset<T, SecuritiesAggregateArgs>): PrismaPromise<GetSecuritiesAggregateType<T>>

    /**
     * Group by Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecuritiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecuritiesGroupByArgs['orderBy'] }
        : { orderBy?: SecuritiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecuritiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecuritiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Securities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SecuritiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    SecurityDaily<T extends SecurityDailyFindManyArgs = {}>(args?: Subset<T, SecurityDailyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SecurityDaily>| Null>, PrismaPromise<Array<SecurityDailyGetPayload<T>>| Null>>;

    SecurityDividends<T extends SecurityDividendsFindManyArgs = {}>(args?: Subset<T, SecurityDividendsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SecurityDividends>| Null>, PrismaPromise<Array<SecurityDividendsGetPayload<T>>| Null>>;

    SecurityMinutely<T extends SecurityMinutelyFindManyArgs = {}>(args?: Subset<T, SecurityMinutelyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SecurityMinutely>| Null>, PrismaPromise<Array<SecurityMinutelyGetPayload<T>>| Null>>;

    SecuritySecondly<T extends SecuritySecondlyFindManyArgs = {}>(args?: Subset<T, SecuritySecondlyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SecuritySecondly>| Null>, PrismaPromise<Array<SecuritySecondlyGetPayload<T>>| Null>>;

    SecuritySplits<T extends SecuritySplitsFindManyArgs = {}>(args?: Subset<T, SecuritySplitsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SecuritySplits>| Null>, PrismaPromise<Array<SecuritySplitsGetPayload<T>>| Null>>;

    Trades<T extends TradesFindManyArgs = {}>(args?: Subset<T, TradesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Trades>| Null>, PrismaPromise<Array<TradesGetPayload<T>>| Null>>;

    Quotes<T extends QuotesFindManyArgs = {}>(args?: Subset<T, QuotesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Quotes>| Null>, PrismaPromise<Array<QuotesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Securities base type for findUnique actions
   */
  export type SecuritiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Securities
     * 
    **/
    select?: SecuritiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritiesInclude | null
    /**
     * Filter, which Securities to fetch.
     * 
    **/
    where: SecuritiesWhereUniqueInput
  }

  /**
   * Securities: findUnique
   */
  export interface SecuritiesFindUniqueArgs extends SecuritiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Securities base type for findFirst actions
   */
  export type SecuritiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Securities
     * 
    **/
    select?: SecuritiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritiesInclude | null
    /**
     * Filter, which Securities to fetch.
     * 
    **/
    where?: SecuritiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Securities to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Securities.
     * 
    **/
    cursor?: SecuritiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Securities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Securities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Securities.
     * 
    **/
    distinct?: Enumerable<SecuritiesScalarFieldEnum>
  }

  /**
   * Securities: findFirst
   */
  export interface SecuritiesFindFirstArgs extends SecuritiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Securities findMany
   */
  export type SecuritiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Securities
     * 
    **/
    select?: SecuritiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritiesInclude | null
    /**
     * Filter, which Securities to fetch.
     * 
    **/
    where?: SecuritiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Securities to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Securities.
     * 
    **/
    cursor?: SecuritiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Securities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Securities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SecuritiesScalarFieldEnum>
  }


  /**
   * Securities create
   */
  export type SecuritiesCreateArgs = {
    /**
     * Select specific fields to fetch from the Securities
     * 
    **/
    select?: SecuritiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritiesInclude | null
    /**
     * The data needed to create a Securities.
     * 
    **/
    data: XOR<SecuritiesCreateInput, SecuritiesUncheckedCreateInput>
  }


  /**
   * Securities createMany
   */
  export type SecuritiesCreateManyArgs = {
    /**
     * The data used to create many Securities.
     * 
    **/
    data: Enumerable<SecuritiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Securities update
   */
  export type SecuritiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Securities
     * 
    **/
    select?: SecuritiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritiesInclude | null
    /**
     * The data needed to update a Securities.
     * 
    **/
    data: XOR<SecuritiesUpdateInput, SecuritiesUncheckedUpdateInput>
    /**
     * Choose, which Securities to update.
     * 
    **/
    where: SecuritiesWhereUniqueInput
  }


  /**
   * Securities updateMany
   */
  export type SecuritiesUpdateManyArgs = {
    /**
     * The data used to update Securities.
     * 
    **/
    data: XOR<SecuritiesUpdateManyMutationInput, SecuritiesUncheckedUpdateManyInput>
    /**
     * Filter which Securities to update
     * 
    **/
    where?: SecuritiesWhereInput
  }


  /**
   * Securities upsert
   */
  export type SecuritiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Securities
     * 
    **/
    select?: SecuritiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritiesInclude | null
    /**
     * The filter to search for the Securities to update in case it exists.
     * 
    **/
    where: SecuritiesWhereUniqueInput
    /**
     * In case the Securities found by the `where` argument doesn't exist, create a new Securities with this data.
     * 
    **/
    create: XOR<SecuritiesCreateInput, SecuritiesUncheckedCreateInput>
    /**
     * In case the Securities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SecuritiesUpdateInput, SecuritiesUncheckedUpdateInput>
  }


  /**
   * Securities delete
   */
  export type SecuritiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Securities
     * 
    **/
    select?: SecuritiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritiesInclude | null
    /**
     * Filter which Securities to delete.
     * 
    **/
    where: SecuritiesWhereUniqueInput
  }


  /**
   * Securities deleteMany
   */
  export type SecuritiesDeleteManyArgs = {
    /**
     * Filter which Securities to delete
     * 
    **/
    where?: SecuritiesWhereInput
  }


  /**
   * Securities: findUniqueOrThrow
   */
  export type SecuritiesFindUniqueOrThrowArgs = SecuritiesFindUniqueArgsBase
      

  /**
   * Securities: findFirstOrThrow
   */
  export type SecuritiesFindFirstOrThrowArgs = SecuritiesFindFirstArgsBase
      

  /**
   * Securities without action
   */
  export type SecuritiesArgs = {
    /**
     * Select specific fields to fetch from the Securities
     * 
    **/
    select?: SecuritiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritiesInclude | null
  }



  /**
   * Model SecurityDaily
   */


  export type AggregateSecurityDaily = {
    _count: SecurityDailyCountAggregateOutputType | null
    _avg: SecurityDailyAvgAggregateOutputType | null
    _sum: SecurityDailySumAggregateOutputType | null
    _min: SecurityDailyMinAggregateOutputType | null
    _max: SecurityDailyMaxAggregateOutputType | null
  }

  export type SecurityDailyAvgAggregateOutputType = {
    id: number | null
    securityId: number | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    adjustedClose: Decimal | null
    marketCap: Decimal | null
    enterpriseValue: Decimal | null
    peRatio: Decimal | null
    pbRatio: Decimal | null
    trailingOneYearPegRatio: Decimal | null
    dividendAmount: Decimal | null
    splitCoefficient: Decimal | null
    volume: number | null
  }

  export type SecurityDailySumAggregateOutputType = {
    id: number | null
    securityId: number | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    adjustedClose: Decimal | null
    marketCap: Decimal | null
    enterpriseValue: Decimal | null
    peRatio: Decimal | null
    pbRatio: Decimal | null
    trailingOneYearPegRatio: Decimal | null
    dividendAmount: Decimal | null
    splitCoefficient: Decimal | null
    volume: number | null
  }

  export type SecurityDailyMinAggregateOutputType = {
    id: number | null
    securityId: number | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    adjustedClose: Decimal | null
    marketCap: Decimal | null
    enterpriseValue: Decimal | null
    peRatio: Decimal | null
    pbRatio: Decimal | null
    trailingOneYearPegRatio: Decimal | null
    dividendAmount: Decimal | null
    splitCoefficient: Decimal | null
    volume: number | null
    adjusted: boolean | null
    calendarDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityDailyMaxAggregateOutputType = {
    id: number | null
    securityId: number | null
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    adjustedClose: Decimal | null
    marketCap: Decimal | null
    enterpriseValue: Decimal | null
    peRatio: Decimal | null
    pbRatio: Decimal | null
    trailingOneYearPegRatio: Decimal | null
    dividendAmount: Decimal | null
    splitCoefficient: Decimal | null
    volume: number | null
    adjusted: boolean | null
    calendarDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityDailyCountAggregateOutputType = {
    id: number
    securityId: number
    open: number
    high: number
    low: number
    close: number
    adjustedClose: number
    marketCap: number
    enterpriseValue: number
    peRatio: number
    pbRatio: number
    trailingOneYearPegRatio: number
    dividendAmount: number
    splitCoefficient: number
    volume: number
    adjusted: number
    calendarDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityDailyAvgAggregateInputType = {
    id?: true
    securityId?: true
    open?: true
    high?: true
    low?: true
    close?: true
    adjustedClose?: true
    marketCap?: true
    enterpriseValue?: true
    peRatio?: true
    pbRatio?: true
    trailingOneYearPegRatio?: true
    dividendAmount?: true
    splitCoefficient?: true
    volume?: true
  }

  export type SecurityDailySumAggregateInputType = {
    id?: true
    securityId?: true
    open?: true
    high?: true
    low?: true
    close?: true
    adjustedClose?: true
    marketCap?: true
    enterpriseValue?: true
    peRatio?: true
    pbRatio?: true
    trailingOneYearPegRatio?: true
    dividendAmount?: true
    splitCoefficient?: true
    volume?: true
  }

  export type SecurityDailyMinAggregateInputType = {
    id?: true
    securityId?: true
    open?: true
    high?: true
    low?: true
    close?: true
    adjustedClose?: true
    marketCap?: true
    enterpriseValue?: true
    peRatio?: true
    pbRatio?: true
    trailingOneYearPegRatio?: true
    dividendAmount?: true
    splitCoefficient?: true
    volume?: true
    adjusted?: true
    calendarDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityDailyMaxAggregateInputType = {
    id?: true
    securityId?: true
    open?: true
    high?: true
    low?: true
    close?: true
    adjustedClose?: true
    marketCap?: true
    enterpriseValue?: true
    peRatio?: true
    pbRatio?: true
    trailingOneYearPegRatio?: true
    dividendAmount?: true
    splitCoefficient?: true
    volume?: true
    adjusted?: true
    calendarDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityDailyCountAggregateInputType = {
    id?: true
    securityId?: true
    open?: true
    high?: true
    low?: true
    close?: true
    adjustedClose?: true
    marketCap?: true
    enterpriseValue?: true
    peRatio?: true
    pbRatio?: true
    trailingOneYearPegRatio?: true
    dividendAmount?: true
    splitCoefficient?: true
    volume?: true
    adjusted?: true
    calendarDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityDailyAggregateArgs = {
    /**
     * Filter which SecurityDaily to aggregate.
     * 
    **/
    where?: SecurityDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityDailies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityDailyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SecurityDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityDailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityDailies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityDailies
    **/
    _count?: true | SecurityDailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityDailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityDailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityDailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityDailyMaxAggregateInputType
  }

  export type GetSecurityDailyAggregateType<T extends SecurityDailyAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityDaily[P]>
      : GetScalarType<T[P], AggregateSecurityDaily[P]>
  }




  export type SecurityDailyGroupByArgs = {
    where?: SecurityDailyWhereInput
    orderBy?: Enumerable<SecurityDailyOrderByWithAggregationInput>
    by: Array<SecurityDailyScalarFieldEnum>
    having?: SecurityDailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityDailyCountAggregateInputType | true
    _avg?: SecurityDailyAvgAggregateInputType
    _sum?: SecurityDailySumAggregateInputType
    _min?: SecurityDailyMinAggregateInputType
    _max?: SecurityDailyMaxAggregateInputType
  }


  export type SecurityDailyGroupByOutputType = {
    id: number
    securityId: number
    open: Decimal | null
    high: Decimal | null
    low: Decimal | null
    close: Decimal | null
    adjustedClose: Decimal | null
    marketCap: Decimal | null
    enterpriseValue: Decimal | null
    peRatio: Decimal | null
    pbRatio: Decimal | null
    trailingOneYearPegRatio: Decimal | null
    dividendAmount: Decimal | null
    splitCoefficient: Decimal | null
    volume: number
    adjusted: boolean
    calendarDate: Date
    createdAt: Date
    updatedAt: Date | null
    _count: SecurityDailyCountAggregateOutputType | null
    _avg: SecurityDailyAvgAggregateOutputType | null
    _sum: SecurityDailySumAggregateOutputType | null
    _min: SecurityDailyMinAggregateOutputType | null
    _max: SecurityDailyMaxAggregateOutputType | null
  }

  type GetSecurityDailyGroupByPayload<T extends SecurityDailyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SecurityDailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityDailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityDailyGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityDailyGroupByOutputType[P]>
        }
      >
    >


  export type SecurityDailySelect = {
    id?: boolean
    securityId?: boolean
    open?: boolean
    high?: boolean
    low?: boolean
    close?: boolean
    adjustedClose?: boolean
    marketCap?: boolean
    enterpriseValue?: boolean
    peRatio?: boolean
    pbRatio?: boolean
    trailingOneYearPegRatio?: boolean
    dividendAmount?: boolean
    splitCoefficient?: boolean
    volume?: boolean
    adjusted?: boolean
    calendarDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Security?: boolean | SecuritiesArgs
  }

  export type SecurityDailyInclude = {
    Security?: boolean | SecuritiesArgs
  }

  export type SecurityDailyGetPayload<
    S extends boolean | null | undefined | SecurityDailyArgs,
    U = keyof S
      > = S extends true
        ? SecurityDaily
    : S extends undefined
    ? never
    : S extends SecurityDailyArgs | SecurityDailyFindManyArgs
    ?'include' extends U
    ? SecurityDaily  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SecurityDaily ? SecurityDaily[P] : never
  } 
    : SecurityDaily
  : SecurityDaily


  type SecurityDailyCountArgs = Merge<
    Omit<SecurityDailyFindManyArgs, 'select' | 'include'> & {
      select?: SecurityDailyCountAggregateInputType | true
    }
  >

  export interface SecurityDailyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SecurityDaily that matches the filter.
     * @param {SecurityDailyFindUniqueArgs} args - Arguments to find a SecurityDaily
     * @example
     * // Get one SecurityDaily
     * const securityDaily = await prisma.securityDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecurityDailyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SecurityDailyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SecurityDaily'> extends True ? CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T>>> : CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily | null, null>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T> | null, null>>

    /**
     * Find the first SecurityDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDailyFindFirstArgs} args - Arguments to find a SecurityDaily
     * @example
     * // Get one SecurityDaily
     * const securityDaily = await prisma.securityDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecurityDailyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SecurityDailyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SecurityDaily'> extends True ? CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T>>> : CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily | null, null>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T> | null, null>>

    /**
     * Find zero or more SecurityDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDailyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityDailies
     * const securityDailies = await prisma.securityDaily.findMany()
     * 
     * // Get first 10 SecurityDailies
     * const securityDailies = await prisma.securityDaily.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityDailyWithIdOnly = await prisma.securityDaily.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecurityDailyFindManyArgs>(
      args?: SelectSubset<T, SecurityDailyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SecurityDaily>>, PrismaPromise<Array<SecurityDailyGetPayload<T>>>>

    /**
     * Create a SecurityDaily.
     * @param {SecurityDailyCreateArgs} args - Arguments to create a SecurityDaily.
     * @example
     * // Create one SecurityDaily
     * const SecurityDaily = await prisma.securityDaily.create({
     *   data: {
     *     // ... data to create a SecurityDaily
     *   }
     * })
     * 
    **/
    create<T extends SecurityDailyCreateArgs>(
      args: SelectSubset<T, SecurityDailyCreateArgs>
    ): CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T>>>

    /**
     * Create many SecurityDailies.
     *     @param {SecurityDailyCreateManyArgs} args - Arguments to create many SecurityDailies.
     *     @example
     *     // Create many SecurityDailies
     *     const securityDaily = await prisma.securityDaily.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecurityDailyCreateManyArgs>(
      args?: SelectSubset<T, SecurityDailyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SecurityDaily.
     * @param {SecurityDailyDeleteArgs} args - Arguments to delete one SecurityDaily.
     * @example
     * // Delete one SecurityDaily
     * const SecurityDaily = await prisma.securityDaily.delete({
     *   where: {
     *     // ... filter to delete one SecurityDaily
     *   }
     * })
     * 
    **/
    delete<T extends SecurityDailyDeleteArgs>(
      args: SelectSubset<T, SecurityDailyDeleteArgs>
    ): CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T>>>

    /**
     * Update one SecurityDaily.
     * @param {SecurityDailyUpdateArgs} args - Arguments to update one SecurityDaily.
     * @example
     * // Update one SecurityDaily
     * const securityDaily = await prisma.securityDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecurityDailyUpdateArgs>(
      args: SelectSubset<T, SecurityDailyUpdateArgs>
    ): CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T>>>

    /**
     * Delete zero or more SecurityDailies.
     * @param {SecurityDailyDeleteManyArgs} args - Arguments to filter SecurityDailies to delete.
     * @example
     * // Delete a few SecurityDailies
     * const { count } = await prisma.securityDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecurityDailyDeleteManyArgs>(
      args?: SelectSubset<T, SecurityDailyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityDailies
     * const securityDaily = await prisma.securityDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecurityDailyUpdateManyArgs>(
      args: SelectSubset<T, SecurityDailyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityDaily.
     * @param {SecurityDailyUpsertArgs} args - Arguments to update or create a SecurityDaily.
     * @example
     * // Update or create a SecurityDaily
     * const securityDaily = await prisma.securityDaily.upsert({
     *   create: {
     *     // ... data to create a SecurityDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityDaily we want to update
     *   }
     * })
    **/
    upsert<T extends SecurityDailyUpsertArgs>(
      args: SelectSubset<T, SecurityDailyUpsertArgs>
    ): CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T>>>

    /**
     * Find one SecurityDaily that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SecurityDailyFindUniqueOrThrowArgs} args - Arguments to find a SecurityDaily
     * @example
     * // Get one SecurityDaily
     * const securityDaily = await prisma.securityDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecurityDailyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SecurityDailyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T>>>

    /**
     * Find the first SecurityDaily that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDailyFindFirstOrThrowArgs} args - Arguments to find a SecurityDaily
     * @example
     * // Get one SecurityDaily
     * const securityDaily = await prisma.securityDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecurityDailyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SecurityDailyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityDailyClient<SecurityDaily>, Prisma__SecurityDailyClient<SecurityDailyGetPayload<T>>>

    /**
     * Count the number of SecurityDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDailyCountArgs} args - Arguments to filter SecurityDailies to count.
     * @example
     * // Count the number of SecurityDailies
     * const count = await prisma.securityDaily.count({
     *   where: {
     *     // ... the filter for the SecurityDailies we want to count
     *   }
     * })
    **/
    count<T extends SecurityDailyCountArgs>(
      args?: Subset<T, SecurityDailyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityDailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityDailyAggregateArgs>(args: Subset<T, SecurityDailyAggregateArgs>): PrismaPromise<GetSecurityDailyAggregateType<T>>

    /**
     * Group by SecurityDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityDailyGroupByArgs['orderBy'] }
        : { orderBy?: SecurityDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityDailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityDailyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SecurityDailyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Security<T extends SecuritiesArgs = {}>(args?: Subset<T, SecuritiesArgs>): CheckSelect<T, Prisma__SecuritiesClient<Securities | Null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SecurityDaily base type for findUnique actions
   */
  export type SecurityDailyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityDaily
     * 
    **/
    select?: SecurityDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDailyInclude | null
    /**
     * Filter, which SecurityDaily to fetch.
     * 
    **/
    where: SecurityDailyWhereUniqueInput
  }

  /**
   * SecurityDaily: findUnique
   */
  export interface SecurityDailyFindUniqueArgs extends SecurityDailyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityDaily base type for findFirst actions
   */
  export type SecurityDailyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityDaily
     * 
    **/
    select?: SecurityDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDailyInclude | null
    /**
     * Filter, which SecurityDaily to fetch.
     * 
    **/
    where?: SecurityDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityDailies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityDailyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityDailies.
     * 
    **/
    cursor?: SecurityDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityDailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityDailies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityDailies.
     * 
    **/
    distinct?: Enumerable<SecurityDailyScalarFieldEnum>
  }

  /**
   * SecurityDaily: findFirst
   */
  export interface SecurityDailyFindFirstArgs extends SecurityDailyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityDaily findMany
   */
  export type SecurityDailyFindManyArgs = {
    /**
     * Select specific fields to fetch from the SecurityDaily
     * 
    **/
    select?: SecurityDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDailyInclude | null
    /**
     * Filter, which SecurityDailies to fetch.
     * 
    **/
    where?: SecurityDailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityDailies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityDailyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityDailies.
     * 
    **/
    cursor?: SecurityDailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityDailies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityDailies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SecurityDailyScalarFieldEnum>
  }


  /**
   * SecurityDaily create
   */
  export type SecurityDailyCreateArgs = {
    /**
     * Select specific fields to fetch from the SecurityDaily
     * 
    **/
    select?: SecurityDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDailyInclude | null
    /**
     * The data needed to create a SecurityDaily.
     * 
    **/
    data: XOR<SecurityDailyCreateInput, SecurityDailyUncheckedCreateInput>
  }


  /**
   * SecurityDaily createMany
   */
  export type SecurityDailyCreateManyArgs = {
    /**
     * The data used to create many SecurityDailies.
     * 
    **/
    data: Enumerable<SecurityDailyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SecurityDaily update
   */
  export type SecurityDailyUpdateArgs = {
    /**
     * Select specific fields to fetch from the SecurityDaily
     * 
    **/
    select?: SecurityDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDailyInclude | null
    /**
     * The data needed to update a SecurityDaily.
     * 
    **/
    data: XOR<SecurityDailyUpdateInput, SecurityDailyUncheckedUpdateInput>
    /**
     * Choose, which SecurityDaily to update.
     * 
    **/
    where: SecurityDailyWhereUniqueInput
  }


  /**
   * SecurityDaily updateMany
   */
  export type SecurityDailyUpdateManyArgs = {
    /**
     * The data used to update SecurityDailies.
     * 
    **/
    data: XOR<SecurityDailyUpdateManyMutationInput, SecurityDailyUncheckedUpdateManyInput>
    /**
     * Filter which SecurityDailies to update
     * 
    **/
    where?: SecurityDailyWhereInput
  }


  /**
   * SecurityDaily upsert
   */
  export type SecurityDailyUpsertArgs = {
    /**
     * Select specific fields to fetch from the SecurityDaily
     * 
    **/
    select?: SecurityDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDailyInclude | null
    /**
     * The filter to search for the SecurityDaily to update in case it exists.
     * 
    **/
    where: SecurityDailyWhereUniqueInput
    /**
     * In case the SecurityDaily found by the `where` argument doesn't exist, create a new SecurityDaily with this data.
     * 
    **/
    create: XOR<SecurityDailyCreateInput, SecurityDailyUncheckedCreateInput>
    /**
     * In case the SecurityDaily was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SecurityDailyUpdateInput, SecurityDailyUncheckedUpdateInput>
  }


  /**
   * SecurityDaily delete
   */
  export type SecurityDailyDeleteArgs = {
    /**
     * Select specific fields to fetch from the SecurityDaily
     * 
    **/
    select?: SecurityDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDailyInclude | null
    /**
     * Filter which SecurityDaily to delete.
     * 
    **/
    where: SecurityDailyWhereUniqueInput
  }


  /**
   * SecurityDaily deleteMany
   */
  export type SecurityDailyDeleteManyArgs = {
    /**
     * Filter which SecurityDailies to delete
     * 
    **/
    where?: SecurityDailyWhereInput
  }


  /**
   * SecurityDaily: findUniqueOrThrow
   */
  export type SecurityDailyFindUniqueOrThrowArgs = SecurityDailyFindUniqueArgsBase
      

  /**
   * SecurityDaily: findFirstOrThrow
   */
  export type SecurityDailyFindFirstOrThrowArgs = SecurityDailyFindFirstArgsBase
      

  /**
   * SecurityDaily without action
   */
  export type SecurityDailyArgs = {
    /**
     * Select specific fields to fetch from the SecurityDaily
     * 
    **/
    select?: SecurityDailySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDailyInclude | null
  }



  /**
   * Model SecurityDividends
   */


  export type AggregateSecurityDividends = {
    _count: SecurityDividendsCountAggregateOutputType | null
    _avg: SecurityDividendsAvgAggregateOutputType | null
    _sum: SecurityDividendsSumAggregateOutputType | null
    _min: SecurityDividendsMinAggregateOutputType | null
    _max: SecurityDividendsMaxAggregateOutputType | null
  }

  export type SecurityDividendsAvgAggregateOutputType = {
    id: number | null
    securityId: number | null
    amount: Decimal | null
  }

  export type SecurityDividendsSumAggregateOutputType = {
    id: number | null
    securityId: number | null
    amount: Decimal | null
  }

  export type SecurityDividendsMinAggregateOutputType = {
    id: number | null
    securityId: number | null
    expirationDate: Date | null
    paymentDate: Date | null
    recordDate: Date | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityDividendsMaxAggregateOutputType = {
    id: number | null
    securityId: number | null
    expirationDate: Date | null
    paymentDate: Date | null
    recordDate: Date | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecurityDividendsCountAggregateOutputType = {
    id: number
    securityId: number
    expirationDate: number
    paymentDate: number
    recordDate: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecurityDividendsAvgAggregateInputType = {
    id?: true
    securityId?: true
    amount?: true
  }

  export type SecurityDividendsSumAggregateInputType = {
    id?: true
    securityId?: true
    amount?: true
  }

  export type SecurityDividendsMinAggregateInputType = {
    id?: true
    securityId?: true
    expirationDate?: true
    paymentDate?: true
    recordDate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityDividendsMaxAggregateInputType = {
    id?: true
    securityId?: true
    expirationDate?: true
    paymentDate?: true
    recordDate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecurityDividendsCountAggregateInputType = {
    id?: true
    securityId?: true
    expirationDate?: true
    paymentDate?: true
    recordDate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecurityDividendsAggregateArgs = {
    /**
     * Filter which SecurityDividends to aggregate.
     * 
    **/
    where?: SecurityDividendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityDividends to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityDividendsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SecurityDividendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityDividends from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityDividends.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityDividends
    **/
    _count?: true | SecurityDividendsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityDividendsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityDividendsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityDividendsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityDividendsMaxAggregateInputType
  }

  export type GetSecurityDividendsAggregateType<T extends SecurityDividendsAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityDividends]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityDividends[P]>
      : GetScalarType<T[P], AggregateSecurityDividends[P]>
  }




  export type SecurityDividendsGroupByArgs = {
    where?: SecurityDividendsWhereInput
    orderBy?: Enumerable<SecurityDividendsOrderByWithAggregationInput>
    by: Array<SecurityDividendsScalarFieldEnum>
    having?: SecurityDividendsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityDividendsCountAggregateInputType | true
    _avg?: SecurityDividendsAvgAggregateInputType
    _sum?: SecurityDividendsSumAggregateInputType
    _min?: SecurityDividendsMinAggregateInputType
    _max?: SecurityDividendsMaxAggregateInputType
  }


  export type SecurityDividendsGroupByOutputType = {
    id: number
    securityId: number
    expirationDate: Date | null
    paymentDate: Date
    recordDate: Date
    amount: Decimal
    createdAt: Date
    updatedAt: Date | null
    _count: SecurityDividendsCountAggregateOutputType | null
    _avg: SecurityDividendsAvgAggregateOutputType | null
    _sum: SecurityDividendsSumAggregateOutputType | null
    _min: SecurityDividendsMinAggregateOutputType | null
    _max: SecurityDividendsMaxAggregateOutputType | null
  }

  type GetSecurityDividendsGroupByPayload<T extends SecurityDividendsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SecurityDividendsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityDividendsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityDividendsGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityDividendsGroupByOutputType[P]>
        }
      >
    >


  export type SecurityDividendsSelect = {
    id?: boolean
    securityId?: boolean
    expirationDate?: boolean
    paymentDate?: boolean
    recordDate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Security?: boolean | SecuritiesArgs
  }

  export type SecurityDividendsInclude = {
    Security?: boolean | SecuritiesArgs
  }

  export type SecurityDividendsGetPayload<
    S extends boolean | null | undefined | SecurityDividendsArgs,
    U = keyof S
      > = S extends true
        ? SecurityDividends
    : S extends undefined
    ? never
    : S extends SecurityDividendsArgs | SecurityDividendsFindManyArgs
    ?'include' extends U
    ? SecurityDividends  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SecurityDividends ? SecurityDividends[P] : never
  } 
    : SecurityDividends
  : SecurityDividends


  type SecurityDividendsCountArgs = Merge<
    Omit<SecurityDividendsFindManyArgs, 'select' | 'include'> & {
      select?: SecurityDividendsCountAggregateInputType | true
    }
  >

  export interface SecurityDividendsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SecurityDividends that matches the filter.
     * @param {SecurityDividendsFindUniqueArgs} args - Arguments to find a SecurityDividends
     * @example
     * // Get one SecurityDividends
     * const securityDividends = await prisma.securityDividends.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecurityDividendsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SecurityDividendsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SecurityDividends'> extends True ? CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T>>> : CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends | null, null>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T> | null, null>>

    /**
     * Find the first SecurityDividends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDividendsFindFirstArgs} args - Arguments to find a SecurityDividends
     * @example
     * // Get one SecurityDividends
     * const securityDividends = await prisma.securityDividends.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecurityDividendsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SecurityDividendsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SecurityDividends'> extends True ? CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T>>> : CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends | null, null>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T> | null, null>>

    /**
     * Find zero or more SecurityDividends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDividendsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityDividends
     * const securityDividends = await prisma.securityDividends.findMany()
     * 
     * // Get first 10 SecurityDividends
     * const securityDividends = await prisma.securityDividends.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityDividendsWithIdOnly = await prisma.securityDividends.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecurityDividendsFindManyArgs>(
      args?: SelectSubset<T, SecurityDividendsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SecurityDividends>>, PrismaPromise<Array<SecurityDividendsGetPayload<T>>>>

    /**
     * Create a SecurityDividends.
     * @param {SecurityDividendsCreateArgs} args - Arguments to create a SecurityDividends.
     * @example
     * // Create one SecurityDividends
     * const SecurityDividends = await prisma.securityDividends.create({
     *   data: {
     *     // ... data to create a SecurityDividends
     *   }
     * })
     * 
    **/
    create<T extends SecurityDividendsCreateArgs>(
      args: SelectSubset<T, SecurityDividendsCreateArgs>
    ): CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T>>>

    /**
     * Create many SecurityDividends.
     *     @param {SecurityDividendsCreateManyArgs} args - Arguments to create many SecurityDividends.
     *     @example
     *     // Create many SecurityDividends
     *     const securityDividends = await prisma.securityDividends.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecurityDividendsCreateManyArgs>(
      args?: SelectSubset<T, SecurityDividendsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SecurityDividends.
     * @param {SecurityDividendsDeleteArgs} args - Arguments to delete one SecurityDividends.
     * @example
     * // Delete one SecurityDividends
     * const SecurityDividends = await prisma.securityDividends.delete({
     *   where: {
     *     // ... filter to delete one SecurityDividends
     *   }
     * })
     * 
    **/
    delete<T extends SecurityDividendsDeleteArgs>(
      args: SelectSubset<T, SecurityDividendsDeleteArgs>
    ): CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T>>>

    /**
     * Update one SecurityDividends.
     * @param {SecurityDividendsUpdateArgs} args - Arguments to update one SecurityDividends.
     * @example
     * // Update one SecurityDividends
     * const securityDividends = await prisma.securityDividends.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecurityDividendsUpdateArgs>(
      args: SelectSubset<T, SecurityDividendsUpdateArgs>
    ): CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T>>>

    /**
     * Delete zero or more SecurityDividends.
     * @param {SecurityDividendsDeleteManyArgs} args - Arguments to filter SecurityDividends to delete.
     * @example
     * // Delete a few SecurityDividends
     * const { count } = await prisma.securityDividends.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecurityDividendsDeleteManyArgs>(
      args?: SelectSubset<T, SecurityDividendsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityDividends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDividendsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityDividends
     * const securityDividends = await prisma.securityDividends.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecurityDividendsUpdateManyArgs>(
      args: SelectSubset<T, SecurityDividendsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityDividends.
     * @param {SecurityDividendsUpsertArgs} args - Arguments to update or create a SecurityDividends.
     * @example
     * // Update or create a SecurityDividends
     * const securityDividends = await prisma.securityDividends.upsert({
     *   create: {
     *     // ... data to create a SecurityDividends
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityDividends we want to update
     *   }
     * })
    **/
    upsert<T extends SecurityDividendsUpsertArgs>(
      args: SelectSubset<T, SecurityDividendsUpsertArgs>
    ): CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T>>>

    /**
     * Find one SecurityDividends that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SecurityDividendsFindUniqueOrThrowArgs} args - Arguments to find a SecurityDividends
     * @example
     * // Get one SecurityDividends
     * const securityDividends = await prisma.securityDividends.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecurityDividendsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SecurityDividendsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T>>>

    /**
     * Find the first SecurityDividends that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDividendsFindFirstOrThrowArgs} args - Arguments to find a SecurityDividends
     * @example
     * // Get one SecurityDividends
     * const securityDividends = await prisma.securityDividends.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecurityDividendsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SecurityDividendsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityDividendsClient<SecurityDividends>, Prisma__SecurityDividendsClient<SecurityDividendsGetPayload<T>>>

    /**
     * Count the number of SecurityDividends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDividendsCountArgs} args - Arguments to filter SecurityDividends to count.
     * @example
     * // Count the number of SecurityDividends
     * const count = await prisma.securityDividends.count({
     *   where: {
     *     // ... the filter for the SecurityDividends we want to count
     *   }
     * })
    **/
    count<T extends SecurityDividendsCountArgs>(
      args?: Subset<T, SecurityDividendsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityDividendsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityDividends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDividendsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityDividendsAggregateArgs>(args: Subset<T, SecurityDividendsAggregateArgs>): PrismaPromise<GetSecurityDividendsAggregateType<T>>

    /**
     * Group by SecurityDividends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityDividendsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityDividendsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityDividendsGroupByArgs['orderBy'] }
        : { orderBy?: SecurityDividendsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityDividendsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityDividendsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityDividends.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SecurityDividendsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Security<T extends SecuritiesArgs = {}>(args?: Subset<T, SecuritiesArgs>): CheckSelect<T, Prisma__SecuritiesClient<Securities | Null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SecurityDividends base type for findUnique actions
   */
  export type SecurityDividendsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityDividends
     * 
    **/
    select?: SecurityDividendsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDividendsInclude | null
    /**
     * Filter, which SecurityDividends to fetch.
     * 
    **/
    where: SecurityDividendsWhereUniqueInput
  }

  /**
   * SecurityDividends: findUnique
   */
  export interface SecurityDividendsFindUniqueArgs extends SecurityDividendsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityDividends base type for findFirst actions
   */
  export type SecurityDividendsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityDividends
     * 
    **/
    select?: SecurityDividendsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDividendsInclude | null
    /**
     * Filter, which SecurityDividends to fetch.
     * 
    **/
    where?: SecurityDividendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityDividends to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityDividendsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityDividends.
     * 
    **/
    cursor?: SecurityDividendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityDividends from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityDividends.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityDividends.
     * 
    **/
    distinct?: Enumerable<SecurityDividendsScalarFieldEnum>
  }

  /**
   * SecurityDividends: findFirst
   */
  export interface SecurityDividendsFindFirstArgs extends SecurityDividendsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityDividends findMany
   */
  export type SecurityDividendsFindManyArgs = {
    /**
     * Select specific fields to fetch from the SecurityDividends
     * 
    **/
    select?: SecurityDividendsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDividendsInclude | null
    /**
     * Filter, which SecurityDividends to fetch.
     * 
    **/
    where?: SecurityDividendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityDividends to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityDividendsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityDividends.
     * 
    **/
    cursor?: SecurityDividendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityDividends from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityDividends.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SecurityDividendsScalarFieldEnum>
  }


  /**
   * SecurityDividends create
   */
  export type SecurityDividendsCreateArgs = {
    /**
     * Select specific fields to fetch from the SecurityDividends
     * 
    **/
    select?: SecurityDividendsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDividendsInclude | null
    /**
     * The data needed to create a SecurityDividends.
     * 
    **/
    data: XOR<SecurityDividendsCreateInput, SecurityDividendsUncheckedCreateInput>
  }


  /**
   * SecurityDividends createMany
   */
  export type SecurityDividendsCreateManyArgs = {
    /**
     * The data used to create many SecurityDividends.
     * 
    **/
    data: Enumerable<SecurityDividendsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SecurityDividends update
   */
  export type SecurityDividendsUpdateArgs = {
    /**
     * Select specific fields to fetch from the SecurityDividends
     * 
    **/
    select?: SecurityDividendsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDividendsInclude | null
    /**
     * The data needed to update a SecurityDividends.
     * 
    **/
    data: XOR<SecurityDividendsUpdateInput, SecurityDividendsUncheckedUpdateInput>
    /**
     * Choose, which SecurityDividends to update.
     * 
    **/
    where: SecurityDividendsWhereUniqueInput
  }


  /**
   * SecurityDividends updateMany
   */
  export type SecurityDividendsUpdateManyArgs = {
    /**
     * The data used to update SecurityDividends.
     * 
    **/
    data: XOR<SecurityDividendsUpdateManyMutationInput, SecurityDividendsUncheckedUpdateManyInput>
    /**
     * Filter which SecurityDividends to update
     * 
    **/
    where?: SecurityDividendsWhereInput
  }


  /**
   * SecurityDividends upsert
   */
  export type SecurityDividendsUpsertArgs = {
    /**
     * Select specific fields to fetch from the SecurityDividends
     * 
    **/
    select?: SecurityDividendsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDividendsInclude | null
    /**
     * The filter to search for the SecurityDividends to update in case it exists.
     * 
    **/
    where: SecurityDividendsWhereUniqueInput
    /**
     * In case the SecurityDividends found by the `where` argument doesn't exist, create a new SecurityDividends with this data.
     * 
    **/
    create: XOR<SecurityDividendsCreateInput, SecurityDividendsUncheckedCreateInput>
    /**
     * In case the SecurityDividends was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SecurityDividendsUpdateInput, SecurityDividendsUncheckedUpdateInput>
  }


  /**
   * SecurityDividends delete
   */
  export type SecurityDividendsDeleteArgs = {
    /**
     * Select specific fields to fetch from the SecurityDividends
     * 
    **/
    select?: SecurityDividendsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDividendsInclude | null
    /**
     * Filter which SecurityDividends to delete.
     * 
    **/
    where: SecurityDividendsWhereUniqueInput
  }


  /**
   * SecurityDividends deleteMany
   */
  export type SecurityDividendsDeleteManyArgs = {
    /**
     * Filter which SecurityDividends to delete
     * 
    **/
    where?: SecurityDividendsWhereInput
  }


  /**
   * SecurityDividends: findUniqueOrThrow
   */
  export type SecurityDividendsFindUniqueOrThrowArgs = SecurityDividendsFindUniqueArgsBase
      

  /**
   * SecurityDividends: findFirstOrThrow
   */
  export type SecurityDividendsFindFirstOrThrowArgs = SecurityDividendsFindFirstArgsBase
      

  /**
   * SecurityDividends without action
   */
  export type SecurityDividendsArgs = {
    /**
     * Select specific fields to fetch from the SecurityDividends
     * 
    **/
    select?: SecurityDividendsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityDividendsInclude | null
  }



  /**
   * Model SecurityIndexTypes
   */


  export type AggregateSecurityIndexTypes = {
    _count: SecurityIndexTypesCountAggregateOutputType | null
    _avg: SecurityIndexTypesAvgAggregateOutputType | null
    _sum: SecurityIndexTypesSumAggregateOutputType | null
    _min: SecurityIndexTypesMinAggregateOutputType | null
    _max: SecurityIndexTypesMaxAggregateOutputType | null
  }

  export type SecurityIndexTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type SecurityIndexTypesSumAggregateOutputType = {
    id: number | null
  }

  export type SecurityIndexTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type SecurityIndexTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type SecurityIndexTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type SecurityIndexTypesAvgAggregateInputType = {
    id?: true
  }

  export type SecurityIndexTypesSumAggregateInputType = {
    id?: true
  }

  export type SecurityIndexTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SecurityIndexTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SecurityIndexTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type SecurityIndexTypesAggregateArgs = {
    /**
     * Filter which SecurityIndexTypes to aggregate.
     * 
    **/
    where?: SecurityIndexTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIndexTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityIndexTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SecurityIndexTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIndexTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIndexTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityIndexTypes
    **/
    _count?: true | SecurityIndexTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityIndexTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityIndexTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityIndexTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityIndexTypesMaxAggregateInputType
  }

  export type GetSecurityIndexTypesAggregateType<T extends SecurityIndexTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityIndexTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityIndexTypes[P]>
      : GetScalarType<T[P], AggregateSecurityIndexTypes[P]>
  }




  export type SecurityIndexTypesGroupByArgs = {
    where?: SecurityIndexTypesWhereInput
    orderBy?: Enumerable<SecurityIndexTypesOrderByWithAggregationInput>
    by: Array<SecurityIndexTypesScalarFieldEnum>
    having?: SecurityIndexTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityIndexTypesCountAggregateInputType | true
    _avg?: SecurityIndexTypesAvgAggregateInputType
    _sum?: SecurityIndexTypesSumAggregateInputType
    _min?: SecurityIndexTypesMinAggregateInputType
    _max?: SecurityIndexTypesMaxAggregateInputType
  }


  export type SecurityIndexTypesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: SecurityIndexTypesCountAggregateOutputType | null
    _avg: SecurityIndexTypesAvgAggregateOutputType | null
    _sum: SecurityIndexTypesSumAggregateOutputType | null
    _min: SecurityIndexTypesMinAggregateOutputType | null
    _max: SecurityIndexTypesMaxAggregateOutputType | null
  }

  type GetSecurityIndexTypesGroupByPayload<T extends SecurityIndexTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SecurityIndexTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityIndexTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityIndexTypesGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityIndexTypesGroupByOutputType[P]>
        }
      >
    >


  export type SecurityIndexTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type SecurityIndexTypesGetPayload<
    S extends boolean | null | undefined | SecurityIndexTypesArgs,
    U = keyof S
      > = S extends true
        ? SecurityIndexTypes
    : S extends undefined
    ? never
    : S extends SecurityIndexTypesArgs | SecurityIndexTypesFindManyArgs
    ?'include' extends U
    ? SecurityIndexTypes 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SecurityIndexTypes ? SecurityIndexTypes[P] : never
  } 
    : SecurityIndexTypes
  : SecurityIndexTypes


  type SecurityIndexTypesCountArgs = Merge<
    Omit<SecurityIndexTypesFindManyArgs, 'select' | 'include'> & {
      select?: SecurityIndexTypesCountAggregateInputType | true
    }
  >

  export interface SecurityIndexTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SecurityIndexTypes that matches the filter.
     * @param {SecurityIndexTypesFindUniqueArgs} args - Arguments to find a SecurityIndexTypes
     * @example
     * // Get one SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecurityIndexTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SecurityIndexTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SecurityIndexTypes'> extends True ? CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T>>> : CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes | null, null>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T> | null, null>>

    /**
     * Find the first SecurityIndexTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIndexTypesFindFirstArgs} args - Arguments to find a SecurityIndexTypes
     * @example
     * // Get one SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecurityIndexTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SecurityIndexTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SecurityIndexTypes'> extends True ? CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T>>> : CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes | null, null>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T> | null, null>>

    /**
     * Find zero or more SecurityIndexTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIndexTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.findMany()
     * 
     * // Get first 10 SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityIndexTypesWithIdOnly = await prisma.securityIndexTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecurityIndexTypesFindManyArgs>(
      args?: SelectSubset<T, SecurityIndexTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SecurityIndexTypes>>, PrismaPromise<Array<SecurityIndexTypesGetPayload<T>>>>

    /**
     * Create a SecurityIndexTypes.
     * @param {SecurityIndexTypesCreateArgs} args - Arguments to create a SecurityIndexTypes.
     * @example
     * // Create one SecurityIndexTypes
     * const SecurityIndexTypes = await prisma.securityIndexTypes.create({
     *   data: {
     *     // ... data to create a SecurityIndexTypes
     *   }
     * })
     * 
    **/
    create<T extends SecurityIndexTypesCreateArgs>(
      args: SelectSubset<T, SecurityIndexTypesCreateArgs>
    ): CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T>>>

    /**
     * Create many SecurityIndexTypes.
     *     @param {SecurityIndexTypesCreateManyArgs} args - Arguments to create many SecurityIndexTypes.
     *     @example
     *     // Create many SecurityIndexTypes
     *     const securityIndexTypes = await prisma.securityIndexTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecurityIndexTypesCreateManyArgs>(
      args?: SelectSubset<T, SecurityIndexTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SecurityIndexTypes.
     * @param {SecurityIndexTypesDeleteArgs} args - Arguments to delete one SecurityIndexTypes.
     * @example
     * // Delete one SecurityIndexTypes
     * const SecurityIndexTypes = await prisma.securityIndexTypes.delete({
     *   where: {
     *     // ... filter to delete one SecurityIndexTypes
     *   }
     * })
     * 
    **/
    delete<T extends SecurityIndexTypesDeleteArgs>(
      args: SelectSubset<T, SecurityIndexTypesDeleteArgs>
    ): CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T>>>

    /**
     * Update one SecurityIndexTypes.
     * @param {SecurityIndexTypesUpdateArgs} args - Arguments to update one SecurityIndexTypes.
     * @example
     * // Update one SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecurityIndexTypesUpdateArgs>(
      args: SelectSubset<T, SecurityIndexTypesUpdateArgs>
    ): CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T>>>

    /**
     * Delete zero or more SecurityIndexTypes.
     * @param {SecurityIndexTypesDeleteManyArgs} args - Arguments to filter SecurityIndexTypes to delete.
     * @example
     * // Delete a few SecurityIndexTypes
     * const { count } = await prisma.securityIndexTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecurityIndexTypesDeleteManyArgs>(
      args?: SelectSubset<T, SecurityIndexTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityIndexTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIndexTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecurityIndexTypesUpdateManyArgs>(
      args: SelectSubset<T, SecurityIndexTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityIndexTypes.
     * @param {SecurityIndexTypesUpsertArgs} args - Arguments to update or create a SecurityIndexTypes.
     * @example
     * // Update or create a SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.upsert({
     *   create: {
     *     // ... data to create a SecurityIndexTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityIndexTypes we want to update
     *   }
     * })
    **/
    upsert<T extends SecurityIndexTypesUpsertArgs>(
      args: SelectSubset<T, SecurityIndexTypesUpsertArgs>
    ): CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T>>>

    /**
     * Find one SecurityIndexTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SecurityIndexTypesFindUniqueOrThrowArgs} args - Arguments to find a SecurityIndexTypes
     * @example
     * // Get one SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecurityIndexTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SecurityIndexTypesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T>>>

    /**
     * Find the first SecurityIndexTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIndexTypesFindFirstOrThrowArgs} args - Arguments to find a SecurityIndexTypes
     * @example
     * // Get one SecurityIndexTypes
     * const securityIndexTypes = await prisma.securityIndexTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecurityIndexTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SecurityIndexTypesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityIndexTypesClient<SecurityIndexTypes>, Prisma__SecurityIndexTypesClient<SecurityIndexTypesGetPayload<T>>>

    /**
     * Count the number of SecurityIndexTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIndexTypesCountArgs} args - Arguments to filter SecurityIndexTypes to count.
     * @example
     * // Count the number of SecurityIndexTypes
     * const count = await prisma.securityIndexTypes.count({
     *   where: {
     *     // ... the filter for the SecurityIndexTypes we want to count
     *   }
     * })
    **/
    count<T extends SecurityIndexTypesCountArgs>(
      args?: Subset<T, SecurityIndexTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityIndexTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityIndexTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIndexTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityIndexTypesAggregateArgs>(args: Subset<T, SecurityIndexTypesAggregateArgs>): PrismaPromise<GetSecurityIndexTypesAggregateType<T>>

    /**
     * Group by SecurityIndexTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityIndexTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityIndexTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityIndexTypesGroupByArgs['orderBy'] }
        : { orderBy?: SecurityIndexTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityIndexTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityIndexTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityIndexTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SecurityIndexTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SecurityIndexTypes base type for findUnique actions
   */
  export type SecurityIndexTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityIndexTypes
     * 
    **/
    select?: SecurityIndexTypesSelect | null
    /**
     * Filter, which SecurityIndexTypes to fetch.
     * 
    **/
    where: SecurityIndexTypesWhereUniqueInput
  }

  /**
   * SecurityIndexTypes: findUnique
   */
  export interface SecurityIndexTypesFindUniqueArgs extends SecurityIndexTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityIndexTypes base type for findFirst actions
   */
  export type SecurityIndexTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityIndexTypes
     * 
    **/
    select?: SecurityIndexTypesSelect | null
    /**
     * Filter, which SecurityIndexTypes to fetch.
     * 
    **/
    where?: SecurityIndexTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIndexTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityIndexTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityIndexTypes.
     * 
    **/
    cursor?: SecurityIndexTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIndexTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIndexTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityIndexTypes.
     * 
    **/
    distinct?: Enumerable<SecurityIndexTypesScalarFieldEnum>
  }

  /**
   * SecurityIndexTypes: findFirst
   */
  export interface SecurityIndexTypesFindFirstArgs extends SecurityIndexTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityIndexTypes findMany
   */
  export type SecurityIndexTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the SecurityIndexTypes
     * 
    **/
    select?: SecurityIndexTypesSelect | null
    /**
     * Filter, which SecurityIndexTypes to fetch.
     * 
    **/
    where?: SecurityIndexTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityIndexTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityIndexTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityIndexTypes.
     * 
    **/
    cursor?: SecurityIndexTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityIndexTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityIndexTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SecurityIndexTypesScalarFieldEnum>
  }


  /**
   * SecurityIndexTypes create
   */
  export type SecurityIndexTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the SecurityIndexTypes
     * 
    **/
    select?: SecurityIndexTypesSelect | null
    /**
     * The data needed to create a SecurityIndexTypes.
     * 
    **/
    data: XOR<SecurityIndexTypesCreateInput, SecurityIndexTypesUncheckedCreateInput>
  }


  /**
   * SecurityIndexTypes createMany
   */
  export type SecurityIndexTypesCreateManyArgs = {
    /**
     * The data used to create many SecurityIndexTypes.
     * 
    **/
    data: Enumerable<SecurityIndexTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SecurityIndexTypes update
   */
  export type SecurityIndexTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the SecurityIndexTypes
     * 
    **/
    select?: SecurityIndexTypesSelect | null
    /**
     * The data needed to update a SecurityIndexTypes.
     * 
    **/
    data: XOR<SecurityIndexTypesUpdateInput, SecurityIndexTypesUncheckedUpdateInput>
    /**
     * Choose, which SecurityIndexTypes to update.
     * 
    **/
    where: SecurityIndexTypesWhereUniqueInput
  }


  /**
   * SecurityIndexTypes updateMany
   */
  export type SecurityIndexTypesUpdateManyArgs = {
    /**
     * The data used to update SecurityIndexTypes.
     * 
    **/
    data: XOR<SecurityIndexTypesUpdateManyMutationInput, SecurityIndexTypesUncheckedUpdateManyInput>
    /**
     * Filter which SecurityIndexTypes to update
     * 
    **/
    where?: SecurityIndexTypesWhereInput
  }


  /**
   * SecurityIndexTypes upsert
   */
  export type SecurityIndexTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the SecurityIndexTypes
     * 
    **/
    select?: SecurityIndexTypesSelect | null
    /**
     * The filter to search for the SecurityIndexTypes to update in case it exists.
     * 
    **/
    where: SecurityIndexTypesWhereUniqueInput
    /**
     * In case the SecurityIndexTypes found by the `where` argument doesn't exist, create a new SecurityIndexTypes with this data.
     * 
    **/
    create: XOR<SecurityIndexTypesCreateInput, SecurityIndexTypesUncheckedCreateInput>
    /**
     * In case the SecurityIndexTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SecurityIndexTypesUpdateInput, SecurityIndexTypesUncheckedUpdateInput>
  }


  /**
   * SecurityIndexTypes delete
   */
  export type SecurityIndexTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the SecurityIndexTypes
     * 
    **/
    select?: SecurityIndexTypesSelect | null
    /**
     * Filter which SecurityIndexTypes to delete.
     * 
    **/
    where: SecurityIndexTypesWhereUniqueInput
  }


  /**
   * SecurityIndexTypes deleteMany
   */
  export type SecurityIndexTypesDeleteManyArgs = {
    /**
     * Filter which SecurityIndexTypes to delete
     * 
    **/
    where?: SecurityIndexTypesWhereInput
  }


  /**
   * SecurityIndexTypes: findUniqueOrThrow
   */
  export type SecurityIndexTypesFindUniqueOrThrowArgs = SecurityIndexTypesFindUniqueArgsBase
      

  /**
   * SecurityIndexTypes: findFirstOrThrow
   */
  export type SecurityIndexTypesFindFirstOrThrowArgs = SecurityIndexTypesFindFirstArgsBase
      

  /**
   * SecurityIndexTypes without action
   */
  export type SecurityIndexTypesArgs = {
    /**
     * Select specific fields to fetch from the SecurityIndexTypes
     * 
    **/
    select?: SecurityIndexTypesSelect | null
  }



  /**
   * Model SecurityMinutely
   */


  export type AggregateSecurityMinutely = {
    _count: SecurityMinutelyCountAggregateOutputType | null
    _avg: SecurityMinutelyAvgAggregateOutputType | null
    _sum: SecurityMinutelySumAggregateOutputType | null
    _min: SecurityMinutelyMinAggregateOutputType | null
    _max: SecurityMinutelyMaxAggregateOutputType | null
  }

  export type SecurityMinutelyAvgAggregateOutputType = {
    securityId: number | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: number | null
    notional: Decimal | null
    numberOfTrades: number | null
    marketHigh: Decimal | null
    marketLow: Decimal | null
    marketAverage: Decimal | null
    marketVolume: number | null
    marketNotional: Decimal | null
    marketNumberOfTrades: number | null
    marketOpen: Decimal | null
    marketClose: Decimal | null
    changeOverTime: Decimal | null
    marketChangeOverTime: Decimal | null
  }

  export type SecurityMinutelySumAggregateOutputType = {
    securityId: number | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: bigint | null
    notional: Decimal | null
    numberOfTrades: bigint | null
    marketHigh: Decimal | null
    marketLow: Decimal | null
    marketAverage: Decimal | null
    marketVolume: bigint | null
    marketNotional: Decimal | null
    marketNumberOfTrades: bigint | null
    marketOpen: Decimal | null
    marketClose: Decimal | null
    changeOverTime: Decimal | null
    marketChangeOverTime: Decimal | null
  }

  export type SecurityMinutelyMinAggregateOutputType = {
    securityId: number | null
    calendarDate: Date | null
    minute: string | null
    label: string | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: bigint | null
    notional: Decimal | null
    numberOfTrades: bigint | null
    marketHigh: Decimal | null
    marketLow: Decimal | null
    marketAverage: Decimal | null
    marketVolume: bigint | null
    marketNotional: Decimal | null
    marketNumberOfTrades: bigint | null
    marketOpen: Decimal | null
    marketClose: Decimal | null
    changeOverTime: Decimal | null
    marketChangeOverTime: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    dateTime: Date | null
  }

  export type SecurityMinutelyMaxAggregateOutputType = {
    securityId: number | null
    calendarDate: Date | null
    minute: string | null
    label: string | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: bigint | null
    notional: Decimal | null
    numberOfTrades: bigint | null
    marketHigh: Decimal | null
    marketLow: Decimal | null
    marketAverage: Decimal | null
    marketVolume: bigint | null
    marketNotional: Decimal | null
    marketNumberOfTrades: bigint | null
    marketOpen: Decimal | null
    marketClose: Decimal | null
    changeOverTime: Decimal | null
    marketChangeOverTime: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    dateTime: Date | null
  }

  export type SecurityMinutelyCountAggregateOutputType = {
    securityId: number
    calendarDate: number
    minute: number
    label: number
    open: number
    close: number
    high: number
    low: number
    average: number
    volume: number
    notional: number
    numberOfTrades: number
    marketHigh: number
    marketLow: number
    marketAverage: number
    marketVolume: number
    marketNotional: number
    marketNumberOfTrades: number
    marketOpen: number
    marketClose: number
    changeOverTime: number
    marketChangeOverTime: number
    createdAt: number
    updatedAt: number
    dateTime: number
    _all: number
  }


  export type SecurityMinutelyAvgAggregateInputType = {
    securityId?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    marketHigh?: true
    marketLow?: true
    marketAverage?: true
    marketVolume?: true
    marketNotional?: true
    marketNumberOfTrades?: true
    marketOpen?: true
    marketClose?: true
    changeOverTime?: true
    marketChangeOverTime?: true
  }

  export type SecurityMinutelySumAggregateInputType = {
    securityId?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    marketHigh?: true
    marketLow?: true
    marketAverage?: true
    marketVolume?: true
    marketNotional?: true
    marketNumberOfTrades?: true
    marketOpen?: true
    marketClose?: true
    changeOverTime?: true
    marketChangeOverTime?: true
  }

  export type SecurityMinutelyMinAggregateInputType = {
    securityId?: true
    calendarDate?: true
    minute?: true
    label?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    marketHigh?: true
    marketLow?: true
    marketAverage?: true
    marketVolume?: true
    marketNotional?: true
    marketNumberOfTrades?: true
    marketOpen?: true
    marketClose?: true
    changeOverTime?: true
    marketChangeOverTime?: true
    createdAt?: true
    updatedAt?: true
    dateTime?: true
  }

  export type SecurityMinutelyMaxAggregateInputType = {
    securityId?: true
    calendarDate?: true
    minute?: true
    label?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    marketHigh?: true
    marketLow?: true
    marketAverage?: true
    marketVolume?: true
    marketNotional?: true
    marketNumberOfTrades?: true
    marketOpen?: true
    marketClose?: true
    changeOverTime?: true
    marketChangeOverTime?: true
    createdAt?: true
    updatedAt?: true
    dateTime?: true
  }

  export type SecurityMinutelyCountAggregateInputType = {
    securityId?: true
    calendarDate?: true
    minute?: true
    label?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    marketHigh?: true
    marketLow?: true
    marketAverage?: true
    marketVolume?: true
    marketNotional?: true
    marketNumberOfTrades?: true
    marketOpen?: true
    marketClose?: true
    changeOverTime?: true
    marketChangeOverTime?: true
    createdAt?: true
    updatedAt?: true
    dateTime?: true
    _all?: true
  }

  export type SecurityMinutelyAggregateArgs = {
    /**
     * Filter which SecurityMinutely to aggregate.
     * 
    **/
    where?: SecurityMinutelyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityMinutelies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityMinutelyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SecurityMinutelyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityMinutelies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityMinutelies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityMinutelies
    **/
    _count?: true | SecurityMinutelyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityMinutelyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityMinutelySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityMinutelyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityMinutelyMaxAggregateInputType
  }

  export type GetSecurityMinutelyAggregateType<T extends SecurityMinutelyAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityMinutely]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityMinutely[P]>
      : GetScalarType<T[P], AggregateSecurityMinutely[P]>
  }




  export type SecurityMinutelyGroupByArgs = {
    where?: SecurityMinutelyWhereInput
    orderBy?: Enumerable<SecurityMinutelyOrderByWithAggregationInput>
    by: Array<SecurityMinutelyScalarFieldEnum>
    having?: SecurityMinutelyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityMinutelyCountAggregateInputType | true
    _avg?: SecurityMinutelyAvgAggregateInputType
    _sum?: SecurityMinutelySumAggregateInputType
    _min?: SecurityMinutelyMinAggregateInputType
    _max?: SecurityMinutelyMaxAggregateInputType
  }


  export type SecurityMinutelyGroupByOutputType = {
    securityId: number
    calendarDate: Date
    minute: string | null
    label: string | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: bigint | null
    notional: Decimal | null
    numberOfTrades: bigint | null
    marketHigh: Decimal | null
    marketLow: Decimal | null
    marketAverage: Decimal | null
    marketVolume: bigint | null
    marketNotional: Decimal | null
    marketNumberOfTrades: bigint | null
    marketOpen: Decimal | null
    marketClose: Decimal | null
    changeOverTime: Decimal | null
    marketChangeOverTime: Decimal | null
    createdAt: Date
    updatedAt: Date | null
    dateTime: Date | null
    _count: SecurityMinutelyCountAggregateOutputType | null
    _avg: SecurityMinutelyAvgAggregateOutputType | null
    _sum: SecurityMinutelySumAggregateOutputType | null
    _min: SecurityMinutelyMinAggregateOutputType | null
    _max: SecurityMinutelyMaxAggregateOutputType | null
  }

  type GetSecurityMinutelyGroupByPayload<T extends SecurityMinutelyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SecurityMinutelyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityMinutelyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityMinutelyGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityMinutelyGroupByOutputType[P]>
        }
      >
    >


  export type SecurityMinutelySelect = {
    securityId?: boolean
    calendarDate?: boolean
    minute?: boolean
    label?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    average?: boolean
    volume?: boolean
    notional?: boolean
    numberOfTrades?: boolean
    marketHigh?: boolean
    marketLow?: boolean
    marketAverage?: boolean
    marketVolume?: boolean
    marketNotional?: boolean
    marketNumberOfTrades?: boolean
    marketOpen?: boolean
    marketClose?: boolean
    changeOverTime?: boolean
    marketChangeOverTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dateTime?: boolean
    Security?: boolean | SecuritiesArgs
  }

  export type SecurityMinutelyInclude = {
    Security?: boolean | SecuritiesArgs
  }

  export type SecurityMinutelyGetPayload<
    S extends boolean | null | undefined | SecurityMinutelyArgs,
    U = keyof S
      > = S extends true
        ? SecurityMinutely
    : S extends undefined
    ? never
    : S extends SecurityMinutelyArgs | SecurityMinutelyFindManyArgs
    ?'include' extends U
    ? SecurityMinutely  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SecurityMinutely ? SecurityMinutely[P] : never
  } 
    : SecurityMinutely
  : SecurityMinutely


  type SecurityMinutelyCountArgs = Merge<
    Omit<SecurityMinutelyFindManyArgs, 'select' | 'include'> & {
      select?: SecurityMinutelyCountAggregateInputType | true
    }
  >

  export interface SecurityMinutelyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SecurityMinutely that matches the filter.
     * @param {SecurityMinutelyFindUniqueArgs} args - Arguments to find a SecurityMinutely
     * @example
     * // Get one SecurityMinutely
     * const securityMinutely = await prisma.securityMinutely.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecurityMinutelyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SecurityMinutelyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SecurityMinutely'> extends True ? CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T>>> : CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely | null, null>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T> | null, null>>

    /**
     * Find the first SecurityMinutely that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityMinutelyFindFirstArgs} args - Arguments to find a SecurityMinutely
     * @example
     * // Get one SecurityMinutely
     * const securityMinutely = await prisma.securityMinutely.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecurityMinutelyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SecurityMinutelyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SecurityMinutely'> extends True ? CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T>>> : CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely | null, null>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T> | null, null>>

    /**
     * Find zero or more SecurityMinutelies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityMinutelyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityMinutelies
     * const securityMinutelies = await prisma.securityMinutely.findMany()
     * 
     * // Get first 10 SecurityMinutelies
     * const securityMinutelies = await prisma.securityMinutely.findMany({ take: 10 })
     * 
     * // Only select the `securityId`
     * const securityMinutelyWithSecurityIdOnly = await prisma.securityMinutely.findMany({ select: { securityId: true } })
     * 
    **/
    findMany<T extends SecurityMinutelyFindManyArgs>(
      args?: SelectSubset<T, SecurityMinutelyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SecurityMinutely>>, PrismaPromise<Array<SecurityMinutelyGetPayload<T>>>>

    /**
     * Create a SecurityMinutely.
     * @param {SecurityMinutelyCreateArgs} args - Arguments to create a SecurityMinutely.
     * @example
     * // Create one SecurityMinutely
     * const SecurityMinutely = await prisma.securityMinutely.create({
     *   data: {
     *     // ... data to create a SecurityMinutely
     *   }
     * })
     * 
    **/
    create<T extends SecurityMinutelyCreateArgs>(
      args: SelectSubset<T, SecurityMinutelyCreateArgs>
    ): CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T>>>

    /**
     * Create many SecurityMinutelies.
     *     @param {SecurityMinutelyCreateManyArgs} args - Arguments to create many SecurityMinutelies.
     *     @example
     *     // Create many SecurityMinutelies
     *     const securityMinutely = await prisma.securityMinutely.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecurityMinutelyCreateManyArgs>(
      args?: SelectSubset<T, SecurityMinutelyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SecurityMinutely.
     * @param {SecurityMinutelyDeleteArgs} args - Arguments to delete one SecurityMinutely.
     * @example
     * // Delete one SecurityMinutely
     * const SecurityMinutely = await prisma.securityMinutely.delete({
     *   where: {
     *     // ... filter to delete one SecurityMinutely
     *   }
     * })
     * 
    **/
    delete<T extends SecurityMinutelyDeleteArgs>(
      args: SelectSubset<T, SecurityMinutelyDeleteArgs>
    ): CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T>>>

    /**
     * Update one SecurityMinutely.
     * @param {SecurityMinutelyUpdateArgs} args - Arguments to update one SecurityMinutely.
     * @example
     * // Update one SecurityMinutely
     * const securityMinutely = await prisma.securityMinutely.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecurityMinutelyUpdateArgs>(
      args: SelectSubset<T, SecurityMinutelyUpdateArgs>
    ): CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T>>>

    /**
     * Delete zero or more SecurityMinutelies.
     * @param {SecurityMinutelyDeleteManyArgs} args - Arguments to filter SecurityMinutelies to delete.
     * @example
     * // Delete a few SecurityMinutelies
     * const { count } = await prisma.securityMinutely.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecurityMinutelyDeleteManyArgs>(
      args?: SelectSubset<T, SecurityMinutelyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityMinutelies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityMinutelyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityMinutelies
     * const securityMinutely = await prisma.securityMinutely.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecurityMinutelyUpdateManyArgs>(
      args: SelectSubset<T, SecurityMinutelyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityMinutely.
     * @param {SecurityMinutelyUpsertArgs} args - Arguments to update or create a SecurityMinutely.
     * @example
     * // Update or create a SecurityMinutely
     * const securityMinutely = await prisma.securityMinutely.upsert({
     *   create: {
     *     // ... data to create a SecurityMinutely
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityMinutely we want to update
     *   }
     * })
    **/
    upsert<T extends SecurityMinutelyUpsertArgs>(
      args: SelectSubset<T, SecurityMinutelyUpsertArgs>
    ): CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T>>>

    /**
     * Find one SecurityMinutely that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SecurityMinutelyFindUniqueOrThrowArgs} args - Arguments to find a SecurityMinutely
     * @example
     * // Get one SecurityMinutely
     * const securityMinutely = await prisma.securityMinutely.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecurityMinutelyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SecurityMinutelyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T>>>

    /**
     * Find the first SecurityMinutely that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityMinutelyFindFirstOrThrowArgs} args - Arguments to find a SecurityMinutely
     * @example
     * // Get one SecurityMinutely
     * const securityMinutely = await prisma.securityMinutely.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecurityMinutelyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SecurityMinutelyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityMinutelyClient<SecurityMinutely>, Prisma__SecurityMinutelyClient<SecurityMinutelyGetPayload<T>>>

    /**
     * Count the number of SecurityMinutelies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityMinutelyCountArgs} args - Arguments to filter SecurityMinutelies to count.
     * @example
     * // Count the number of SecurityMinutelies
     * const count = await prisma.securityMinutely.count({
     *   where: {
     *     // ... the filter for the SecurityMinutelies we want to count
     *   }
     * })
    **/
    count<T extends SecurityMinutelyCountArgs>(
      args?: Subset<T, SecurityMinutelyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityMinutelyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityMinutely.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityMinutelyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityMinutelyAggregateArgs>(args: Subset<T, SecurityMinutelyAggregateArgs>): PrismaPromise<GetSecurityMinutelyAggregateType<T>>

    /**
     * Group by SecurityMinutely.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityMinutelyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityMinutelyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityMinutelyGroupByArgs['orderBy'] }
        : { orderBy?: SecurityMinutelyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityMinutelyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityMinutelyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityMinutely.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SecurityMinutelyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Security<T extends SecuritiesArgs = {}>(args?: Subset<T, SecuritiesArgs>): CheckSelect<T, Prisma__SecuritiesClient<Securities | Null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SecurityMinutely base type for findUnique actions
   */
  export type SecurityMinutelyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityMinutely
     * 
    **/
    select?: SecurityMinutelySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityMinutelyInclude | null
    /**
     * Filter, which SecurityMinutely to fetch.
     * 
    **/
    where: SecurityMinutelyWhereUniqueInput
  }

  /**
   * SecurityMinutely: findUnique
   */
  export interface SecurityMinutelyFindUniqueArgs extends SecurityMinutelyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityMinutely base type for findFirst actions
   */
  export type SecurityMinutelyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityMinutely
     * 
    **/
    select?: SecurityMinutelySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityMinutelyInclude | null
    /**
     * Filter, which SecurityMinutely to fetch.
     * 
    **/
    where?: SecurityMinutelyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityMinutelies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityMinutelyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityMinutelies.
     * 
    **/
    cursor?: SecurityMinutelyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityMinutelies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityMinutelies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityMinutelies.
     * 
    **/
    distinct?: Enumerable<SecurityMinutelyScalarFieldEnum>
  }

  /**
   * SecurityMinutely: findFirst
   */
  export interface SecurityMinutelyFindFirstArgs extends SecurityMinutelyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityMinutely findMany
   */
  export type SecurityMinutelyFindManyArgs = {
    /**
     * Select specific fields to fetch from the SecurityMinutely
     * 
    **/
    select?: SecurityMinutelySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityMinutelyInclude | null
    /**
     * Filter, which SecurityMinutelies to fetch.
     * 
    **/
    where?: SecurityMinutelyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityMinutelies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityMinutelyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityMinutelies.
     * 
    **/
    cursor?: SecurityMinutelyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityMinutelies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityMinutelies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SecurityMinutelyScalarFieldEnum>
  }


  /**
   * SecurityMinutely create
   */
  export type SecurityMinutelyCreateArgs = {
    /**
     * Select specific fields to fetch from the SecurityMinutely
     * 
    **/
    select?: SecurityMinutelySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityMinutelyInclude | null
    /**
     * The data needed to create a SecurityMinutely.
     * 
    **/
    data: XOR<SecurityMinutelyCreateInput, SecurityMinutelyUncheckedCreateInput>
  }


  /**
   * SecurityMinutely createMany
   */
  export type SecurityMinutelyCreateManyArgs = {
    /**
     * The data used to create many SecurityMinutelies.
     * 
    **/
    data: Enumerable<SecurityMinutelyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SecurityMinutely update
   */
  export type SecurityMinutelyUpdateArgs = {
    /**
     * Select specific fields to fetch from the SecurityMinutely
     * 
    **/
    select?: SecurityMinutelySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityMinutelyInclude | null
    /**
     * The data needed to update a SecurityMinutely.
     * 
    **/
    data: XOR<SecurityMinutelyUpdateInput, SecurityMinutelyUncheckedUpdateInput>
    /**
     * Choose, which SecurityMinutely to update.
     * 
    **/
    where: SecurityMinutelyWhereUniqueInput
  }


  /**
   * SecurityMinutely updateMany
   */
  export type SecurityMinutelyUpdateManyArgs = {
    /**
     * The data used to update SecurityMinutelies.
     * 
    **/
    data: XOR<SecurityMinutelyUpdateManyMutationInput, SecurityMinutelyUncheckedUpdateManyInput>
    /**
     * Filter which SecurityMinutelies to update
     * 
    **/
    where?: SecurityMinutelyWhereInput
  }


  /**
   * SecurityMinutely upsert
   */
  export type SecurityMinutelyUpsertArgs = {
    /**
     * Select specific fields to fetch from the SecurityMinutely
     * 
    **/
    select?: SecurityMinutelySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityMinutelyInclude | null
    /**
     * The filter to search for the SecurityMinutely to update in case it exists.
     * 
    **/
    where: SecurityMinutelyWhereUniqueInput
    /**
     * In case the SecurityMinutely found by the `where` argument doesn't exist, create a new SecurityMinutely with this data.
     * 
    **/
    create: XOR<SecurityMinutelyCreateInput, SecurityMinutelyUncheckedCreateInput>
    /**
     * In case the SecurityMinutely was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SecurityMinutelyUpdateInput, SecurityMinutelyUncheckedUpdateInput>
  }


  /**
   * SecurityMinutely delete
   */
  export type SecurityMinutelyDeleteArgs = {
    /**
     * Select specific fields to fetch from the SecurityMinutely
     * 
    **/
    select?: SecurityMinutelySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityMinutelyInclude | null
    /**
     * Filter which SecurityMinutely to delete.
     * 
    **/
    where: SecurityMinutelyWhereUniqueInput
  }


  /**
   * SecurityMinutely deleteMany
   */
  export type SecurityMinutelyDeleteManyArgs = {
    /**
     * Filter which SecurityMinutelies to delete
     * 
    **/
    where?: SecurityMinutelyWhereInput
  }


  /**
   * SecurityMinutely: findUniqueOrThrow
   */
  export type SecurityMinutelyFindUniqueOrThrowArgs = SecurityMinutelyFindUniqueArgsBase
      

  /**
   * SecurityMinutely: findFirstOrThrow
   */
  export type SecurityMinutelyFindFirstOrThrowArgs = SecurityMinutelyFindFirstArgsBase
      

  /**
   * SecurityMinutely without action
   */
  export type SecurityMinutelyArgs = {
    /**
     * Select specific fields to fetch from the SecurityMinutely
     * 
    **/
    select?: SecurityMinutelySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecurityMinutelyInclude | null
  }



  /**
   * Model SecuritySecondly
   */


  export type AggregateSecuritySecondly = {
    _count: SecuritySecondlyCountAggregateOutputType | null
    _avg: SecuritySecondlyAvgAggregateOutputType | null
    _sum: SecuritySecondlySumAggregateOutputType | null
    _min: SecuritySecondlyMinAggregateOutputType | null
    _max: SecuritySecondlyMaxAggregateOutputType | null
  }

  export type SecuritySecondlyAvgAggregateOutputType = {
    securityId: number | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: number | null
    notional: Decimal | null
    numberOfTrades: number | null
    changeOverTime: Decimal | null
  }

  export type SecuritySecondlySumAggregateOutputType = {
    securityId: number | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: bigint | null
    notional: Decimal | null
    numberOfTrades: bigint | null
    changeOverTime: Decimal | null
  }

  export type SecuritySecondlyMinAggregateOutputType = {
    calendarDate: Date | null
    securityId: number | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: bigint | null
    notional: Decimal | null
    numberOfTrades: bigint | null
    changeOverTime: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecuritySecondlyMaxAggregateOutputType = {
    calendarDate: Date | null
    securityId: number | null
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: bigint | null
    notional: Decimal | null
    numberOfTrades: bigint | null
    changeOverTime: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SecuritySecondlyCountAggregateOutputType = {
    calendarDate: number
    securityId: number
    open: number
    close: number
    high: number
    low: number
    average: number
    volume: number
    notional: number
    numberOfTrades: number
    changeOverTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SecuritySecondlyAvgAggregateInputType = {
    securityId?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    changeOverTime?: true
  }

  export type SecuritySecondlySumAggregateInputType = {
    securityId?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    changeOverTime?: true
  }

  export type SecuritySecondlyMinAggregateInputType = {
    calendarDate?: true
    securityId?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    changeOverTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecuritySecondlyMaxAggregateInputType = {
    calendarDate?: true
    securityId?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    changeOverTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SecuritySecondlyCountAggregateInputType = {
    calendarDate?: true
    securityId?: true
    open?: true
    close?: true
    high?: true
    low?: true
    average?: true
    volume?: true
    notional?: true
    numberOfTrades?: true
    changeOverTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SecuritySecondlyAggregateArgs = {
    /**
     * Filter which SecuritySecondly to aggregate.
     * 
    **/
    where?: SecuritySecondlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySecondlies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritySecondlyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SecuritySecondlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySecondlies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySecondlies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecuritySecondlies
    **/
    _count?: true | SecuritySecondlyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecuritySecondlyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecuritySecondlySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecuritySecondlyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecuritySecondlyMaxAggregateInputType
  }

  export type GetSecuritySecondlyAggregateType<T extends SecuritySecondlyAggregateArgs> = {
        [P in keyof T & keyof AggregateSecuritySecondly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecuritySecondly[P]>
      : GetScalarType<T[P], AggregateSecuritySecondly[P]>
  }




  export type SecuritySecondlyGroupByArgs = {
    where?: SecuritySecondlyWhereInput
    orderBy?: Enumerable<SecuritySecondlyOrderByWithAggregationInput>
    by: Array<SecuritySecondlyScalarFieldEnum>
    having?: SecuritySecondlyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecuritySecondlyCountAggregateInputType | true
    _avg?: SecuritySecondlyAvgAggregateInputType
    _sum?: SecuritySecondlySumAggregateInputType
    _min?: SecuritySecondlyMinAggregateInputType
    _max?: SecuritySecondlyMaxAggregateInputType
  }


  export type SecuritySecondlyGroupByOutputType = {
    calendarDate: Date
    securityId: number
    open: Decimal | null
    close: Decimal | null
    high: Decimal | null
    low: Decimal | null
    average: Decimal | null
    volume: bigint | null
    notional: Decimal | null
    numberOfTrades: bigint | null
    changeOverTime: Decimal | null
    createdAt: Date
    updatedAt: Date | null
    _count: SecuritySecondlyCountAggregateOutputType | null
    _avg: SecuritySecondlyAvgAggregateOutputType | null
    _sum: SecuritySecondlySumAggregateOutputType | null
    _min: SecuritySecondlyMinAggregateOutputType | null
    _max: SecuritySecondlyMaxAggregateOutputType | null
  }

  type GetSecuritySecondlyGroupByPayload<T extends SecuritySecondlyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SecuritySecondlyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecuritySecondlyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecuritySecondlyGroupByOutputType[P]>
            : GetScalarType<T[P], SecuritySecondlyGroupByOutputType[P]>
        }
      >
    >


  export type SecuritySecondlySelect = {
    calendarDate?: boolean
    securityId?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    average?: boolean
    volume?: boolean
    notional?: boolean
    numberOfTrades?: boolean
    changeOverTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Security?: boolean | SecuritiesArgs
  }

  export type SecuritySecondlyInclude = {
    Security?: boolean | SecuritiesArgs
  }

  export type SecuritySecondlyGetPayload<
    S extends boolean | null | undefined | SecuritySecondlyArgs,
    U = keyof S
      > = S extends true
        ? SecuritySecondly
    : S extends undefined
    ? never
    : S extends SecuritySecondlyArgs | SecuritySecondlyFindManyArgs
    ?'include' extends U
    ? SecuritySecondly  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SecuritySecondly ? SecuritySecondly[P] : never
  } 
    : SecuritySecondly
  : SecuritySecondly


  type SecuritySecondlyCountArgs = Merge<
    Omit<SecuritySecondlyFindManyArgs, 'select' | 'include'> & {
      select?: SecuritySecondlyCountAggregateInputType | true
    }
  >

  export interface SecuritySecondlyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SecuritySecondly that matches the filter.
     * @param {SecuritySecondlyFindUniqueArgs} args - Arguments to find a SecuritySecondly
     * @example
     * // Get one SecuritySecondly
     * const securitySecondly = await prisma.securitySecondly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecuritySecondlyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SecuritySecondlyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SecuritySecondly'> extends True ? CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T>>> : CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly | null, null>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T> | null, null>>

    /**
     * Find the first SecuritySecondly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySecondlyFindFirstArgs} args - Arguments to find a SecuritySecondly
     * @example
     * // Get one SecuritySecondly
     * const securitySecondly = await prisma.securitySecondly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecuritySecondlyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SecuritySecondlyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SecuritySecondly'> extends True ? CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T>>> : CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly | null, null>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T> | null, null>>

    /**
     * Find zero or more SecuritySecondlies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySecondlyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecuritySecondlies
     * const securitySecondlies = await prisma.securitySecondly.findMany()
     * 
     * // Get first 10 SecuritySecondlies
     * const securitySecondlies = await prisma.securitySecondly.findMany({ take: 10 })
     * 
     * // Only select the `calendarDate`
     * const securitySecondlyWithCalendarDateOnly = await prisma.securitySecondly.findMany({ select: { calendarDate: true } })
     * 
    **/
    findMany<T extends SecuritySecondlyFindManyArgs>(
      args?: SelectSubset<T, SecuritySecondlyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SecuritySecondly>>, PrismaPromise<Array<SecuritySecondlyGetPayload<T>>>>

    /**
     * Create a SecuritySecondly.
     * @param {SecuritySecondlyCreateArgs} args - Arguments to create a SecuritySecondly.
     * @example
     * // Create one SecuritySecondly
     * const SecuritySecondly = await prisma.securitySecondly.create({
     *   data: {
     *     // ... data to create a SecuritySecondly
     *   }
     * })
     * 
    **/
    create<T extends SecuritySecondlyCreateArgs>(
      args: SelectSubset<T, SecuritySecondlyCreateArgs>
    ): CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T>>>

    /**
     * Create many SecuritySecondlies.
     *     @param {SecuritySecondlyCreateManyArgs} args - Arguments to create many SecuritySecondlies.
     *     @example
     *     // Create many SecuritySecondlies
     *     const securitySecondly = await prisma.securitySecondly.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecuritySecondlyCreateManyArgs>(
      args?: SelectSubset<T, SecuritySecondlyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SecuritySecondly.
     * @param {SecuritySecondlyDeleteArgs} args - Arguments to delete one SecuritySecondly.
     * @example
     * // Delete one SecuritySecondly
     * const SecuritySecondly = await prisma.securitySecondly.delete({
     *   where: {
     *     // ... filter to delete one SecuritySecondly
     *   }
     * })
     * 
    **/
    delete<T extends SecuritySecondlyDeleteArgs>(
      args: SelectSubset<T, SecuritySecondlyDeleteArgs>
    ): CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T>>>

    /**
     * Update one SecuritySecondly.
     * @param {SecuritySecondlyUpdateArgs} args - Arguments to update one SecuritySecondly.
     * @example
     * // Update one SecuritySecondly
     * const securitySecondly = await prisma.securitySecondly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecuritySecondlyUpdateArgs>(
      args: SelectSubset<T, SecuritySecondlyUpdateArgs>
    ): CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T>>>

    /**
     * Delete zero or more SecuritySecondlies.
     * @param {SecuritySecondlyDeleteManyArgs} args - Arguments to filter SecuritySecondlies to delete.
     * @example
     * // Delete a few SecuritySecondlies
     * const { count } = await prisma.securitySecondly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecuritySecondlyDeleteManyArgs>(
      args?: SelectSubset<T, SecuritySecondlyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecuritySecondlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySecondlyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecuritySecondlies
     * const securitySecondly = await prisma.securitySecondly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecuritySecondlyUpdateManyArgs>(
      args: SelectSubset<T, SecuritySecondlyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SecuritySecondly.
     * @param {SecuritySecondlyUpsertArgs} args - Arguments to update or create a SecuritySecondly.
     * @example
     * // Update or create a SecuritySecondly
     * const securitySecondly = await prisma.securitySecondly.upsert({
     *   create: {
     *     // ... data to create a SecuritySecondly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecuritySecondly we want to update
     *   }
     * })
    **/
    upsert<T extends SecuritySecondlyUpsertArgs>(
      args: SelectSubset<T, SecuritySecondlyUpsertArgs>
    ): CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T>>>

    /**
     * Find one SecuritySecondly that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SecuritySecondlyFindUniqueOrThrowArgs} args - Arguments to find a SecuritySecondly
     * @example
     * // Get one SecuritySecondly
     * const securitySecondly = await prisma.securitySecondly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecuritySecondlyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SecuritySecondlyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T>>>

    /**
     * Find the first SecuritySecondly that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySecondlyFindFirstOrThrowArgs} args - Arguments to find a SecuritySecondly
     * @example
     * // Get one SecuritySecondly
     * const securitySecondly = await prisma.securitySecondly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecuritySecondlyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SecuritySecondlyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SecuritySecondlyClient<SecuritySecondly>, Prisma__SecuritySecondlyClient<SecuritySecondlyGetPayload<T>>>

    /**
     * Count the number of SecuritySecondlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySecondlyCountArgs} args - Arguments to filter SecuritySecondlies to count.
     * @example
     * // Count the number of SecuritySecondlies
     * const count = await prisma.securitySecondly.count({
     *   where: {
     *     // ... the filter for the SecuritySecondlies we want to count
     *   }
     * })
    **/
    count<T extends SecuritySecondlyCountArgs>(
      args?: Subset<T, SecuritySecondlyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecuritySecondlyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecuritySecondly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySecondlyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecuritySecondlyAggregateArgs>(args: Subset<T, SecuritySecondlyAggregateArgs>): PrismaPromise<GetSecuritySecondlyAggregateType<T>>

    /**
     * Group by SecuritySecondly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySecondlyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecuritySecondlyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecuritySecondlyGroupByArgs['orderBy'] }
        : { orderBy?: SecuritySecondlyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecuritySecondlyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecuritySecondlyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SecuritySecondly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SecuritySecondlyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Security<T extends SecuritiesArgs = {}>(args?: Subset<T, SecuritiesArgs>): CheckSelect<T, Prisma__SecuritiesClient<Securities | Null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SecuritySecondly base type for findUnique actions
   */
  export type SecuritySecondlyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SecuritySecondly
     * 
    **/
    select?: SecuritySecondlySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySecondlyInclude | null
    /**
     * Filter, which SecuritySecondly to fetch.
     * 
    **/
    where: SecuritySecondlyWhereUniqueInput
  }

  /**
   * SecuritySecondly: findUnique
   */
  export interface SecuritySecondlyFindUniqueArgs extends SecuritySecondlyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecuritySecondly base type for findFirst actions
   */
  export type SecuritySecondlyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SecuritySecondly
     * 
    **/
    select?: SecuritySecondlySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySecondlyInclude | null
    /**
     * Filter, which SecuritySecondly to fetch.
     * 
    **/
    where?: SecuritySecondlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySecondlies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritySecondlyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecuritySecondlies.
     * 
    **/
    cursor?: SecuritySecondlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySecondlies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySecondlies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecuritySecondlies.
     * 
    **/
    distinct?: Enumerable<SecuritySecondlyScalarFieldEnum>
  }

  /**
   * SecuritySecondly: findFirst
   */
  export interface SecuritySecondlyFindFirstArgs extends SecuritySecondlyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecuritySecondly findMany
   */
  export type SecuritySecondlyFindManyArgs = {
    /**
     * Select specific fields to fetch from the SecuritySecondly
     * 
    **/
    select?: SecuritySecondlySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySecondlyInclude | null
    /**
     * Filter, which SecuritySecondlies to fetch.
     * 
    **/
    where?: SecuritySecondlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySecondlies to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritySecondlyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecuritySecondlies.
     * 
    **/
    cursor?: SecuritySecondlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySecondlies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySecondlies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SecuritySecondlyScalarFieldEnum>
  }


  /**
   * SecuritySecondly create
   */
  export type SecuritySecondlyCreateArgs = {
    /**
     * Select specific fields to fetch from the SecuritySecondly
     * 
    **/
    select?: SecuritySecondlySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySecondlyInclude | null
    /**
     * The data needed to create a SecuritySecondly.
     * 
    **/
    data: XOR<SecuritySecondlyCreateInput, SecuritySecondlyUncheckedCreateInput>
  }


  /**
   * SecuritySecondly createMany
   */
  export type SecuritySecondlyCreateManyArgs = {
    /**
     * The data used to create many SecuritySecondlies.
     * 
    **/
    data: Enumerable<SecuritySecondlyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SecuritySecondly update
   */
  export type SecuritySecondlyUpdateArgs = {
    /**
     * Select specific fields to fetch from the SecuritySecondly
     * 
    **/
    select?: SecuritySecondlySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySecondlyInclude | null
    /**
     * The data needed to update a SecuritySecondly.
     * 
    **/
    data: XOR<SecuritySecondlyUpdateInput, SecuritySecondlyUncheckedUpdateInput>
    /**
     * Choose, which SecuritySecondly to update.
     * 
    **/
    where: SecuritySecondlyWhereUniqueInput
  }


  /**
   * SecuritySecondly updateMany
   */
  export type SecuritySecondlyUpdateManyArgs = {
    /**
     * The data used to update SecuritySecondlies.
     * 
    **/
    data: XOR<SecuritySecondlyUpdateManyMutationInput, SecuritySecondlyUncheckedUpdateManyInput>
    /**
     * Filter which SecuritySecondlies to update
     * 
    **/
    where?: SecuritySecondlyWhereInput
  }


  /**
   * SecuritySecondly upsert
   */
  export type SecuritySecondlyUpsertArgs = {
    /**
     * Select specific fields to fetch from the SecuritySecondly
     * 
    **/
    select?: SecuritySecondlySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySecondlyInclude | null
    /**
     * The filter to search for the SecuritySecondly to update in case it exists.
     * 
    **/
    where: SecuritySecondlyWhereUniqueInput
    /**
     * In case the SecuritySecondly found by the `where` argument doesn't exist, create a new SecuritySecondly with this data.
     * 
    **/
    create: XOR<SecuritySecondlyCreateInput, SecuritySecondlyUncheckedCreateInput>
    /**
     * In case the SecuritySecondly was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SecuritySecondlyUpdateInput, SecuritySecondlyUncheckedUpdateInput>
  }


  /**
   * SecuritySecondly delete
   */
  export type SecuritySecondlyDeleteArgs = {
    /**
     * Select specific fields to fetch from the SecuritySecondly
     * 
    **/
    select?: SecuritySecondlySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySecondlyInclude | null
    /**
     * Filter which SecuritySecondly to delete.
     * 
    **/
    where: SecuritySecondlyWhereUniqueInput
  }


  /**
   * SecuritySecondly deleteMany
   */
  export type SecuritySecondlyDeleteManyArgs = {
    /**
     * Filter which SecuritySecondlies to delete
     * 
    **/
    where?: SecuritySecondlyWhereInput
  }


  /**
   * SecuritySecondly: findUniqueOrThrow
   */
  export type SecuritySecondlyFindUniqueOrThrowArgs = SecuritySecondlyFindUniqueArgsBase
      

  /**
   * SecuritySecondly: findFirstOrThrow
   */
  export type SecuritySecondlyFindFirstOrThrowArgs = SecuritySecondlyFindFirstArgsBase
      

  /**
   * SecuritySecondly without action
   */
  export type SecuritySecondlyArgs = {
    /**
     * Select specific fields to fetch from the SecuritySecondly
     * 
    **/
    select?: SecuritySecondlySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySecondlyInclude | null
  }



  /**
   * Model SecuritySplits
   */


  export type AggregateSecuritySplits = {
    _count: SecuritySplitsCountAggregateOutputType | null
    _avg: SecuritySplitsAvgAggregateOutputType | null
    _sum: SecuritySplitsSumAggregateOutputType | null
    _min: SecuritySplitsMinAggregateOutputType | null
    _max: SecuritySplitsMaxAggregateOutputType | null
  }

  export type SecuritySplitsAvgAggregateOutputType = {
    id: number | null
    securityId: number | null
    ratio: Decimal | null
    toFactor: number | null
    fromFactor: number | null
  }

  export type SecuritySplitsSumAggregateOutputType = {
    id: number | null
    securityId: number | null
    ratio: Decimal | null
    toFactor: number | null
    fromFactor: number | null
  }

  export type SecuritySplitsMinAggregateOutputType = {
    id: number | null
    securityId: number | null
    paymentDate: Date | null
    ratio: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    exercisedDate: Date | null
    declaredDate: Date | null
    toFactor: number | null
    fromFactor: number | null
    description: string | null
  }

  export type SecuritySplitsMaxAggregateOutputType = {
    id: number | null
    securityId: number | null
    paymentDate: Date | null
    ratio: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    exercisedDate: Date | null
    declaredDate: Date | null
    toFactor: number | null
    fromFactor: number | null
    description: string | null
  }

  export type SecuritySplitsCountAggregateOutputType = {
    id: number
    securityId: number
    paymentDate: number
    ratio: number
    createdAt: number
    updatedAt: number
    exercisedDate: number
    declaredDate: number
    toFactor: number
    fromFactor: number
    description: number
    _all: number
  }


  export type SecuritySplitsAvgAggregateInputType = {
    id?: true
    securityId?: true
    ratio?: true
    toFactor?: true
    fromFactor?: true
  }

  export type SecuritySplitsSumAggregateInputType = {
    id?: true
    securityId?: true
    ratio?: true
    toFactor?: true
    fromFactor?: true
  }

  export type SecuritySplitsMinAggregateInputType = {
    id?: true
    securityId?: true
    paymentDate?: true
    ratio?: true
    createdAt?: true
    updatedAt?: true
    exercisedDate?: true
    declaredDate?: true
    toFactor?: true
    fromFactor?: true
    description?: true
  }

  export type SecuritySplitsMaxAggregateInputType = {
    id?: true
    securityId?: true
    paymentDate?: true
    ratio?: true
    createdAt?: true
    updatedAt?: true
    exercisedDate?: true
    declaredDate?: true
    toFactor?: true
    fromFactor?: true
    description?: true
  }

  export type SecuritySplitsCountAggregateInputType = {
    id?: true
    securityId?: true
    paymentDate?: true
    ratio?: true
    createdAt?: true
    updatedAt?: true
    exercisedDate?: true
    declaredDate?: true
    toFactor?: true
    fromFactor?: true
    description?: true
    _all?: true
  }

  export type SecuritySplitsAggregateArgs = {
    /**
     * Filter which SecuritySplits to aggregate.
     * 
    **/
    where?: SecuritySplitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySplits to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritySplitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SecuritySplitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySplits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySplits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecuritySplits
    **/
    _count?: true | SecuritySplitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecuritySplitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecuritySplitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecuritySplitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecuritySplitsMaxAggregateInputType
  }

  export type GetSecuritySplitsAggregateType<T extends SecuritySplitsAggregateArgs> = {
        [P in keyof T & keyof AggregateSecuritySplits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecuritySplits[P]>
      : GetScalarType<T[P], AggregateSecuritySplits[P]>
  }




  export type SecuritySplitsGroupByArgs = {
    where?: SecuritySplitsWhereInput
    orderBy?: Enumerable<SecuritySplitsOrderByWithAggregationInput>
    by: Array<SecuritySplitsScalarFieldEnum>
    having?: SecuritySplitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecuritySplitsCountAggregateInputType | true
    _avg?: SecuritySplitsAvgAggregateInputType
    _sum?: SecuritySplitsSumAggregateInputType
    _min?: SecuritySplitsMinAggregateInputType
    _max?: SecuritySplitsMaxAggregateInputType
  }


  export type SecuritySplitsGroupByOutputType = {
    id: number
    securityId: number
    paymentDate: Date
    ratio: Decimal
    createdAt: Date
    updatedAt: Date | null
    exercisedDate: Date
    declaredDate: Date
    toFactor: number
    fromFactor: number
    description: string | null
    _count: SecuritySplitsCountAggregateOutputType | null
    _avg: SecuritySplitsAvgAggregateOutputType | null
    _sum: SecuritySplitsSumAggregateOutputType | null
    _min: SecuritySplitsMinAggregateOutputType | null
    _max: SecuritySplitsMaxAggregateOutputType | null
  }

  type GetSecuritySplitsGroupByPayload<T extends SecuritySplitsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SecuritySplitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecuritySplitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecuritySplitsGroupByOutputType[P]>
            : GetScalarType<T[P], SecuritySplitsGroupByOutputType[P]>
        }
      >
    >


  export type SecuritySplitsSelect = {
    id?: boolean
    securityId?: boolean
    paymentDate?: boolean
    ratio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exercisedDate?: boolean
    declaredDate?: boolean
    toFactor?: boolean
    fromFactor?: boolean
    description?: boolean
    Security?: boolean | SecuritiesArgs
  }

  export type SecuritySplitsInclude = {
    Security?: boolean | SecuritiesArgs
  }

  export type SecuritySplitsGetPayload<
    S extends boolean | null | undefined | SecuritySplitsArgs,
    U = keyof S
      > = S extends true
        ? SecuritySplits
    : S extends undefined
    ? never
    : S extends SecuritySplitsArgs | SecuritySplitsFindManyArgs
    ?'include' extends U
    ? SecuritySplits  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof SecuritySplits ? SecuritySplits[P] : never
  } 
    : SecuritySplits
  : SecuritySplits


  type SecuritySplitsCountArgs = Merge<
    Omit<SecuritySplitsFindManyArgs, 'select' | 'include'> & {
      select?: SecuritySplitsCountAggregateInputType | true
    }
  >

  export interface SecuritySplitsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SecuritySplits that matches the filter.
     * @param {SecuritySplitsFindUniqueArgs} args - Arguments to find a SecuritySplits
     * @example
     * // Get one SecuritySplits
     * const securitySplits = await prisma.securitySplits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecuritySplitsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SecuritySplitsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SecuritySplits'> extends True ? CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T>>> : CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits | null, null>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T> | null, null>>

    /**
     * Find the first SecuritySplits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySplitsFindFirstArgs} args - Arguments to find a SecuritySplits
     * @example
     * // Get one SecuritySplits
     * const securitySplits = await prisma.securitySplits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecuritySplitsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SecuritySplitsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SecuritySplits'> extends True ? CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T>>> : CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits | null, null>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T> | null, null>>

    /**
     * Find zero or more SecuritySplits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySplitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecuritySplits
     * const securitySplits = await prisma.securitySplits.findMany()
     * 
     * // Get first 10 SecuritySplits
     * const securitySplits = await prisma.securitySplits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securitySplitsWithIdOnly = await prisma.securitySplits.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecuritySplitsFindManyArgs>(
      args?: SelectSubset<T, SecuritySplitsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SecuritySplits>>, PrismaPromise<Array<SecuritySplitsGetPayload<T>>>>

    /**
     * Create a SecuritySplits.
     * @param {SecuritySplitsCreateArgs} args - Arguments to create a SecuritySplits.
     * @example
     * // Create one SecuritySplits
     * const SecuritySplits = await prisma.securitySplits.create({
     *   data: {
     *     // ... data to create a SecuritySplits
     *   }
     * })
     * 
    **/
    create<T extends SecuritySplitsCreateArgs>(
      args: SelectSubset<T, SecuritySplitsCreateArgs>
    ): CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T>>>

    /**
     * Create many SecuritySplits.
     *     @param {SecuritySplitsCreateManyArgs} args - Arguments to create many SecuritySplits.
     *     @example
     *     // Create many SecuritySplits
     *     const securitySplits = await prisma.securitySplits.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecuritySplitsCreateManyArgs>(
      args?: SelectSubset<T, SecuritySplitsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SecuritySplits.
     * @param {SecuritySplitsDeleteArgs} args - Arguments to delete one SecuritySplits.
     * @example
     * // Delete one SecuritySplits
     * const SecuritySplits = await prisma.securitySplits.delete({
     *   where: {
     *     // ... filter to delete one SecuritySplits
     *   }
     * })
     * 
    **/
    delete<T extends SecuritySplitsDeleteArgs>(
      args: SelectSubset<T, SecuritySplitsDeleteArgs>
    ): CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T>>>

    /**
     * Update one SecuritySplits.
     * @param {SecuritySplitsUpdateArgs} args - Arguments to update one SecuritySplits.
     * @example
     * // Update one SecuritySplits
     * const securitySplits = await prisma.securitySplits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecuritySplitsUpdateArgs>(
      args: SelectSubset<T, SecuritySplitsUpdateArgs>
    ): CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T>>>

    /**
     * Delete zero or more SecuritySplits.
     * @param {SecuritySplitsDeleteManyArgs} args - Arguments to filter SecuritySplits to delete.
     * @example
     * // Delete a few SecuritySplits
     * const { count } = await prisma.securitySplits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecuritySplitsDeleteManyArgs>(
      args?: SelectSubset<T, SecuritySplitsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecuritySplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySplitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecuritySplits
     * const securitySplits = await prisma.securitySplits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecuritySplitsUpdateManyArgs>(
      args: SelectSubset<T, SecuritySplitsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SecuritySplits.
     * @param {SecuritySplitsUpsertArgs} args - Arguments to update or create a SecuritySplits.
     * @example
     * // Update or create a SecuritySplits
     * const securitySplits = await prisma.securitySplits.upsert({
     *   create: {
     *     // ... data to create a SecuritySplits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecuritySplits we want to update
     *   }
     * })
    **/
    upsert<T extends SecuritySplitsUpsertArgs>(
      args: SelectSubset<T, SecuritySplitsUpsertArgs>
    ): CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T>>>

    /**
     * Find one SecuritySplits that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SecuritySplitsFindUniqueOrThrowArgs} args - Arguments to find a SecuritySplits
     * @example
     * // Get one SecuritySplits
     * const securitySplits = await prisma.securitySplits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecuritySplitsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SecuritySplitsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T>>>

    /**
     * Find the first SecuritySplits that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySplitsFindFirstOrThrowArgs} args - Arguments to find a SecuritySplits
     * @example
     * // Get one SecuritySplits
     * const securitySplits = await prisma.securitySplits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecuritySplitsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SecuritySplitsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SecuritySplitsClient<SecuritySplits>, Prisma__SecuritySplitsClient<SecuritySplitsGetPayload<T>>>

    /**
     * Count the number of SecuritySplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySplitsCountArgs} args - Arguments to filter SecuritySplits to count.
     * @example
     * // Count the number of SecuritySplits
     * const count = await prisma.securitySplits.count({
     *   where: {
     *     // ... the filter for the SecuritySplits we want to count
     *   }
     * })
    **/
    count<T extends SecuritySplitsCountArgs>(
      args?: Subset<T, SecuritySplitsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecuritySplitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecuritySplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySplitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecuritySplitsAggregateArgs>(args: Subset<T, SecuritySplitsAggregateArgs>): PrismaPromise<GetSecuritySplitsAggregateType<T>>

    /**
     * Group by SecuritySplits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySplitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecuritySplitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecuritySplitsGroupByArgs['orderBy'] }
        : { orderBy?: SecuritySplitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecuritySplitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecuritySplitsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SecuritySplits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SecuritySplitsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Security<T extends SecuritiesArgs = {}>(args?: Subset<T, SecuritiesArgs>): CheckSelect<T, Prisma__SecuritiesClient<Securities | Null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SecuritySplits base type for findUnique actions
   */
  export type SecuritySplitsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SecuritySplits
     * 
    **/
    select?: SecuritySplitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySplitsInclude | null
    /**
     * Filter, which SecuritySplits to fetch.
     * 
    **/
    where: SecuritySplitsWhereUniqueInput
  }

  /**
   * SecuritySplits: findUnique
   */
  export interface SecuritySplitsFindUniqueArgs extends SecuritySplitsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecuritySplits base type for findFirst actions
   */
  export type SecuritySplitsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SecuritySplits
     * 
    **/
    select?: SecuritySplitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySplitsInclude | null
    /**
     * Filter, which SecuritySplits to fetch.
     * 
    **/
    where?: SecuritySplitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySplits to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritySplitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecuritySplits.
     * 
    **/
    cursor?: SecuritySplitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySplits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySplits.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecuritySplits.
     * 
    **/
    distinct?: Enumerable<SecuritySplitsScalarFieldEnum>
  }

  /**
   * SecuritySplits: findFirst
   */
  export interface SecuritySplitsFindFirstArgs extends SecuritySplitsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecuritySplits findMany
   */
  export type SecuritySplitsFindManyArgs = {
    /**
     * Select specific fields to fetch from the SecuritySplits
     * 
    **/
    select?: SecuritySplitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySplitsInclude | null
    /**
     * Filter, which SecuritySplits to fetch.
     * 
    **/
    where?: SecuritySplitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySplits to fetch.
     * 
    **/
    orderBy?: Enumerable<SecuritySplitsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecuritySplits.
     * 
    **/
    cursor?: SecuritySplitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySplits from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySplits.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SecuritySplitsScalarFieldEnum>
  }


  /**
   * SecuritySplits create
   */
  export type SecuritySplitsCreateArgs = {
    /**
     * Select specific fields to fetch from the SecuritySplits
     * 
    **/
    select?: SecuritySplitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySplitsInclude | null
    /**
     * The data needed to create a SecuritySplits.
     * 
    **/
    data: XOR<SecuritySplitsCreateInput, SecuritySplitsUncheckedCreateInput>
  }


  /**
   * SecuritySplits createMany
   */
  export type SecuritySplitsCreateManyArgs = {
    /**
     * The data used to create many SecuritySplits.
     * 
    **/
    data: Enumerable<SecuritySplitsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SecuritySplits update
   */
  export type SecuritySplitsUpdateArgs = {
    /**
     * Select specific fields to fetch from the SecuritySplits
     * 
    **/
    select?: SecuritySplitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySplitsInclude | null
    /**
     * The data needed to update a SecuritySplits.
     * 
    **/
    data: XOR<SecuritySplitsUpdateInput, SecuritySplitsUncheckedUpdateInput>
    /**
     * Choose, which SecuritySplits to update.
     * 
    **/
    where: SecuritySplitsWhereUniqueInput
  }


  /**
   * SecuritySplits updateMany
   */
  export type SecuritySplitsUpdateManyArgs = {
    /**
     * The data used to update SecuritySplits.
     * 
    **/
    data: XOR<SecuritySplitsUpdateManyMutationInput, SecuritySplitsUncheckedUpdateManyInput>
    /**
     * Filter which SecuritySplits to update
     * 
    **/
    where?: SecuritySplitsWhereInput
  }


  /**
   * SecuritySplits upsert
   */
  export type SecuritySplitsUpsertArgs = {
    /**
     * Select specific fields to fetch from the SecuritySplits
     * 
    **/
    select?: SecuritySplitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySplitsInclude | null
    /**
     * The filter to search for the SecuritySplits to update in case it exists.
     * 
    **/
    where: SecuritySplitsWhereUniqueInput
    /**
     * In case the SecuritySplits found by the `where` argument doesn't exist, create a new SecuritySplits with this data.
     * 
    **/
    create: XOR<SecuritySplitsCreateInput, SecuritySplitsUncheckedCreateInput>
    /**
     * In case the SecuritySplits was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SecuritySplitsUpdateInput, SecuritySplitsUncheckedUpdateInput>
  }


  /**
   * SecuritySplits delete
   */
  export type SecuritySplitsDeleteArgs = {
    /**
     * Select specific fields to fetch from the SecuritySplits
     * 
    **/
    select?: SecuritySplitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySplitsInclude | null
    /**
     * Filter which SecuritySplits to delete.
     * 
    **/
    where: SecuritySplitsWhereUniqueInput
  }


  /**
   * SecuritySplits deleteMany
   */
  export type SecuritySplitsDeleteManyArgs = {
    /**
     * Filter which SecuritySplits to delete
     * 
    **/
    where?: SecuritySplitsWhereInput
  }


  /**
   * SecuritySplits: findUniqueOrThrow
   */
  export type SecuritySplitsFindUniqueOrThrowArgs = SecuritySplitsFindUniqueArgsBase
      

  /**
   * SecuritySplits: findFirstOrThrow
   */
  export type SecuritySplitsFindFirstOrThrowArgs = SecuritySplitsFindFirstArgsBase
      

  /**
   * SecuritySplits without action
   */
  export type SecuritySplitsArgs = {
    /**
     * Select specific fields to fetch from the SecuritySplits
     * 
    **/
    select?: SecuritySplitsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SecuritySplitsInclude | null
  }



  /**
   * Model SecurityTypes
   */


  export type AggregateSecurityTypes = {
    _count: SecurityTypesCountAggregateOutputType | null
    _avg: SecurityTypesAvgAggregateOutputType | null
    _sum: SecurityTypesSumAggregateOutputType | null
    _min: SecurityTypesMinAggregateOutputType | null
    _max: SecurityTypesMaxAggregateOutputType | null
  }

  export type SecurityTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type SecurityTypesSumAggregateOutputType = {
    id: number | null
  }

  export type SecurityTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type SecurityTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type SecurityTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type SecurityTypesAvgAggregateInputType = {
    id?: true
  }

  export type SecurityTypesSumAggregateInputType = {
    id?: true
  }

  export type SecurityTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SecurityTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SecurityTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type SecurityTypesAggregateArgs = {
    /**
     * Filter which SecurityTypes to aggregate.
     * 
    **/
    where?: SecurityTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SecurityTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityTypes
    **/
    _count?: true | SecurityTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecurityTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecurityTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityTypesMaxAggregateInputType
  }

  export type GetSecurityTypesAggregateType<T extends SecurityTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityTypes[P]>
      : GetScalarType<T[P], AggregateSecurityTypes[P]>
  }




  export type SecurityTypesGroupByArgs = {
    where?: SecurityTypesWhereInput
    orderBy?: Enumerable<SecurityTypesOrderByWithAggregationInput>
    by: Array<SecurityTypesScalarFieldEnum>
    having?: SecurityTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityTypesCountAggregateInputType | true
    _avg?: SecurityTypesAvgAggregateInputType
    _sum?: SecurityTypesSumAggregateInputType
    _min?: SecurityTypesMinAggregateInputType
    _max?: SecurityTypesMaxAggregateInputType
  }


  export type SecurityTypesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: SecurityTypesCountAggregateOutputType | null
    _avg: SecurityTypesAvgAggregateOutputType | null
    _sum: SecurityTypesSumAggregateOutputType | null
    _min: SecurityTypesMinAggregateOutputType | null
    _max: SecurityTypesMaxAggregateOutputType | null
  }

  type GetSecurityTypesGroupByPayload<T extends SecurityTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SecurityTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityTypesGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityTypesGroupByOutputType[P]>
        }
      >
    >


  export type SecurityTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type SecurityTypesGetPayload<
    S extends boolean | null | undefined | SecurityTypesArgs,
    U = keyof S
      > = S extends true
        ? SecurityTypes
    : S extends undefined
    ? never
    : S extends SecurityTypesArgs | SecurityTypesFindManyArgs
    ?'include' extends U
    ? SecurityTypes 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SecurityTypes ? SecurityTypes[P] : never
  } 
    : SecurityTypes
  : SecurityTypes


  type SecurityTypesCountArgs = Merge<
    Omit<SecurityTypesFindManyArgs, 'select' | 'include'> & {
      select?: SecurityTypesCountAggregateInputType | true
    }
  >

  export interface SecurityTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SecurityTypes that matches the filter.
     * @param {SecurityTypesFindUniqueArgs} args - Arguments to find a SecurityTypes
     * @example
     * // Get one SecurityTypes
     * const securityTypes = await prisma.securityTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SecurityTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SecurityTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SecurityTypes'> extends True ? CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T>>> : CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes | null, null>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T> | null, null>>

    /**
     * Find the first SecurityTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityTypesFindFirstArgs} args - Arguments to find a SecurityTypes
     * @example
     * // Get one SecurityTypes
     * const securityTypes = await prisma.securityTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SecurityTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SecurityTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SecurityTypes'> extends True ? CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T>>> : CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes | null, null>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T> | null, null>>

    /**
     * Find zero or more SecurityTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityTypes
     * const securityTypes = await prisma.securityTypes.findMany()
     * 
     * // Get first 10 SecurityTypes
     * const securityTypes = await prisma.securityTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityTypesWithIdOnly = await prisma.securityTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SecurityTypesFindManyArgs>(
      args?: SelectSubset<T, SecurityTypesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SecurityTypes>>, PrismaPromise<Array<SecurityTypesGetPayload<T>>>>

    /**
     * Create a SecurityTypes.
     * @param {SecurityTypesCreateArgs} args - Arguments to create a SecurityTypes.
     * @example
     * // Create one SecurityTypes
     * const SecurityTypes = await prisma.securityTypes.create({
     *   data: {
     *     // ... data to create a SecurityTypes
     *   }
     * })
     * 
    **/
    create<T extends SecurityTypesCreateArgs>(
      args: SelectSubset<T, SecurityTypesCreateArgs>
    ): CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T>>>

    /**
     * Create many SecurityTypes.
     *     @param {SecurityTypesCreateManyArgs} args - Arguments to create many SecurityTypes.
     *     @example
     *     // Create many SecurityTypes
     *     const securityTypes = await prisma.securityTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SecurityTypesCreateManyArgs>(
      args?: SelectSubset<T, SecurityTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SecurityTypes.
     * @param {SecurityTypesDeleteArgs} args - Arguments to delete one SecurityTypes.
     * @example
     * // Delete one SecurityTypes
     * const SecurityTypes = await prisma.securityTypes.delete({
     *   where: {
     *     // ... filter to delete one SecurityTypes
     *   }
     * })
     * 
    **/
    delete<T extends SecurityTypesDeleteArgs>(
      args: SelectSubset<T, SecurityTypesDeleteArgs>
    ): CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T>>>

    /**
     * Update one SecurityTypes.
     * @param {SecurityTypesUpdateArgs} args - Arguments to update one SecurityTypes.
     * @example
     * // Update one SecurityTypes
     * const securityTypes = await prisma.securityTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SecurityTypesUpdateArgs>(
      args: SelectSubset<T, SecurityTypesUpdateArgs>
    ): CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T>>>

    /**
     * Delete zero or more SecurityTypes.
     * @param {SecurityTypesDeleteManyArgs} args - Arguments to filter SecurityTypes to delete.
     * @example
     * // Delete a few SecurityTypes
     * const { count } = await prisma.securityTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SecurityTypesDeleteManyArgs>(
      args?: SelectSubset<T, SecurityTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityTypes
     * const securityTypes = await prisma.securityTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SecurityTypesUpdateManyArgs>(
      args: SelectSubset<T, SecurityTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityTypes.
     * @param {SecurityTypesUpsertArgs} args - Arguments to update or create a SecurityTypes.
     * @example
     * // Update or create a SecurityTypes
     * const securityTypes = await prisma.securityTypes.upsert({
     *   create: {
     *     // ... data to create a SecurityTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityTypes we want to update
     *   }
     * })
    **/
    upsert<T extends SecurityTypesUpsertArgs>(
      args: SelectSubset<T, SecurityTypesUpsertArgs>
    ): CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T>>>

    /**
     * Find one SecurityTypes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {SecurityTypesFindUniqueOrThrowArgs} args - Arguments to find a SecurityTypes
     * @example
     * // Get one SecurityTypes
     * const securityTypes = await prisma.securityTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SecurityTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SecurityTypesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T>>>

    /**
     * Find the first SecurityTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityTypesFindFirstOrThrowArgs} args - Arguments to find a SecurityTypes
     * @example
     * // Get one SecurityTypes
     * const securityTypes = await prisma.securityTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SecurityTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SecurityTypesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__SecurityTypesClient<SecurityTypes>, Prisma__SecurityTypesClient<SecurityTypesGetPayload<T>>>

    /**
     * Count the number of SecurityTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityTypesCountArgs} args - Arguments to filter SecurityTypes to count.
     * @example
     * // Count the number of SecurityTypes
     * const count = await prisma.securityTypes.count({
     *   where: {
     *     // ... the filter for the SecurityTypes we want to count
     *   }
     * })
    **/
    count<T extends SecurityTypesCountArgs>(
      args?: Subset<T, SecurityTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityTypesAggregateArgs>(args: Subset<T, SecurityTypesAggregateArgs>): PrismaPromise<GetSecurityTypesAggregateType<T>>

    /**
     * Group by SecurityTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityTypesGroupByArgs['orderBy'] }
        : { orderBy?: SecurityTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SecurityTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SecurityTypes base type for findUnique actions
   */
  export type SecurityTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityTypes
     * 
    **/
    select?: SecurityTypesSelect | null
    /**
     * Filter, which SecurityTypes to fetch.
     * 
    **/
    where: SecurityTypesWhereUniqueInput
  }

  /**
   * SecurityTypes: findUnique
   */
  export interface SecurityTypesFindUniqueArgs extends SecurityTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityTypes base type for findFirst actions
   */
  export type SecurityTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SecurityTypes
     * 
    **/
    select?: SecurityTypesSelect | null
    /**
     * Filter, which SecurityTypes to fetch.
     * 
    **/
    where?: SecurityTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityTypes.
     * 
    **/
    cursor?: SecurityTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityTypes.
     * 
    **/
    distinct?: Enumerable<SecurityTypesScalarFieldEnum>
  }

  /**
   * SecurityTypes: findFirst
   */
  export interface SecurityTypesFindFirstArgs extends SecurityTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SecurityTypes findMany
   */
  export type SecurityTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the SecurityTypes
     * 
    **/
    select?: SecurityTypesSelect | null
    /**
     * Filter, which SecurityTypes to fetch.
     * 
    **/
    where?: SecurityTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SecurityTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityTypes.
     * 
    **/
    cursor?: SecurityTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SecurityTypesScalarFieldEnum>
  }


  /**
   * SecurityTypes create
   */
  export type SecurityTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the SecurityTypes
     * 
    **/
    select?: SecurityTypesSelect | null
    /**
     * The data needed to create a SecurityTypes.
     * 
    **/
    data: XOR<SecurityTypesCreateInput, SecurityTypesUncheckedCreateInput>
  }


  /**
   * SecurityTypes createMany
   */
  export type SecurityTypesCreateManyArgs = {
    /**
     * The data used to create many SecurityTypes.
     * 
    **/
    data: Enumerable<SecurityTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SecurityTypes update
   */
  export type SecurityTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the SecurityTypes
     * 
    **/
    select?: SecurityTypesSelect | null
    /**
     * The data needed to update a SecurityTypes.
     * 
    **/
    data: XOR<SecurityTypesUpdateInput, SecurityTypesUncheckedUpdateInput>
    /**
     * Choose, which SecurityTypes to update.
     * 
    **/
    where: SecurityTypesWhereUniqueInput
  }


  /**
   * SecurityTypes updateMany
   */
  export type SecurityTypesUpdateManyArgs = {
    /**
     * The data used to update SecurityTypes.
     * 
    **/
    data: XOR<SecurityTypesUpdateManyMutationInput, SecurityTypesUncheckedUpdateManyInput>
    /**
     * Filter which SecurityTypes to update
     * 
    **/
    where?: SecurityTypesWhereInput
  }


  /**
   * SecurityTypes upsert
   */
  export type SecurityTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the SecurityTypes
     * 
    **/
    select?: SecurityTypesSelect | null
    /**
     * The filter to search for the SecurityTypes to update in case it exists.
     * 
    **/
    where: SecurityTypesWhereUniqueInput
    /**
     * In case the SecurityTypes found by the `where` argument doesn't exist, create a new SecurityTypes with this data.
     * 
    **/
    create: XOR<SecurityTypesCreateInput, SecurityTypesUncheckedCreateInput>
    /**
     * In case the SecurityTypes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SecurityTypesUpdateInput, SecurityTypesUncheckedUpdateInput>
  }


  /**
   * SecurityTypes delete
   */
  export type SecurityTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the SecurityTypes
     * 
    **/
    select?: SecurityTypesSelect | null
    /**
     * Filter which SecurityTypes to delete.
     * 
    **/
    where: SecurityTypesWhereUniqueInput
  }


  /**
   * SecurityTypes deleteMany
   */
  export type SecurityTypesDeleteManyArgs = {
    /**
     * Filter which SecurityTypes to delete
     * 
    **/
    where?: SecurityTypesWhereInput
  }


  /**
   * SecurityTypes: findUniqueOrThrow
   */
  export type SecurityTypesFindUniqueOrThrowArgs = SecurityTypesFindUniqueArgsBase
      

  /**
   * SecurityTypes: findFirstOrThrow
   */
  export type SecurityTypesFindFirstOrThrowArgs = SecurityTypesFindFirstArgsBase
      

  /**
   * SecurityTypes without action
   */
  export type SecurityTypesArgs = {
    /**
     * Select specific fields to fetch from the SecurityTypes
     * 
    **/
    select?: SecurityTypesSelect | null
  }



  /**
   * Model Strategies
   */


  export type AggregateStrategies = {
    _count: StrategiesCountAggregateOutputType | null
    _avg: StrategiesAvgAggregateOutputType | null
    _sum: StrategiesSumAggregateOutputType | null
    _min: StrategiesMinAggregateOutputType | null
    _max: StrategiesMaxAggregateOutputType | null
  }

  export type StrategiesAvgAggregateOutputType = {
    id: number | null
  }

  export type StrategiesSumAggregateOutputType = {
    id: number | null
  }

  export type StrategiesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type StrategiesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type StrategiesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type StrategiesAvgAggregateInputType = {
    id?: true
  }

  export type StrategiesSumAggregateInputType = {
    id?: true
  }

  export type StrategiesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type StrategiesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type StrategiesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type StrategiesAggregateArgs = {
    /**
     * Filter which Strategies to aggregate.
     * 
    **/
    where?: StrategiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     * 
    **/
    orderBy?: Enumerable<StrategiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StrategiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Strategies
    **/
    _count?: true | StrategiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrategiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrategiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrategiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrategiesMaxAggregateInputType
  }

  export type GetStrategiesAggregateType<T extends StrategiesAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategies[P]>
      : GetScalarType<T[P], AggregateStrategies[P]>
  }




  export type StrategiesGroupByArgs = {
    where?: StrategiesWhereInput
    orderBy?: Enumerable<StrategiesOrderByWithAggregationInput>
    by: Array<StrategiesScalarFieldEnum>
    having?: StrategiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrategiesCountAggregateInputType | true
    _avg?: StrategiesAvgAggregateInputType
    _sum?: StrategiesSumAggregateInputType
    _min?: StrategiesMinAggregateInputType
    _max?: StrategiesMaxAggregateInputType
  }


  export type StrategiesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: StrategiesCountAggregateOutputType | null
    _avg: StrategiesAvgAggregateOutputType | null
    _sum: StrategiesSumAggregateOutputType | null
    _min: StrategiesMinAggregateOutputType | null
    _max: StrategiesMaxAggregateOutputType | null
  }

  type GetStrategiesGroupByPayload<T extends StrategiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StrategiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrategiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrategiesGroupByOutputType[P]>
            : GetScalarType<T[P], StrategiesGroupByOutputType[P]>
        }
      >
    >


  export type StrategiesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    StrategyParameters?: boolean | StrategyParametersFindManyArgs
    _count?: boolean | StrategiesCountOutputTypeArgs
  }

  export type StrategiesInclude = {
    StrategyParameters?: boolean | StrategyParametersFindManyArgs
    _count?: boolean | StrategiesCountOutputTypeArgs
  }

  export type StrategiesGetPayload<
    S extends boolean | null | undefined | StrategiesArgs,
    U = keyof S
      > = S extends true
        ? Strategies
    : S extends undefined
    ? never
    : S extends StrategiesArgs | StrategiesFindManyArgs
    ?'include' extends U
    ? Strategies  & {
    [P in TrueKeys<S['include']>]:
        P extends 'StrategyParameters' ? Array < StrategyParametersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? StrategiesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'StrategyParameters' ? Array < StrategyParametersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? StrategiesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Strategies ? Strategies[P] : never
  } 
    : Strategies
  : Strategies


  type StrategiesCountArgs = Merge<
    Omit<StrategiesFindManyArgs, 'select' | 'include'> & {
      select?: StrategiesCountAggregateInputType | true
    }
  >

  export interface StrategiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Strategies that matches the filter.
     * @param {StrategiesFindUniqueArgs} args - Arguments to find a Strategies
     * @example
     * // Get one Strategies
     * const strategies = await prisma.strategies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StrategiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StrategiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Strategies'> extends True ? CheckSelect<T, Prisma__StrategiesClient<Strategies>, Prisma__StrategiesClient<StrategiesGetPayload<T>>> : CheckSelect<T, Prisma__StrategiesClient<Strategies | null, null>, Prisma__StrategiesClient<StrategiesGetPayload<T> | null, null>>

    /**
     * Find the first Strategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategiesFindFirstArgs} args - Arguments to find a Strategies
     * @example
     * // Get one Strategies
     * const strategies = await prisma.strategies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StrategiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StrategiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Strategies'> extends True ? CheckSelect<T, Prisma__StrategiesClient<Strategies>, Prisma__StrategiesClient<StrategiesGetPayload<T>>> : CheckSelect<T, Prisma__StrategiesClient<Strategies | null, null>, Prisma__StrategiesClient<StrategiesGetPayload<T> | null, null>>

    /**
     * Find zero or more Strategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strategies
     * const strategies = await prisma.strategies.findMany()
     * 
     * // Get first 10 Strategies
     * const strategies = await prisma.strategies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strategiesWithIdOnly = await prisma.strategies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StrategiesFindManyArgs>(
      args?: SelectSubset<T, StrategiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Strategies>>, PrismaPromise<Array<StrategiesGetPayload<T>>>>

    /**
     * Create a Strategies.
     * @param {StrategiesCreateArgs} args - Arguments to create a Strategies.
     * @example
     * // Create one Strategies
     * const Strategies = await prisma.strategies.create({
     *   data: {
     *     // ... data to create a Strategies
     *   }
     * })
     * 
    **/
    create<T extends StrategiesCreateArgs>(
      args: SelectSubset<T, StrategiesCreateArgs>
    ): CheckSelect<T, Prisma__StrategiesClient<Strategies>, Prisma__StrategiesClient<StrategiesGetPayload<T>>>

    /**
     * Create many Strategies.
     *     @param {StrategiesCreateManyArgs} args - Arguments to create many Strategies.
     *     @example
     *     // Create many Strategies
     *     const strategies = await prisma.strategies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StrategiesCreateManyArgs>(
      args?: SelectSubset<T, StrategiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Strategies.
     * @param {StrategiesDeleteArgs} args - Arguments to delete one Strategies.
     * @example
     * // Delete one Strategies
     * const Strategies = await prisma.strategies.delete({
     *   where: {
     *     // ... filter to delete one Strategies
     *   }
     * })
     * 
    **/
    delete<T extends StrategiesDeleteArgs>(
      args: SelectSubset<T, StrategiesDeleteArgs>
    ): CheckSelect<T, Prisma__StrategiesClient<Strategies>, Prisma__StrategiesClient<StrategiesGetPayload<T>>>

    /**
     * Update one Strategies.
     * @param {StrategiesUpdateArgs} args - Arguments to update one Strategies.
     * @example
     * // Update one Strategies
     * const strategies = await prisma.strategies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StrategiesUpdateArgs>(
      args: SelectSubset<T, StrategiesUpdateArgs>
    ): CheckSelect<T, Prisma__StrategiesClient<Strategies>, Prisma__StrategiesClient<StrategiesGetPayload<T>>>

    /**
     * Delete zero or more Strategies.
     * @param {StrategiesDeleteManyArgs} args - Arguments to filter Strategies to delete.
     * @example
     * // Delete a few Strategies
     * const { count } = await prisma.strategies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StrategiesDeleteManyArgs>(
      args?: SelectSubset<T, StrategiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strategies
     * const strategies = await prisma.strategies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StrategiesUpdateManyArgs>(
      args: SelectSubset<T, StrategiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Strategies.
     * @param {StrategiesUpsertArgs} args - Arguments to update or create a Strategies.
     * @example
     * // Update or create a Strategies
     * const strategies = await prisma.strategies.upsert({
     *   create: {
     *     // ... data to create a Strategies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strategies we want to update
     *   }
     * })
    **/
    upsert<T extends StrategiesUpsertArgs>(
      args: SelectSubset<T, StrategiesUpsertArgs>
    ): CheckSelect<T, Prisma__StrategiesClient<Strategies>, Prisma__StrategiesClient<StrategiesGetPayload<T>>>

    /**
     * Find one Strategies that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StrategiesFindUniqueOrThrowArgs} args - Arguments to find a Strategies
     * @example
     * // Get one Strategies
     * const strategies = await prisma.strategies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StrategiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StrategiesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StrategiesClient<Strategies>, Prisma__StrategiesClient<StrategiesGetPayload<T>>>

    /**
     * Find the first Strategies that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategiesFindFirstOrThrowArgs} args - Arguments to find a Strategies
     * @example
     * // Get one Strategies
     * const strategies = await prisma.strategies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StrategiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StrategiesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StrategiesClient<Strategies>, Prisma__StrategiesClient<StrategiesGetPayload<T>>>

    /**
     * Count the number of Strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategiesCountArgs} args - Arguments to filter Strategies to count.
     * @example
     * // Count the number of Strategies
     * const count = await prisma.strategies.count({
     *   where: {
     *     // ... the filter for the Strategies we want to count
     *   }
     * })
    **/
    count<T extends StrategiesCountArgs>(
      args?: Subset<T, StrategiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrategiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrategiesAggregateArgs>(args: Subset<T, StrategiesAggregateArgs>): PrismaPromise<GetStrategiesAggregateType<T>>

    /**
     * Group by Strategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrategiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrategiesGroupByArgs['orderBy'] }
        : { orderBy?: StrategiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrategiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Strategies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StrategiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    StrategyParameters<T extends StrategyParametersFindManyArgs = {}>(args?: Subset<T, StrategyParametersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<StrategyParameters>| Null>, PrismaPromise<Array<StrategyParametersGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Strategies base type for findUnique actions
   */
  export type StrategiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Strategies
     * 
    **/
    select?: StrategiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategiesInclude | null
    /**
     * Filter, which Strategies to fetch.
     * 
    **/
    where: StrategiesWhereUniqueInput
  }

  /**
   * Strategies: findUnique
   */
  export interface StrategiesFindUniqueArgs extends StrategiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Strategies base type for findFirst actions
   */
  export type StrategiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Strategies
     * 
    **/
    select?: StrategiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategiesInclude | null
    /**
     * Filter, which Strategies to fetch.
     * 
    **/
    where?: StrategiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     * 
    **/
    orderBy?: Enumerable<StrategiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strategies.
     * 
    **/
    cursor?: StrategiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strategies.
     * 
    **/
    distinct?: Enumerable<StrategiesScalarFieldEnum>
  }

  /**
   * Strategies: findFirst
   */
  export interface StrategiesFindFirstArgs extends StrategiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Strategies findMany
   */
  export type StrategiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Strategies
     * 
    **/
    select?: StrategiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategiesInclude | null
    /**
     * Filter, which Strategies to fetch.
     * 
    **/
    where?: StrategiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strategies to fetch.
     * 
    **/
    orderBy?: Enumerable<StrategiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Strategies.
     * 
    **/
    cursor?: StrategiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strategies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strategies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StrategiesScalarFieldEnum>
  }


  /**
   * Strategies create
   */
  export type StrategiesCreateArgs = {
    /**
     * Select specific fields to fetch from the Strategies
     * 
    **/
    select?: StrategiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategiesInclude | null
    /**
     * The data needed to create a Strategies.
     * 
    **/
    data: XOR<StrategiesCreateInput, StrategiesUncheckedCreateInput>
  }


  /**
   * Strategies createMany
   */
  export type StrategiesCreateManyArgs = {
    /**
     * The data used to create many Strategies.
     * 
    **/
    data: Enumerable<StrategiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Strategies update
   */
  export type StrategiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Strategies
     * 
    **/
    select?: StrategiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategiesInclude | null
    /**
     * The data needed to update a Strategies.
     * 
    **/
    data: XOR<StrategiesUpdateInput, StrategiesUncheckedUpdateInput>
    /**
     * Choose, which Strategies to update.
     * 
    **/
    where: StrategiesWhereUniqueInput
  }


  /**
   * Strategies updateMany
   */
  export type StrategiesUpdateManyArgs = {
    /**
     * The data used to update Strategies.
     * 
    **/
    data: XOR<StrategiesUpdateManyMutationInput, StrategiesUncheckedUpdateManyInput>
    /**
     * Filter which Strategies to update
     * 
    **/
    where?: StrategiesWhereInput
  }


  /**
   * Strategies upsert
   */
  export type StrategiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Strategies
     * 
    **/
    select?: StrategiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategiesInclude | null
    /**
     * The filter to search for the Strategies to update in case it exists.
     * 
    **/
    where: StrategiesWhereUniqueInput
    /**
     * In case the Strategies found by the `where` argument doesn't exist, create a new Strategies with this data.
     * 
    **/
    create: XOR<StrategiesCreateInput, StrategiesUncheckedCreateInput>
    /**
     * In case the Strategies was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StrategiesUpdateInput, StrategiesUncheckedUpdateInput>
  }


  /**
   * Strategies delete
   */
  export type StrategiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Strategies
     * 
    **/
    select?: StrategiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategiesInclude | null
    /**
     * Filter which Strategies to delete.
     * 
    **/
    where: StrategiesWhereUniqueInput
  }


  /**
   * Strategies deleteMany
   */
  export type StrategiesDeleteManyArgs = {
    /**
     * Filter which Strategies to delete
     * 
    **/
    where?: StrategiesWhereInput
  }


  /**
   * Strategies: findUniqueOrThrow
   */
  export type StrategiesFindUniqueOrThrowArgs = StrategiesFindUniqueArgsBase
      

  /**
   * Strategies: findFirstOrThrow
   */
  export type StrategiesFindFirstOrThrowArgs = StrategiesFindFirstArgsBase
      

  /**
   * Strategies without action
   */
  export type StrategiesArgs = {
    /**
     * Select specific fields to fetch from the Strategies
     * 
    **/
    select?: StrategiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategiesInclude | null
  }



  /**
   * Model StrategyParameters
   */


  export type AggregateStrategyParameters = {
    _count: StrategyParametersCountAggregateOutputType | null
    _avg: StrategyParametersAvgAggregateOutputType | null
    _sum: StrategyParametersSumAggregateOutputType | null
    _min: StrategyParametersMinAggregateOutputType | null
    _max: StrategyParametersMaxAggregateOutputType | null
  }

  export type StrategyParametersAvgAggregateOutputType = {
    id: number | null
    strategyId: number | null
  }

  export type StrategyParametersSumAggregateOutputType = {
    id: number | null
    strategyId: number | null
  }

  export type StrategyParametersMinAggregateOutputType = {
    id: number | null
    strategyId: number | null
    key: string | null
    value: string | null
    dataType: string | null
  }

  export type StrategyParametersMaxAggregateOutputType = {
    id: number | null
    strategyId: number | null
    key: string | null
    value: string | null
    dataType: string | null
  }

  export type StrategyParametersCountAggregateOutputType = {
    id: number
    strategyId: number
    key: number
    value: number
    dataType: number
    _all: number
  }


  export type StrategyParametersAvgAggregateInputType = {
    id?: true
    strategyId?: true
  }

  export type StrategyParametersSumAggregateInputType = {
    id?: true
    strategyId?: true
  }

  export type StrategyParametersMinAggregateInputType = {
    id?: true
    strategyId?: true
    key?: true
    value?: true
    dataType?: true
  }

  export type StrategyParametersMaxAggregateInputType = {
    id?: true
    strategyId?: true
    key?: true
    value?: true
    dataType?: true
  }

  export type StrategyParametersCountAggregateInputType = {
    id?: true
    strategyId?: true
    key?: true
    value?: true
    dataType?: true
    _all?: true
  }

  export type StrategyParametersAggregateArgs = {
    /**
     * Filter which StrategyParameters to aggregate.
     * 
    **/
    where?: StrategyParametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyParameters to fetch.
     * 
    **/
    orderBy?: Enumerable<StrategyParametersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StrategyParametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyParameters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyParameters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StrategyParameters
    **/
    _count?: true | StrategyParametersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrategyParametersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrategyParametersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrategyParametersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrategyParametersMaxAggregateInputType
  }

  export type GetStrategyParametersAggregateType<T extends StrategyParametersAggregateArgs> = {
        [P in keyof T & keyof AggregateStrategyParameters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrategyParameters[P]>
      : GetScalarType<T[P], AggregateStrategyParameters[P]>
  }




  export type StrategyParametersGroupByArgs = {
    where?: StrategyParametersWhereInput
    orderBy?: Enumerable<StrategyParametersOrderByWithAggregationInput>
    by: Array<StrategyParametersScalarFieldEnum>
    having?: StrategyParametersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrategyParametersCountAggregateInputType | true
    _avg?: StrategyParametersAvgAggregateInputType
    _sum?: StrategyParametersSumAggregateInputType
    _min?: StrategyParametersMinAggregateInputType
    _max?: StrategyParametersMaxAggregateInputType
  }


  export type StrategyParametersGroupByOutputType = {
    id: number
    strategyId: number
    key: string
    value: string
    dataType: string | null
    _count: StrategyParametersCountAggregateOutputType | null
    _avg: StrategyParametersAvgAggregateOutputType | null
    _sum: StrategyParametersSumAggregateOutputType | null
    _min: StrategyParametersMinAggregateOutputType | null
    _max: StrategyParametersMaxAggregateOutputType | null
  }

  type GetStrategyParametersGroupByPayload<T extends StrategyParametersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StrategyParametersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrategyParametersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrategyParametersGroupByOutputType[P]>
            : GetScalarType<T[P], StrategyParametersGroupByOutputType[P]>
        }
      >
    >


  export type StrategyParametersSelect = {
    id?: boolean
    strategyId?: boolean
    key?: boolean
    value?: boolean
    dataType?: boolean
    Strategy?: boolean | StrategiesArgs
  }

  export type StrategyParametersInclude = {
    Strategy?: boolean | StrategiesArgs
  }

  export type StrategyParametersGetPayload<
    S extends boolean | null | undefined | StrategyParametersArgs,
    U = keyof S
      > = S extends true
        ? StrategyParameters
    : S extends undefined
    ? never
    : S extends StrategyParametersArgs | StrategyParametersFindManyArgs
    ?'include' extends U
    ? StrategyParameters  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Strategy' ? StrategiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Strategy' ? StrategiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof StrategyParameters ? StrategyParameters[P] : never
  } 
    : StrategyParameters
  : StrategyParameters


  type StrategyParametersCountArgs = Merge<
    Omit<StrategyParametersFindManyArgs, 'select' | 'include'> & {
      select?: StrategyParametersCountAggregateInputType | true
    }
  >

  export interface StrategyParametersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one StrategyParameters that matches the filter.
     * @param {StrategyParametersFindUniqueArgs} args - Arguments to find a StrategyParameters
     * @example
     * // Get one StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StrategyParametersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StrategyParametersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'StrategyParameters'> extends True ? CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T>>> : CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters | null, null>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T> | null, null>>

    /**
     * Find the first StrategyParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyParametersFindFirstArgs} args - Arguments to find a StrategyParameters
     * @example
     * // Get one StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StrategyParametersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StrategyParametersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'StrategyParameters'> extends True ? CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T>>> : CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters | null, null>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T> | null, null>>

    /**
     * Find zero or more StrategyParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyParametersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.findMany()
     * 
     * // Get first 10 StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strategyParametersWithIdOnly = await prisma.strategyParameters.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StrategyParametersFindManyArgs>(
      args?: SelectSubset<T, StrategyParametersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<StrategyParameters>>, PrismaPromise<Array<StrategyParametersGetPayload<T>>>>

    /**
     * Create a StrategyParameters.
     * @param {StrategyParametersCreateArgs} args - Arguments to create a StrategyParameters.
     * @example
     * // Create one StrategyParameters
     * const StrategyParameters = await prisma.strategyParameters.create({
     *   data: {
     *     // ... data to create a StrategyParameters
     *   }
     * })
     * 
    **/
    create<T extends StrategyParametersCreateArgs>(
      args: SelectSubset<T, StrategyParametersCreateArgs>
    ): CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T>>>

    /**
     * Create many StrategyParameters.
     *     @param {StrategyParametersCreateManyArgs} args - Arguments to create many StrategyParameters.
     *     @example
     *     // Create many StrategyParameters
     *     const strategyParameters = await prisma.strategyParameters.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StrategyParametersCreateManyArgs>(
      args?: SelectSubset<T, StrategyParametersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a StrategyParameters.
     * @param {StrategyParametersDeleteArgs} args - Arguments to delete one StrategyParameters.
     * @example
     * // Delete one StrategyParameters
     * const StrategyParameters = await prisma.strategyParameters.delete({
     *   where: {
     *     // ... filter to delete one StrategyParameters
     *   }
     * })
     * 
    **/
    delete<T extends StrategyParametersDeleteArgs>(
      args: SelectSubset<T, StrategyParametersDeleteArgs>
    ): CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T>>>

    /**
     * Update one StrategyParameters.
     * @param {StrategyParametersUpdateArgs} args - Arguments to update one StrategyParameters.
     * @example
     * // Update one StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StrategyParametersUpdateArgs>(
      args: SelectSubset<T, StrategyParametersUpdateArgs>
    ): CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T>>>

    /**
     * Delete zero or more StrategyParameters.
     * @param {StrategyParametersDeleteManyArgs} args - Arguments to filter StrategyParameters to delete.
     * @example
     * // Delete a few StrategyParameters
     * const { count } = await prisma.strategyParameters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StrategyParametersDeleteManyArgs>(
      args?: SelectSubset<T, StrategyParametersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrategyParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyParametersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StrategyParametersUpdateManyArgs>(
      args: SelectSubset<T, StrategyParametersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one StrategyParameters.
     * @param {StrategyParametersUpsertArgs} args - Arguments to update or create a StrategyParameters.
     * @example
     * // Update or create a StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.upsert({
     *   create: {
     *     // ... data to create a StrategyParameters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StrategyParameters we want to update
     *   }
     * })
    **/
    upsert<T extends StrategyParametersUpsertArgs>(
      args: SelectSubset<T, StrategyParametersUpsertArgs>
    ): CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T>>>

    /**
     * Find one StrategyParameters that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {StrategyParametersFindUniqueOrThrowArgs} args - Arguments to find a StrategyParameters
     * @example
     * // Get one StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StrategyParametersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StrategyParametersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T>>>

    /**
     * Find the first StrategyParameters that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyParametersFindFirstOrThrowArgs} args - Arguments to find a StrategyParameters
     * @example
     * // Get one StrategyParameters
     * const strategyParameters = await prisma.strategyParameters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StrategyParametersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StrategyParametersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__StrategyParametersClient<StrategyParameters>, Prisma__StrategyParametersClient<StrategyParametersGetPayload<T>>>

    /**
     * Count the number of StrategyParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyParametersCountArgs} args - Arguments to filter StrategyParameters to count.
     * @example
     * // Count the number of StrategyParameters
     * const count = await prisma.strategyParameters.count({
     *   where: {
     *     // ... the filter for the StrategyParameters we want to count
     *   }
     * })
    **/
    count<T extends StrategyParametersCountArgs>(
      args?: Subset<T, StrategyParametersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrategyParametersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StrategyParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyParametersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrategyParametersAggregateArgs>(args: Subset<T, StrategyParametersAggregateArgs>): PrismaPromise<GetStrategyParametersAggregateType<T>>

    /**
     * Group by StrategyParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrategyParametersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrategyParametersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrategyParametersGroupByArgs['orderBy'] }
        : { orderBy?: StrategyParametersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrategyParametersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrategyParametersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for StrategyParameters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StrategyParametersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Strategy<T extends StrategiesArgs = {}>(args?: Subset<T, StrategiesArgs>): CheckSelect<T, Prisma__StrategiesClient<Strategies | Null>, Prisma__StrategiesClient<StrategiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StrategyParameters base type for findUnique actions
   */
  export type StrategyParametersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the StrategyParameters
     * 
    **/
    select?: StrategyParametersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategyParametersInclude | null
    /**
     * Filter, which StrategyParameters to fetch.
     * 
    **/
    where: StrategyParametersWhereUniqueInput
  }

  /**
   * StrategyParameters: findUnique
   */
  export interface StrategyParametersFindUniqueArgs extends StrategyParametersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StrategyParameters base type for findFirst actions
   */
  export type StrategyParametersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the StrategyParameters
     * 
    **/
    select?: StrategyParametersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategyParametersInclude | null
    /**
     * Filter, which StrategyParameters to fetch.
     * 
    **/
    where?: StrategyParametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyParameters to fetch.
     * 
    **/
    orderBy?: Enumerable<StrategyParametersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrategyParameters.
     * 
    **/
    cursor?: StrategyParametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyParameters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyParameters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrategyParameters.
     * 
    **/
    distinct?: Enumerable<StrategyParametersScalarFieldEnum>
  }

  /**
   * StrategyParameters: findFirst
   */
  export interface StrategyParametersFindFirstArgs extends StrategyParametersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * StrategyParameters findMany
   */
  export type StrategyParametersFindManyArgs = {
    /**
     * Select specific fields to fetch from the StrategyParameters
     * 
    **/
    select?: StrategyParametersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategyParametersInclude | null
    /**
     * Filter, which StrategyParameters to fetch.
     * 
    **/
    where?: StrategyParametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrategyParameters to fetch.
     * 
    **/
    orderBy?: Enumerable<StrategyParametersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StrategyParameters.
     * 
    **/
    cursor?: StrategyParametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrategyParameters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrategyParameters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StrategyParametersScalarFieldEnum>
  }


  /**
   * StrategyParameters create
   */
  export type StrategyParametersCreateArgs = {
    /**
     * Select specific fields to fetch from the StrategyParameters
     * 
    **/
    select?: StrategyParametersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategyParametersInclude | null
    /**
     * The data needed to create a StrategyParameters.
     * 
    **/
    data: XOR<StrategyParametersCreateInput, StrategyParametersUncheckedCreateInput>
  }


  /**
   * StrategyParameters createMany
   */
  export type StrategyParametersCreateManyArgs = {
    /**
     * The data used to create many StrategyParameters.
     * 
    **/
    data: Enumerable<StrategyParametersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * StrategyParameters update
   */
  export type StrategyParametersUpdateArgs = {
    /**
     * Select specific fields to fetch from the StrategyParameters
     * 
    **/
    select?: StrategyParametersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategyParametersInclude | null
    /**
     * The data needed to update a StrategyParameters.
     * 
    **/
    data: XOR<StrategyParametersUpdateInput, StrategyParametersUncheckedUpdateInput>
    /**
     * Choose, which StrategyParameters to update.
     * 
    **/
    where: StrategyParametersWhereUniqueInput
  }


  /**
   * StrategyParameters updateMany
   */
  export type StrategyParametersUpdateManyArgs = {
    /**
     * The data used to update StrategyParameters.
     * 
    **/
    data: XOR<StrategyParametersUpdateManyMutationInput, StrategyParametersUncheckedUpdateManyInput>
    /**
     * Filter which StrategyParameters to update
     * 
    **/
    where?: StrategyParametersWhereInput
  }


  /**
   * StrategyParameters upsert
   */
  export type StrategyParametersUpsertArgs = {
    /**
     * Select specific fields to fetch from the StrategyParameters
     * 
    **/
    select?: StrategyParametersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategyParametersInclude | null
    /**
     * The filter to search for the StrategyParameters to update in case it exists.
     * 
    **/
    where: StrategyParametersWhereUniqueInput
    /**
     * In case the StrategyParameters found by the `where` argument doesn't exist, create a new StrategyParameters with this data.
     * 
    **/
    create: XOR<StrategyParametersCreateInput, StrategyParametersUncheckedCreateInput>
    /**
     * In case the StrategyParameters was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StrategyParametersUpdateInput, StrategyParametersUncheckedUpdateInput>
  }


  /**
   * StrategyParameters delete
   */
  export type StrategyParametersDeleteArgs = {
    /**
     * Select specific fields to fetch from the StrategyParameters
     * 
    **/
    select?: StrategyParametersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategyParametersInclude | null
    /**
     * Filter which StrategyParameters to delete.
     * 
    **/
    where: StrategyParametersWhereUniqueInput
  }


  /**
   * StrategyParameters deleteMany
   */
  export type StrategyParametersDeleteManyArgs = {
    /**
     * Filter which StrategyParameters to delete
     * 
    **/
    where?: StrategyParametersWhereInput
  }


  /**
   * StrategyParameters: findUniqueOrThrow
   */
  export type StrategyParametersFindUniqueOrThrowArgs = StrategyParametersFindUniqueArgsBase
      

  /**
   * StrategyParameters: findFirstOrThrow
   */
  export type StrategyParametersFindFirstOrThrowArgs = StrategyParametersFindFirstArgsBase
      

  /**
   * StrategyParameters without action
   */
  export type StrategyParametersArgs = {
    /**
     * Select specific fields to fetch from the StrategyParameters
     * 
    **/
    select?: StrategyParametersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: StrategyParametersInclude | null
  }



  /**
   * Model Trades
   */


  export type AggregateTrades = {
    _count: TradesCountAggregateOutputType | null
    _avg: TradesAvgAggregateOutputType | null
    _sum: TradesSumAggregateOutputType | null
    _min: TradesMinAggregateOutputType | null
    _max: TradesMaxAggregateOutputType | null
  }

  export type TradesAvgAggregateOutputType = {
    id: number | null
    securityId: number | null
    exchangeId: number | null
    price: Decimal | null
    quantity: Decimal | null
  }

  export type TradesSumAggregateOutputType = {
    id: number | null
    securityId: number | null
    exchangeId: number | null
    price: Decimal | null
    quantity: Decimal | null
  }

  export type TradesMinAggregateOutputType = {
    id: number | null
    securityId: number | null
    exchangeId: number | null
    tradeDate: Date | null
    price: Decimal | null
    quantity: Decimal | null
    createdAt: Date | null
  }

  export type TradesMaxAggregateOutputType = {
    id: number | null
    securityId: number | null
    exchangeId: number | null
    tradeDate: Date | null
    price: Decimal | null
    quantity: Decimal | null
    createdAt: Date | null
  }

  export type TradesCountAggregateOutputType = {
    id: number
    securityId: number
    exchangeId: number
    tradeDate: number
    price: number
    quantity: number
    createdAt: number
    _all: number
  }


  export type TradesAvgAggregateInputType = {
    id?: true
    securityId?: true
    exchangeId?: true
    price?: true
    quantity?: true
  }

  export type TradesSumAggregateInputType = {
    id?: true
    securityId?: true
    exchangeId?: true
    price?: true
    quantity?: true
  }

  export type TradesMinAggregateInputType = {
    id?: true
    securityId?: true
    exchangeId?: true
    tradeDate?: true
    price?: true
    quantity?: true
    createdAt?: true
  }

  export type TradesMaxAggregateInputType = {
    id?: true
    securityId?: true
    exchangeId?: true
    tradeDate?: true
    price?: true
    quantity?: true
    createdAt?: true
  }

  export type TradesCountAggregateInputType = {
    id?: true
    securityId?: true
    exchangeId?: true
    tradeDate?: true
    price?: true
    quantity?: true
    createdAt?: true
    _all?: true
  }

  export type TradesAggregateArgs = {
    /**
     * Filter which Trades to aggregate.
     * 
    **/
    where?: TradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     * 
    **/
    orderBy?: Enumerable<TradesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trades
    **/
    _count?: true | TradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradesMaxAggregateInputType
  }

  export type GetTradesAggregateType<T extends TradesAggregateArgs> = {
        [P in keyof T & keyof AggregateTrades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrades[P]>
      : GetScalarType<T[P], AggregateTrades[P]>
  }




  export type TradesGroupByArgs = {
    where?: TradesWhereInput
    orderBy?: Enumerable<TradesOrderByWithAggregationInput>
    by: Array<TradesScalarFieldEnum>
    having?: TradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradesCountAggregateInputType | true
    _avg?: TradesAvgAggregateInputType
    _sum?: TradesSumAggregateInputType
    _min?: TradesMinAggregateInputType
    _max?: TradesMaxAggregateInputType
  }


  export type TradesGroupByOutputType = {
    id: number
    securityId: number
    exchangeId: number
    tradeDate: Date
    price: Decimal
    quantity: Decimal
    createdAt: Date
    _count: TradesCountAggregateOutputType | null
    _avg: TradesAvgAggregateOutputType | null
    _sum: TradesSumAggregateOutputType | null
    _min: TradesMinAggregateOutputType | null
    _max: TradesMaxAggregateOutputType | null
  }

  type GetTradesGroupByPayload<T extends TradesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradesGroupByOutputType[P]>
            : GetScalarType<T[P], TradesGroupByOutputType[P]>
        }
      >
    >


  export type TradesSelect = {
    id?: boolean
    securityId?: boolean
    exchangeId?: boolean
    tradeDate?: boolean
    price?: boolean
    quantity?: boolean
    createdAt?: boolean
    Exchange?: boolean | ExchangesArgs
    Security?: boolean | SecuritiesArgs
    Conditions?: boolean | ConditionsFindManyArgs
    _count?: boolean | TradesCountOutputTypeArgs
  }

  export type TradesInclude = {
    Exchange?: boolean | ExchangesArgs
    Security?: boolean | SecuritiesArgs
    Conditions?: boolean | ConditionsFindManyArgs
    _count?: boolean | TradesCountOutputTypeArgs
  }

  export type TradesGetPayload<
    S extends boolean | null | undefined | TradesArgs,
    U = keyof S
      > = S extends true
        ? Trades
    : S extends undefined
    ? never
    : S extends TradesArgs | TradesFindManyArgs
    ?'include' extends U
    ? Trades  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Exchange' ? ExchangesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Conditions' ? Array < ConditionsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TradesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Exchange' ? ExchangesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Conditions' ? Array < ConditionsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TradesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Trades ? Trades[P] : never
  } 
    : Trades
  : Trades


  type TradesCountArgs = Merge<
    Omit<TradesFindManyArgs, 'select' | 'include'> & {
      select?: TradesCountAggregateInputType | true
    }
  >

  export interface TradesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Trades that matches the filter.
     * @param {TradesFindUniqueArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TradesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TradesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Trades'> extends True ? CheckSelect<T, Prisma__TradesClient<Trades>, Prisma__TradesClient<TradesGetPayload<T>>> : CheckSelect<T, Prisma__TradesClient<Trades | null, null>, Prisma__TradesClient<TradesGetPayload<T> | null, null>>

    /**
     * Find the first Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesFindFirstArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TradesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TradesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Trades'> extends True ? CheckSelect<T, Prisma__TradesClient<Trades>, Prisma__TradesClient<TradesGetPayload<T>>> : CheckSelect<T, Prisma__TradesClient<Trades | null, null>, Prisma__TradesClient<TradesGetPayload<T> | null, null>>

    /**
     * Find zero or more Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trades
     * const trades = await prisma.trades.findMany()
     * 
     * // Get first 10 Trades
     * const trades = await prisma.trades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradesWithIdOnly = await prisma.trades.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TradesFindManyArgs>(
      args?: SelectSubset<T, TradesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Trades>>, PrismaPromise<Array<TradesGetPayload<T>>>>

    /**
     * Create a Trades.
     * @param {TradesCreateArgs} args - Arguments to create a Trades.
     * @example
     * // Create one Trades
     * const Trades = await prisma.trades.create({
     *   data: {
     *     // ... data to create a Trades
     *   }
     * })
     * 
    **/
    create<T extends TradesCreateArgs>(
      args: SelectSubset<T, TradesCreateArgs>
    ): CheckSelect<T, Prisma__TradesClient<Trades>, Prisma__TradesClient<TradesGetPayload<T>>>

    /**
     * Create many Trades.
     *     @param {TradesCreateManyArgs} args - Arguments to create many Trades.
     *     @example
     *     // Create many Trades
     *     const trades = await prisma.trades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TradesCreateManyArgs>(
      args?: SelectSubset<T, TradesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Trades.
     * @param {TradesDeleteArgs} args - Arguments to delete one Trades.
     * @example
     * // Delete one Trades
     * const Trades = await prisma.trades.delete({
     *   where: {
     *     // ... filter to delete one Trades
     *   }
     * })
     * 
    **/
    delete<T extends TradesDeleteArgs>(
      args: SelectSubset<T, TradesDeleteArgs>
    ): CheckSelect<T, Prisma__TradesClient<Trades>, Prisma__TradesClient<TradesGetPayload<T>>>

    /**
     * Update one Trades.
     * @param {TradesUpdateArgs} args - Arguments to update one Trades.
     * @example
     * // Update one Trades
     * const trades = await prisma.trades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TradesUpdateArgs>(
      args: SelectSubset<T, TradesUpdateArgs>
    ): CheckSelect<T, Prisma__TradesClient<Trades>, Prisma__TradesClient<TradesGetPayload<T>>>

    /**
     * Delete zero or more Trades.
     * @param {TradesDeleteManyArgs} args - Arguments to filter Trades to delete.
     * @example
     * // Delete a few Trades
     * const { count } = await prisma.trades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TradesDeleteManyArgs>(
      args?: SelectSubset<T, TradesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trades
     * const trades = await prisma.trades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TradesUpdateManyArgs>(
      args: SelectSubset<T, TradesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Trades.
     * @param {TradesUpsertArgs} args - Arguments to update or create a Trades.
     * @example
     * // Update or create a Trades
     * const trades = await prisma.trades.upsert({
     *   create: {
     *     // ... data to create a Trades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trades we want to update
     *   }
     * })
    **/
    upsert<T extends TradesUpsertArgs>(
      args: SelectSubset<T, TradesUpsertArgs>
    ): CheckSelect<T, Prisma__TradesClient<Trades>, Prisma__TradesClient<TradesGetPayload<T>>>

    /**
     * Find one Trades that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TradesFindUniqueOrThrowArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TradesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TradesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TradesClient<Trades>, Prisma__TradesClient<TradesGetPayload<T>>>

    /**
     * Find the first Trades that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesFindFirstOrThrowArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TradesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TradesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TradesClient<Trades>, Prisma__TradesClient<TradesGetPayload<T>>>

    /**
     * Count the number of Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesCountArgs} args - Arguments to filter Trades to count.
     * @example
     * // Count the number of Trades
     * const count = await prisma.trades.count({
     *   where: {
     *     // ... the filter for the Trades we want to count
     *   }
     * })
    **/
    count<T extends TradesCountArgs>(
      args?: Subset<T, TradesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradesAggregateArgs>(args: Subset<T, TradesAggregateArgs>): PrismaPromise<GetTradesAggregateType<T>>

    /**
     * Group by Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradesGroupByArgs['orderBy'] }
        : { orderBy?: TradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Trades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TradesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Exchange<T extends ExchangesArgs = {}>(args?: Subset<T, ExchangesArgs>): CheckSelect<T, Prisma__ExchangesClient<Exchanges | Null>, Prisma__ExchangesClient<ExchangesGetPayload<T> | Null>>;

    Security<T extends SecuritiesArgs = {}>(args?: Subset<T, SecuritiesArgs>): CheckSelect<T, Prisma__SecuritiesClient<Securities | Null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | Null>>;

    Conditions<T extends ConditionsFindManyArgs = {}>(args?: Subset<T, ConditionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Conditions>| Null>, PrismaPromise<Array<ConditionsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Trades base type for findUnique actions
   */
  export type TradesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Trades
     * 
    **/
    select?: TradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TradesInclude | null
    /**
     * Filter, which Trades to fetch.
     * 
    **/
    where: TradesWhereUniqueInput
  }

  /**
   * Trades: findUnique
   */
  export interface TradesFindUniqueArgs extends TradesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Trades base type for findFirst actions
   */
  export type TradesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Trades
     * 
    **/
    select?: TradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TradesInclude | null
    /**
     * Filter, which Trades to fetch.
     * 
    **/
    where?: TradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     * 
    **/
    orderBy?: Enumerable<TradesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trades.
     * 
    **/
    cursor?: TradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trades.
     * 
    **/
    distinct?: Enumerable<TradesScalarFieldEnum>
  }

  /**
   * Trades: findFirst
   */
  export interface TradesFindFirstArgs extends TradesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Trades findMany
   */
  export type TradesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Trades
     * 
    **/
    select?: TradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TradesInclude | null
    /**
     * Filter, which Trades to fetch.
     * 
    **/
    where?: TradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trades to fetch.
     * 
    **/
    orderBy?: Enumerable<TradesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trades.
     * 
    **/
    cursor?: TradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trades from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trades.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TradesScalarFieldEnum>
  }


  /**
   * Trades create
   */
  export type TradesCreateArgs = {
    /**
     * Select specific fields to fetch from the Trades
     * 
    **/
    select?: TradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TradesInclude | null
    /**
     * The data needed to create a Trades.
     * 
    **/
    data: XOR<TradesCreateInput, TradesUncheckedCreateInput>
  }


  /**
   * Trades createMany
   */
  export type TradesCreateManyArgs = {
    /**
     * The data used to create many Trades.
     * 
    **/
    data: Enumerable<TradesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Trades update
   */
  export type TradesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Trades
     * 
    **/
    select?: TradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TradesInclude | null
    /**
     * The data needed to update a Trades.
     * 
    **/
    data: XOR<TradesUpdateInput, TradesUncheckedUpdateInput>
    /**
     * Choose, which Trades to update.
     * 
    **/
    where: TradesWhereUniqueInput
  }


  /**
   * Trades updateMany
   */
  export type TradesUpdateManyArgs = {
    /**
     * The data used to update Trades.
     * 
    **/
    data: XOR<TradesUpdateManyMutationInput, TradesUncheckedUpdateManyInput>
    /**
     * Filter which Trades to update
     * 
    **/
    where?: TradesWhereInput
  }


  /**
   * Trades upsert
   */
  export type TradesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Trades
     * 
    **/
    select?: TradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TradesInclude | null
    /**
     * The filter to search for the Trades to update in case it exists.
     * 
    **/
    where: TradesWhereUniqueInput
    /**
     * In case the Trades found by the `where` argument doesn't exist, create a new Trades with this data.
     * 
    **/
    create: XOR<TradesCreateInput, TradesUncheckedCreateInput>
    /**
     * In case the Trades was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TradesUpdateInput, TradesUncheckedUpdateInput>
  }


  /**
   * Trades delete
   */
  export type TradesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Trades
     * 
    **/
    select?: TradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TradesInclude | null
    /**
     * Filter which Trades to delete.
     * 
    **/
    where: TradesWhereUniqueInput
  }


  /**
   * Trades deleteMany
   */
  export type TradesDeleteManyArgs = {
    /**
     * Filter which Trades to delete
     * 
    **/
    where?: TradesWhereInput
  }


  /**
   * Trades: findUniqueOrThrow
   */
  export type TradesFindUniqueOrThrowArgs = TradesFindUniqueArgsBase
      

  /**
   * Trades: findFirstOrThrow
   */
  export type TradesFindFirstOrThrowArgs = TradesFindFirstArgsBase
      

  /**
   * Trades without action
   */
  export type TradesArgs = {
    /**
     * Select specific fields to fetch from the Trades
     * 
    **/
    select?: TradesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TradesInclude | null
  }



  /**
   * Model Quotes
   */


  export type AggregateQuotes = {
    _count: QuotesCountAggregateOutputType | null
    _avg: QuotesAvgAggregateOutputType | null
    _sum: QuotesSumAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  export type QuotesAvgAggregateOutputType = {
    id: number | null
    securityId: number | null
    bidExchangeId: number | null
    askExchangeId: number | null
    bidPrice: Decimal | null
    askPrice: Decimal | null
    bidSize: Decimal | null
    askSize: Decimal | null
  }

  export type QuotesSumAggregateOutputType = {
    id: number | null
    securityId: number | null
    bidExchangeId: number | null
    askExchangeId: number | null
    bidPrice: Decimal | null
    askPrice: Decimal | null
    bidSize: Decimal | null
    askSize: Decimal | null
  }

  export type QuotesMinAggregateOutputType = {
    id: number | null
    securityId: number | null
    bidExchangeId: number | null
    askExchangeId: number | null
    bidPrice: Decimal | null
    askPrice: Decimal | null
    bidSize: Decimal | null
    askSize: Decimal | null
    createdAt: Date | null
  }

  export type QuotesMaxAggregateOutputType = {
    id: number | null
    securityId: number | null
    bidExchangeId: number | null
    askExchangeId: number | null
    bidPrice: Decimal | null
    askPrice: Decimal | null
    bidSize: Decimal | null
    askSize: Decimal | null
    createdAt: Date | null
  }

  export type QuotesCountAggregateOutputType = {
    id: number
    securityId: number
    bidExchangeId: number
    askExchangeId: number
    bidPrice: number
    askPrice: number
    bidSize: number
    askSize: number
    createdAt: number
    _all: number
  }


  export type QuotesAvgAggregateInputType = {
    id?: true
    securityId?: true
    bidExchangeId?: true
    askExchangeId?: true
    bidPrice?: true
    askPrice?: true
    bidSize?: true
    askSize?: true
  }

  export type QuotesSumAggregateInputType = {
    id?: true
    securityId?: true
    bidExchangeId?: true
    askExchangeId?: true
    bidPrice?: true
    askPrice?: true
    bidSize?: true
    askSize?: true
  }

  export type QuotesMinAggregateInputType = {
    id?: true
    securityId?: true
    bidExchangeId?: true
    askExchangeId?: true
    bidPrice?: true
    askPrice?: true
    bidSize?: true
    askSize?: true
    createdAt?: true
  }

  export type QuotesMaxAggregateInputType = {
    id?: true
    securityId?: true
    bidExchangeId?: true
    askExchangeId?: true
    bidPrice?: true
    askPrice?: true
    bidSize?: true
    askSize?: true
    createdAt?: true
  }

  export type QuotesCountAggregateInputType = {
    id?: true
    securityId?: true
    bidExchangeId?: true
    askExchangeId?: true
    bidPrice?: true
    askPrice?: true
    bidSize?: true
    askSize?: true
    createdAt?: true
    _all?: true
  }

  export type QuotesAggregateArgs = {
    /**
     * Filter which Quotes to aggregate.
     * 
    **/
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuotesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotesMaxAggregateInputType
  }

  export type GetQuotesAggregateType<T extends QuotesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotes[P]>
      : GetScalarType<T[P], AggregateQuotes[P]>
  }




  export type QuotesGroupByArgs = {
    where?: QuotesWhereInput
    orderBy?: Enumerable<QuotesOrderByWithAggregationInput>
    by: Array<QuotesScalarFieldEnum>
    having?: QuotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotesCountAggregateInputType | true
    _avg?: QuotesAvgAggregateInputType
    _sum?: QuotesSumAggregateInputType
    _min?: QuotesMinAggregateInputType
    _max?: QuotesMaxAggregateInputType
  }


  export type QuotesGroupByOutputType = {
    id: number
    securityId: number
    bidExchangeId: number
    askExchangeId: number
    bidPrice: Decimal | null
    askPrice: Decimal | null
    bidSize: Decimal | null
    askSize: Decimal | null
    createdAt: Date
    _count: QuotesCountAggregateOutputType | null
    _avg: QuotesAvgAggregateOutputType | null
    _sum: QuotesSumAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  type GetQuotesGroupByPayload<T extends QuotesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotesGroupByOutputType[P]>
            : GetScalarType<T[P], QuotesGroupByOutputType[P]>
        }
      >
    >


  export type QuotesSelect = {
    id?: boolean
    securityId?: boolean
    bidExchangeId?: boolean
    askExchangeId?: boolean
    bidPrice?: boolean
    askPrice?: boolean
    bidSize?: boolean
    askSize?: boolean
    createdAt?: boolean
    AskExchange?: boolean | ExchangesArgs
    BidExchange?: boolean | ExchangesArgs
    Security?: boolean | SecuritiesArgs
    Conditions?: boolean | ConditionsFindManyArgs
    _count?: boolean | QuotesCountOutputTypeArgs
  }

  export type QuotesInclude = {
    AskExchange?: boolean | ExchangesArgs
    BidExchange?: boolean | ExchangesArgs
    Security?: boolean | SecuritiesArgs
    Conditions?: boolean | ConditionsFindManyArgs
    _count?: boolean | QuotesCountOutputTypeArgs
  }

  export type QuotesGetPayload<
    S extends boolean | null | undefined | QuotesArgs,
    U = keyof S
      > = S extends true
        ? Quotes
    : S extends undefined
    ? never
    : S extends QuotesArgs | QuotesFindManyArgs
    ?'include' extends U
    ? Quotes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'AskExchange' ? ExchangesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'BidExchange' ? ExchangesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Conditions' ? Array < ConditionsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? QuotesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'AskExchange' ? ExchangesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'BidExchange' ? ExchangesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Security' ? SecuritiesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Conditions' ? Array < ConditionsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? QuotesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Quotes ? Quotes[P] : never
  } 
    : Quotes
  : Quotes


  type QuotesCountArgs = Merge<
    Omit<QuotesFindManyArgs, 'select' | 'include'> & {
      select?: QuotesCountAggregateInputType | true
    }
  >

  export interface QuotesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Quotes that matches the filter.
     * @param {QuotesFindUniqueArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuotesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuotesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Quotes'> extends True ? CheckSelect<T, Prisma__QuotesClient<Quotes>, Prisma__QuotesClient<QuotesGetPayload<T>>> : CheckSelect<T, Prisma__QuotesClient<Quotes | null, null>, Prisma__QuotesClient<QuotesGetPayload<T> | null, null>>

    /**
     * Find the first Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindFirstArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuotesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuotesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Quotes'> extends True ? CheckSelect<T, Prisma__QuotesClient<Quotes>, Prisma__QuotesClient<QuotesGetPayload<T>>> : CheckSelect<T, Prisma__QuotesClient<Quotes | null, null>, Prisma__QuotesClient<QuotesGetPayload<T> | null, null>>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quotes.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotesWithIdOnly = await prisma.quotes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuotesFindManyArgs>(
      args?: SelectSubset<T, QuotesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Quotes>>, PrismaPromise<Array<QuotesGetPayload<T>>>>

    /**
     * Create a Quotes.
     * @param {QuotesCreateArgs} args - Arguments to create a Quotes.
     * @example
     * // Create one Quotes
     * const Quotes = await prisma.quotes.create({
     *   data: {
     *     // ... data to create a Quotes
     *   }
     * })
     * 
    **/
    create<T extends QuotesCreateArgs>(
      args: SelectSubset<T, QuotesCreateArgs>
    ): CheckSelect<T, Prisma__QuotesClient<Quotes>, Prisma__QuotesClient<QuotesGetPayload<T>>>

    /**
     * Create many Quotes.
     *     @param {QuotesCreateManyArgs} args - Arguments to create many Quotes.
     *     @example
     *     // Create many Quotes
     *     const quotes = await prisma.quotes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuotesCreateManyArgs>(
      args?: SelectSubset<T, QuotesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Quotes.
     * @param {QuotesDeleteArgs} args - Arguments to delete one Quotes.
     * @example
     * // Delete one Quotes
     * const Quotes = await prisma.quotes.delete({
     *   where: {
     *     // ... filter to delete one Quotes
     *   }
     * })
     * 
    **/
    delete<T extends QuotesDeleteArgs>(
      args: SelectSubset<T, QuotesDeleteArgs>
    ): CheckSelect<T, Prisma__QuotesClient<Quotes>, Prisma__QuotesClient<QuotesGetPayload<T>>>

    /**
     * Update one Quotes.
     * @param {QuotesUpdateArgs} args - Arguments to update one Quotes.
     * @example
     * // Update one Quotes
     * const quotes = await prisma.quotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuotesUpdateArgs>(
      args: SelectSubset<T, QuotesUpdateArgs>
    ): CheckSelect<T, Prisma__QuotesClient<Quotes>, Prisma__QuotesClient<QuotesGetPayload<T>>>

    /**
     * Delete zero or more Quotes.
     * @param {QuotesDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuotesDeleteManyArgs>(
      args?: SelectSubset<T, QuotesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quotes = await prisma.quotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuotesUpdateManyArgs>(
      args: SelectSubset<T, QuotesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Quotes.
     * @param {QuotesUpsertArgs} args - Arguments to update or create a Quotes.
     * @example
     * // Update or create a Quotes
     * const quotes = await prisma.quotes.upsert({
     *   create: {
     *     // ... data to create a Quotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotes we want to update
     *   }
     * })
    **/
    upsert<T extends QuotesUpsertArgs>(
      args: SelectSubset<T, QuotesUpsertArgs>
    ): CheckSelect<T, Prisma__QuotesClient<Quotes>, Prisma__QuotesClient<QuotesGetPayload<T>>>

    /**
     * Find one Quotes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {QuotesFindUniqueOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuotesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuotesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__QuotesClient<Quotes>, Prisma__QuotesClient<QuotesGetPayload<T>>>

    /**
     * Find the first Quotes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindFirstOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuotesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuotesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__QuotesClient<Quotes>, Prisma__QuotesClient<QuotesGetPayload<T>>>

    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quotes.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuotesCountArgs>(
      args?: Subset<T, QuotesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotesAggregateArgs>(args: Subset<T, QuotesAggregateArgs>): PrismaPromise<GetQuotesAggregateType<T>>

    /**
     * Group by Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotesGroupByArgs['orderBy'] }
        : { orderBy?: QuotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuotesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    AskExchange<T extends ExchangesArgs = {}>(args?: Subset<T, ExchangesArgs>): CheckSelect<T, Prisma__ExchangesClient<Exchanges | Null>, Prisma__ExchangesClient<ExchangesGetPayload<T> | Null>>;

    BidExchange<T extends ExchangesArgs = {}>(args?: Subset<T, ExchangesArgs>): CheckSelect<T, Prisma__ExchangesClient<Exchanges | Null>, Prisma__ExchangesClient<ExchangesGetPayload<T> | Null>>;

    Security<T extends SecuritiesArgs = {}>(args?: Subset<T, SecuritiesArgs>): CheckSelect<T, Prisma__SecuritiesClient<Securities | Null>, Prisma__SecuritiesClient<SecuritiesGetPayload<T> | Null>>;

    Conditions<T extends ConditionsFindManyArgs = {}>(args?: Subset<T, ConditionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Conditions>| Null>, PrismaPromise<Array<ConditionsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Quotes base type for findUnique actions
   */
  export type QuotesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Quotes
     * 
    **/
    select?: QuotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuotesInclude | null
    /**
     * Filter, which Quotes to fetch.
     * 
    **/
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes: findUnique
   */
  export interface QuotesFindUniqueArgs extends QuotesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Quotes base type for findFirst actions
   */
  export type QuotesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Quotes
     * 
    **/
    select?: QuotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuotesInclude | null
    /**
     * Filter, which Quotes to fetch.
     * 
    **/
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuotesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     * 
    **/
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     * 
    **/
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }

  /**
   * Quotes: findFirst
   */
  export interface QuotesFindFirstArgs extends QuotesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Quotes findMany
   */
  export type QuotesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Quotes
     * 
    **/
    select?: QuotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuotesInclude | null
    /**
     * Filter, which Quotes to fetch.
     * 
    **/
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     * 
    **/
    orderBy?: Enumerable<QuotesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     * 
    **/
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }


  /**
   * Quotes create
   */
  export type QuotesCreateArgs = {
    /**
     * Select specific fields to fetch from the Quotes
     * 
    **/
    select?: QuotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuotesInclude | null
    /**
     * The data needed to create a Quotes.
     * 
    **/
    data: XOR<QuotesCreateInput, QuotesUncheckedCreateInput>
  }


  /**
   * Quotes createMany
   */
  export type QuotesCreateManyArgs = {
    /**
     * The data used to create many Quotes.
     * 
    **/
    data: Enumerable<QuotesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Quotes update
   */
  export type QuotesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Quotes
     * 
    **/
    select?: QuotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuotesInclude | null
    /**
     * The data needed to update a Quotes.
     * 
    **/
    data: XOR<QuotesUpdateInput, QuotesUncheckedUpdateInput>
    /**
     * Choose, which Quotes to update.
     * 
    **/
    where: QuotesWhereUniqueInput
  }


  /**
   * Quotes updateMany
   */
  export type QuotesUpdateManyArgs = {
    /**
     * The data used to update Quotes.
     * 
    **/
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     * 
    **/
    where?: QuotesWhereInput
  }


  /**
   * Quotes upsert
   */
  export type QuotesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Quotes
     * 
    **/
    select?: QuotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuotesInclude | null
    /**
     * The filter to search for the Quotes to update in case it exists.
     * 
    **/
    where: QuotesWhereUniqueInput
    /**
     * In case the Quotes found by the `where` argument doesn't exist, create a new Quotes with this data.
     * 
    **/
    create: XOR<QuotesCreateInput, QuotesUncheckedCreateInput>
    /**
     * In case the Quotes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuotesUpdateInput, QuotesUncheckedUpdateInput>
  }


  /**
   * Quotes delete
   */
  export type QuotesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Quotes
     * 
    **/
    select?: QuotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuotesInclude | null
    /**
     * Filter which Quotes to delete.
     * 
    **/
    where: QuotesWhereUniqueInput
  }


  /**
   * Quotes deleteMany
   */
  export type QuotesDeleteManyArgs = {
    /**
     * Filter which Quotes to delete
     * 
    **/
    where?: QuotesWhereInput
  }


  /**
   * Quotes: findUniqueOrThrow
   */
  export type QuotesFindUniqueOrThrowArgs = QuotesFindUniqueArgsBase
      

  /**
   * Quotes: findFirstOrThrow
   */
  export type QuotesFindFirstOrThrowArgs = QuotesFindFirstArgsBase
      

  /**
   * Quotes without action
   */
  export type QuotesArgs = {
    /**
     * Select specific fields to fetch from the Quotes
     * 
    **/
    select?: QuotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuotesInclude | null
  }



  /**
   * Model Conditions
   */


  export type AggregateConditions = {
    _count: ConditionsCountAggregateOutputType | null
    _avg: ConditionsAvgAggregateOutputType | null
    _sum: ConditionsSumAggregateOutputType | null
    _min: ConditionsMinAggregateOutputType | null
    _max: ConditionsMaxAggregateOutputType | null
  }

  export type ConditionsAvgAggregateOutputType = {
    id: number | null
    tradeId: number | null
    quoteId: number | null
    modifier: number | null
  }

  export type ConditionsSumAggregateOutputType = {
    id: number | null
    tradeId: number | null
    quoteId: number | null
    modifier: number | null
  }

  export type ConditionsMinAggregateOutputType = {
    id: number | null
    tradeId: number | null
    quoteId: number | null
    condition: string | null
    modifier: number | null
    SIPMapping: string | null
    createdAt: Date | null
  }

  export type ConditionsMaxAggregateOutputType = {
    id: number | null
    tradeId: number | null
    quoteId: number | null
    condition: string | null
    modifier: number | null
    SIPMapping: string | null
    createdAt: Date | null
  }

  export type ConditionsCountAggregateOutputType = {
    id: number
    tradeId: number
    quoteId: number
    condition: number
    modifier: number
    SIPMapping: number
    createdAt: number
    _all: number
  }


  export type ConditionsAvgAggregateInputType = {
    id?: true
    tradeId?: true
    quoteId?: true
    modifier?: true
  }

  export type ConditionsSumAggregateInputType = {
    id?: true
    tradeId?: true
    quoteId?: true
    modifier?: true
  }

  export type ConditionsMinAggregateInputType = {
    id?: true
    tradeId?: true
    quoteId?: true
    condition?: true
    modifier?: true
    SIPMapping?: true
    createdAt?: true
  }

  export type ConditionsMaxAggregateInputType = {
    id?: true
    tradeId?: true
    quoteId?: true
    condition?: true
    modifier?: true
    SIPMapping?: true
    createdAt?: true
  }

  export type ConditionsCountAggregateInputType = {
    id?: true
    tradeId?: true
    quoteId?: true
    condition?: true
    modifier?: true
    SIPMapping?: true
    createdAt?: true
    _all?: true
  }

  export type ConditionsAggregateArgs = {
    /**
     * Filter which Conditions to aggregate.
     * 
    **/
    where?: ConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conditions
    **/
    _count?: true | ConditionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConditionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConditionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionsMaxAggregateInputType
  }

  export type GetConditionsAggregateType<T extends ConditionsAggregateArgs> = {
        [P in keyof T & keyof AggregateConditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConditions[P]>
      : GetScalarType<T[P], AggregateConditions[P]>
  }




  export type ConditionsGroupByArgs = {
    where?: ConditionsWhereInput
    orderBy?: Enumerable<ConditionsOrderByWithAggregationInput>
    by: Array<ConditionsScalarFieldEnum>
    having?: ConditionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionsCountAggregateInputType | true
    _avg?: ConditionsAvgAggregateInputType
    _sum?: ConditionsSumAggregateInputType
    _min?: ConditionsMinAggregateInputType
    _max?: ConditionsMaxAggregateInputType
  }


  export type ConditionsGroupByOutputType = {
    id: number
    tradeId: number
    quoteId: number
    condition: string
    modifier: number
    SIPMapping: string
    createdAt: Date
    _count: ConditionsCountAggregateOutputType | null
    _avg: ConditionsAvgAggregateOutputType | null
    _sum: ConditionsSumAggregateOutputType | null
    _min: ConditionsMinAggregateOutputType | null
    _max: ConditionsMaxAggregateOutputType | null
  }

  type GetConditionsGroupByPayload<T extends ConditionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ConditionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionsGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionsGroupByOutputType[P]>
        }
      >
    >


  export type ConditionsSelect = {
    id?: boolean
    tradeId?: boolean
    quoteId?: boolean
    condition?: boolean
    modifier?: boolean
    SIPMapping?: boolean
    createdAt?: boolean
    Trade?: boolean | TradesArgs
    Quote?: boolean | QuotesArgs
  }

  export type ConditionsInclude = {
    Trade?: boolean | TradesArgs
    Quote?: boolean | QuotesArgs
  }

  export type ConditionsGetPayload<
    S extends boolean | null | undefined | ConditionsArgs,
    U = keyof S
      > = S extends true
        ? Conditions
    : S extends undefined
    ? never
    : S extends ConditionsArgs | ConditionsFindManyArgs
    ?'include' extends U
    ? Conditions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Trade' ? TradesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'Quote' ? QuotesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Trade' ? TradesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'Quote' ? QuotesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Conditions ? Conditions[P] : never
  } 
    : Conditions
  : Conditions


  type ConditionsCountArgs = Merge<
    Omit<ConditionsFindManyArgs, 'select' | 'include'> & {
      select?: ConditionsCountAggregateInputType | true
    }
  >

  export interface ConditionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Conditions that matches the filter.
     * @param {ConditionsFindUniqueArgs} args - Arguments to find a Conditions
     * @example
     * // Get one Conditions
     * const conditions = await prisma.conditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConditionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConditionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Conditions'> extends True ? CheckSelect<T, Prisma__ConditionsClient<Conditions>, Prisma__ConditionsClient<ConditionsGetPayload<T>>> : CheckSelect<T, Prisma__ConditionsClient<Conditions | null, null>, Prisma__ConditionsClient<ConditionsGetPayload<T> | null, null>>

    /**
     * Find the first Conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsFindFirstArgs} args - Arguments to find a Conditions
     * @example
     * // Get one Conditions
     * const conditions = await prisma.conditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConditionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConditionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Conditions'> extends True ? CheckSelect<T, Prisma__ConditionsClient<Conditions>, Prisma__ConditionsClient<ConditionsGetPayload<T>>> : CheckSelect<T, Prisma__ConditionsClient<Conditions | null, null>, Prisma__ConditionsClient<ConditionsGetPayload<T> | null, null>>

    /**
     * Find zero or more Conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conditions
     * const conditions = await prisma.conditions.findMany()
     * 
     * // Get first 10 Conditions
     * const conditions = await prisma.conditions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionsWithIdOnly = await prisma.conditions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConditionsFindManyArgs>(
      args?: SelectSubset<T, ConditionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Conditions>>, PrismaPromise<Array<ConditionsGetPayload<T>>>>

    /**
     * Create a Conditions.
     * @param {ConditionsCreateArgs} args - Arguments to create a Conditions.
     * @example
     * // Create one Conditions
     * const Conditions = await prisma.conditions.create({
     *   data: {
     *     // ... data to create a Conditions
     *   }
     * })
     * 
    **/
    create<T extends ConditionsCreateArgs>(
      args: SelectSubset<T, ConditionsCreateArgs>
    ): CheckSelect<T, Prisma__ConditionsClient<Conditions>, Prisma__ConditionsClient<ConditionsGetPayload<T>>>

    /**
     * Create many Conditions.
     *     @param {ConditionsCreateManyArgs} args - Arguments to create many Conditions.
     *     @example
     *     // Create many Conditions
     *     const conditions = await prisma.conditions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConditionsCreateManyArgs>(
      args?: SelectSubset<T, ConditionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Conditions.
     * @param {ConditionsDeleteArgs} args - Arguments to delete one Conditions.
     * @example
     * // Delete one Conditions
     * const Conditions = await prisma.conditions.delete({
     *   where: {
     *     // ... filter to delete one Conditions
     *   }
     * })
     * 
    **/
    delete<T extends ConditionsDeleteArgs>(
      args: SelectSubset<T, ConditionsDeleteArgs>
    ): CheckSelect<T, Prisma__ConditionsClient<Conditions>, Prisma__ConditionsClient<ConditionsGetPayload<T>>>

    /**
     * Update one Conditions.
     * @param {ConditionsUpdateArgs} args - Arguments to update one Conditions.
     * @example
     * // Update one Conditions
     * const conditions = await prisma.conditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConditionsUpdateArgs>(
      args: SelectSubset<T, ConditionsUpdateArgs>
    ): CheckSelect<T, Prisma__ConditionsClient<Conditions>, Prisma__ConditionsClient<ConditionsGetPayload<T>>>

    /**
     * Delete zero or more Conditions.
     * @param {ConditionsDeleteManyArgs} args - Arguments to filter Conditions to delete.
     * @example
     * // Delete a few Conditions
     * const { count } = await prisma.conditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConditionsDeleteManyArgs>(
      args?: SelectSubset<T, ConditionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conditions
     * const conditions = await prisma.conditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConditionsUpdateManyArgs>(
      args: SelectSubset<T, ConditionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Conditions.
     * @param {ConditionsUpsertArgs} args - Arguments to update or create a Conditions.
     * @example
     * // Update or create a Conditions
     * const conditions = await prisma.conditions.upsert({
     *   create: {
     *     // ... data to create a Conditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conditions we want to update
     *   }
     * })
    **/
    upsert<T extends ConditionsUpsertArgs>(
      args: SelectSubset<T, ConditionsUpsertArgs>
    ): CheckSelect<T, Prisma__ConditionsClient<Conditions>, Prisma__ConditionsClient<ConditionsGetPayload<T>>>

    /**
     * Find one Conditions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ConditionsFindUniqueOrThrowArgs} args - Arguments to find a Conditions
     * @example
     * // Get one Conditions
     * const conditions = await prisma.conditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConditionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ConditionsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ConditionsClient<Conditions>, Prisma__ConditionsClient<ConditionsGetPayload<T>>>

    /**
     * Find the first Conditions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsFindFirstOrThrowArgs} args - Arguments to find a Conditions
     * @example
     * // Get one Conditions
     * const conditions = await prisma.conditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConditionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ConditionsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ConditionsClient<Conditions>, Prisma__ConditionsClient<ConditionsGetPayload<T>>>

    /**
     * Count the number of Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsCountArgs} args - Arguments to filter Conditions to count.
     * @example
     * // Count the number of Conditions
     * const count = await prisma.conditions.count({
     *   where: {
     *     // ... the filter for the Conditions we want to count
     *   }
     * })
    **/
    count<T extends ConditionsCountArgs>(
      args?: Subset<T, ConditionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionsAggregateArgs>(args: Subset<T, ConditionsAggregateArgs>): PrismaPromise<GetConditionsAggregateType<T>>

    /**
     * Group by Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionsGroupByArgs['orderBy'] }
        : { orderBy?: ConditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Conditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConditionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Trade<T extends TradesArgs = {}>(args?: Subset<T, TradesArgs>): CheckSelect<T, Prisma__TradesClient<Trades | Null>, Prisma__TradesClient<TradesGetPayload<T> | Null>>;

    Quote<T extends QuotesArgs = {}>(args?: Subset<T, QuotesArgs>): CheckSelect<T, Prisma__QuotesClient<Quotes | Null>, Prisma__QuotesClient<QuotesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Conditions base type for findUnique actions
   */
  export type ConditionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Conditions
     * 
    **/
    select?: ConditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionsInclude | null
    /**
     * Filter, which Conditions to fetch.
     * 
    **/
    where: ConditionsWhereUniqueInput
  }

  /**
   * Conditions: findUnique
   */
  export interface ConditionsFindUniqueArgs extends ConditionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Conditions base type for findFirst actions
   */
  export type ConditionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Conditions
     * 
    **/
    select?: ConditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionsInclude | null
    /**
     * Filter, which Conditions to fetch.
     * 
    **/
    where?: ConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     * 
    **/
    cursor?: ConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     * 
    **/
    distinct?: Enumerable<ConditionsScalarFieldEnum>
  }

  /**
   * Conditions: findFirst
   */
  export interface ConditionsFindFirstArgs extends ConditionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Conditions findMany
   */
  export type ConditionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Conditions
     * 
    **/
    select?: ConditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionsInclude | null
    /**
     * Filter, which Conditions to fetch.
     * 
    **/
    where?: ConditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     * 
    **/
    orderBy?: Enumerable<ConditionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conditions.
     * 
    **/
    cursor?: ConditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConditionsScalarFieldEnum>
  }


  /**
   * Conditions create
   */
  export type ConditionsCreateArgs = {
    /**
     * Select specific fields to fetch from the Conditions
     * 
    **/
    select?: ConditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionsInclude | null
    /**
     * The data needed to create a Conditions.
     * 
    **/
    data: XOR<ConditionsCreateInput, ConditionsUncheckedCreateInput>
  }


  /**
   * Conditions createMany
   */
  export type ConditionsCreateManyArgs = {
    /**
     * The data used to create many Conditions.
     * 
    **/
    data: Enumerable<ConditionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Conditions update
   */
  export type ConditionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Conditions
     * 
    **/
    select?: ConditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionsInclude | null
    /**
     * The data needed to update a Conditions.
     * 
    **/
    data: XOR<ConditionsUpdateInput, ConditionsUncheckedUpdateInput>
    /**
     * Choose, which Conditions to update.
     * 
    **/
    where: ConditionsWhereUniqueInput
  }


  /**
   * Conditions updateMany
   */
  export type ConditionsUpdateManyArgs = {
    /**
     * The data used to update Conditions.
     * 
    **/
    data: XOR<ConditionsUpdateManyMutationInput, ConditionsUncheckedUpdateManyInput>
    /**
     * Filter which Conditions to update
     * 
    **/
    where?: ConditionsWhereInput
  }


  /**
   * Conditions upsert
   */
  export type ConditionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Conditions
     * 
    **/
    select?: ConditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionsInclude | null
    /**
     * The filter to search for the Conditions to update in case it exists.
     * 
    **/
    where: ConditionsWhereUniqueInput
    /**
     * In case the Conditions found by the `where` argument doesn't exist, create a new Conditions with this data.
     * 
    **/
    create: XOR<ConditionsCreateInput, ConditionsUncheckedCreateInput>
    /**
     * In case the Conditions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ConditionsUpdateInput, ConditionsUncheckedUpdateInput>
  }


  /**
   * Conditions delete
   */
  export type ConditionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Conditions
     * 
    **/
    select?: ConditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionsInclude | null
    /**
     * Filter which Conditions to delete.
     * 
    **/
    where: ConditionsWhereUniqueInput
  }


  /**
   * Conditions deleteMany
   */
  export type ConditionsDeleteManyArgs = {
    /**
     * Filter which Conditions to delete
     * 
    **/
    where?: ConditionsWhereInput
  }


  /**
   * Conditions: findUniqueOrThrow
   */
  export type ConditionsFindUniqueOrThrowArgs = ConditionsFindUniqueArgsBase
      

  /**
   * Conditions: findFirstOrThrow
   */
  export type ConditionsFindFirstOrThrowArgs = ConditionsFindFirstArgsBase
      

  /**
   * Conditions without action
   */
  export type ConditionsArgs = {
    /**
     * Select specific fields to fetch from the Conditions
     * 
    **/
    select?: ConditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConditionsInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    accountId: 'accountId',
    marketValue: 'marketValue',
    buyingPower: 'buyingPower',
    cash: 'cash',
    currency: 'currency',
    daytradeCount: 'daytradeCount',
    daytradeBuyingPower: 'daytradeBuyingPower',
    regulationTBuyingPower: 'regulationTBuyingPower',
    initialMargin: 'initialMargin',
    lastMaintenanceMargin: 'lastMaintenanceMargin',
    longMarketValue: 'longMarketValue',
    shortMarketValue: 'shortMarketValue',
    maintenanceMargin: 'maintenanceMargin',
    multiplier: 'multiplier',
    sma: 'sma',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const AmeritradeEventsScalarFieldEnum: {
    id: 'id',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmeritradeEventsScalarFieldEnum = (typeof AmeritradeEventsScalarFieldEnum)[keyof typeof AmeritradeEventsScalarFieldEnum]


  export const AmeritradeTokensScalarFieldEnum: {
    id: 'id',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmeritradeTokensScalarFieldEnum = (typeof AmeritradeTokensScalarFieldEnum)[keyof typeof AmeritradeTokensScalarFieldEnum]


  export const BackTestingScalarFieldEnum: {
    id: 'id',
    strategy: 'strategy',
    strategyParameters: 'strategyParameters',
    startDate: 'startDate',
    endDate: 'endDate',
    resultLog: 'resultLog',
    marginPercentage: 'marginPercentage',
    averageInterestRate: 'averageInterestRate',
    finalBalance: 'finalBalance',
    profits: 'profits',
    losses: 'losses',
    highestInterestDay: 'highestInterestDay',
    lowestInterestDay: 'lowestInterestDay',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    code: 'code',
    unrealizedProfit: 'unrealizedProfit'
  };

  export type BackTestingScalarFieldEnum = (typeof BackTestingScalarFieldEnum)[keyof typeof BackTestingScalarFieldEnum]


  export const ConditionsScalarFieldEnum: {
    id: 'id',
    tradeId: 'tradeId',
    quoteId: 'quoteId',
    condition: 'condition',
    modifier: 'modifier',
    SIPMapping: 'SIPMapping',
    createdAt: 'createdAt'
  };

  export type ConditionsScalarFieldEnum = (typeof ConditionsScalarFieldEnum)[keyof typeof ConditionsScalarFieldEnum]


  export const ExchangesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    assetClass: 'assetClass',
    locale: 'locale',
    acronym: 'acronym',
    mic: 'mic',
    operatingMic: 'operatingMic',
    participantId: 'participantId',
    url: 'url'
  };

  export type ExchangesScalarFieldEnum = (typeof ExchangesScalarFieldEnum)[keyof typeof ExchangesScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    name: 'name'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    securityId: 'securityId',
    strategyName: 'strategyName',
    accountId: 'accountId',
    symbol: 'symbol',
    name: 'name',
    type: 'type',
    timeInForce: 'timeInForce',
    quantity: 'quantity',
    filledQuantity: 'filledQuantity',
    filledTime: 'filledTime',
    stopPrice: 'stopPrice',
    limitPrice: 'limitPrice',
    filledAveragePrice: 'filledAveragePrice',
    status: 'status',
    orderType: 'orderType',
    trailAmount: 'trailAmount',
    extendedHours: 'extendedHours',
    submittedAt: 'submittedAt',
    expiredAt: 'expiredAt',
    canceledAt: 'canceledAt',
    failedAt: 'failedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const PositionOrdersScalarFieldEnum: {
    positionId: 'positionId',
    orderId: 'orderId',
    intent: 'intent',
    createdAt: 'createdAt'
  };

  export type PositionOrdersScalarFieldEnum = (typeof PositionOrdersScalarFieldEnum)[keyof typeof PositionOrdersScalarFieldEnum]


  export const PositionsScalarFieldEnum: {
    id: 'id',
    price: 'price',
    securityId: 'securityId',
    strategyName: 'strategyName',
    name: 'name',
    accountId: 'accountId',
    quantity: 'quantity',
    marketValue: 'marketValue',
    symbol: 'symbol',
    exchange: 'exchange',
    positionPercent: 'positionPercent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    type: 'type',
    sellLock: 'sellLock'
  };

  export type PositionsScalarFieldEnum = (typeof PositionsScalarFieldEnum)[keyof typeof PositionsScalarFieldEnum]


  export const PreferencesScalarFieldEnum: {
    id: 'id',
    singleTradeRiskLevel: 'singleTradeRiskLevel',
    allTradeRiskLevel: 'allTradeRiskLevel',
    singleTradeVolatilityLevel: 'singleTradeVolatilityLevel',
    allTradeVolatilityLevel: 'allTradeVolatilityLevel',
    lowestStockPrice: 'lowestStockPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PreferencesScalarFieldEnum = (typeof PreferencesScalarFieldEnum)[keyof typeof PreferencesScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const QuotesScalarFieldEnum: {
    id: 'id',
    securityId: 'securityId',
    bidExchangeId: 'bidExchangeId',
    askExchangeId: 'askExchangeId',
    bidPrice: 'bidPrice',
    askPrice: 'askPrice',
    bidSize: 'bidSize',
    askSize: 'askSize',
    createdAt: 'createdAt'
  };

  export type QuotesScalarFieldEnum = (typeof QuotesScalarFieldEnum)[keyof typeof QuotesScalarFieldEnum]


  export const SectorDailyScalarFieldEnum: {
    id: 'id',
    sectorId: 'sectorId',
    calendarDate: 'calendarDate',
    realtimeReturn: 'realtimeReturn',
    oneDayReturn: 'oneDayReturn',
    fiveDayReturn: 'fiveDayReturn',
    oneMonthReturn: 'oneMonthReturn',
    threeMonthReturn: 'threeMonthReturn',
    oneYearReturn: 'oneYearReturn',
    threeYearReturn: 'threeYearReturn',
    fiveYearReturn: 'fiveYearReturn',
    tenYearReturn: 'tenYearReturn',
    ytdReturn: 'ytdReturn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectorDailyScalarFieldEnum = (typeof SectorDailyScalarFieldEnum)[keyof typeof SectorDailyScalarFieldEnum]


  export const SectorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectorsScalarFieldEnum = (typeof SectorsScalarFieldEnum)[keyof typeof SectorsScalarFieldEnum]


  export const SecuritiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    symbol: 'symbol',
    cusip: 'cusip',
    exchange: 'exchange',
    securityTypeId: 'securityTypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    marketCap: 'marketCap',
    companyName: 'companyName',
    sector: 'sector',
    active: 'active',
    delistedCalendarDate: 'delistedCalendarDate',
    companyDescription: 'companyDescription',
    url: 'url',
    sharesOutstanding: 'sharesOutstanding',
    numberOfEmployees: 'numberOfEmployees'
  };

  export type SecuritiesScalarFieldEnum = (typeof SecuritiesScalarFieldEnum)[keyof typeof SecuritiesScalarFieldEnum]


  export const SecurityDailyScalarFieldEnum: {
    id: 'id',
    securityId: 'securityId',
    open: 'open',
    high: 'high',
    low: 'low',
    close: 'close',
    adjustedClose: 'adjustedClose',
    marketCap: 'marketCap',
    enterpriseValue: 'enterpriseValue',
    peRatio: 'peRatio',
    pbRatio: 'pbRatio',
    trailingOneYearPegRatio: 'trailingOneYearPegRatio',
    dividendAmount: 'dividendAmount',
    splitCoefficient: 'splitCoefficient',
    volume: 'volume',
    adjusted: 'adjusted',
    calendarDate: 'calendarDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityDailyScalarFieldEnum = (typeof SecurityDailyScalarFieldEnum)[keyof typeof SecurityDailyScalarFieldEnum]


  export const SecurityDividendsScalarFieldEnum: {
    id: 'id',
    securityId: 'securityId',
    expirationDate: 'expirationDate',
    paymentDate: 'paymentDate',
    recordDate: 'recordDate',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecurityDividendsScalarFieldEnum = (typeof SecurityDividendsScalarFieldEnum)[keyof typeof SecurityDividendsScalarFieldEnum]


  export const SecurityIndexTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type SecurityIndexTypesScalarFieldEnum = (typeof SecurityIndexTypesScalarFieldEnum)[keyof typeof SecurityIndexTypesScalarFieldEnum]


  export const SecurityMinutelyScalarFieldEnum: {
    securityId: 'securityId',
    calendarDate: 'calendarDate',
    minute: 'minute',
    label: 'label',
    open: 'open',
    close: 'close',
    high: 'high',
    low: 'low',
    average: 'average',
    volume: 'volume',
    notional: 'notional',
    numberOfTrades: 'numberOfTrades',
    marketHigh: 'marketHigh',
    marketLow: 'marketLow',
    marketAverage: 'marketAverage',
    marketVolume: 'marketVolume',
    marketNotional: 'marketNotional',
    marketNumberOfTrades: 'marketNumberOfTrades',
    marketOpen: 'marketOpen',
    marketClose: 'marketClose',
    changeOverTime: 'changeOverTime',
    marketChangeOverTime: 'marketChangeOverTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dateTime: 'dateTime'
  };

  export type SecurityMinutelyScalarFieldEnum = (typeof SecurityMinutelyScalarFieldEnum)[keyof typeof SecurityMinutelyScalarFieldEnum]


  export const SecuritySecondlyScalarFieldEnum: {
    calendarDate: 'calendarDate',
    securityId: 'securityId',
    open: 'open',
    close: 'close',
    high: 'high',
    low: 'low',
    average: 'average',
    volume: 'volume',
    notional: 'notional',
    numberOfTrades: 'numberOfTrades',
    changeOverTime: 'changeOverTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SecuritySecondlyScalarFieldEnum = (typeof SecuritySecondlyScalarFieldEnum)[keyof typeof SecuritySecondlyScalarFieldEnum]


  export const SecuritySplitsScalarFieldEnum: {
    id: 'id',
    securityId: 'securityId',
    paymentDate: 'paymentDate',
    ratio: 'ratio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    exercisedDate: 'exercisedDate',
    declaredDate: 'declaredDate',
    toFactor: 'toFactor',
    fromFactor: 'fromFactor',
    description: 'description'
  };

  export type SecuritySplitsScalarFieldEnum = (typeof SecuritySplitsScalarFieldEnum)[keyof typeof SecuritySplitsScalarFieldEnum]


  export const SecurityTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type SecurityTypesScalarFieldEnum = (typeof SecurityTypesScalarFieldEnum)[keyof typeof SecurityTypesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StrategiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type StrategiesScalarFieldEnum = (typeof StrategiesScalarFieldEnum)[keyof typeof StrategiesScalarFieldEnum]


  export const StrategyParametersScalarFieldEnum: {
    id: 'id',
    strategyId: 'strategyId',
    key: 'key',
    value: 'value',
    dataType: 'dataType'
  };

  export type StrategyParametersScalarFieldEnum = (typeof StrategyParametersScalarFieldEnum)[keyof typeof StrategyParametersScalarFieldEnum]


  export const TradesScalarFieldEnum: {
    id: 'id',
    securityId: 'securityId',
    exchangeId: 'exchangeId',
    tradeDate: 'tradeDate',
    price: 'price',
    quantity: 'quantity',
    createdAt: 'createdAt'
  };

  export type TradesScalarFieldEnum = (typeof TradesScalarFieldEnum)[keyof typeof TradesScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type AccountsWhereInput = {
    AND?: Enumerable<AccountsWhereInput>
    OR?: Enumerable<AccountsWhereInput>
    NOT?: Enumerable<AccountsWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    accountId?: StringNullableFilter | string | null
    marketValue?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    buyingPower?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    cash?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter | string
    daytradeCount?: IntFilter | number
    daytradeBuyingPower?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    initialMargin?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    multiplier?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    sma?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    Orders?: OrdersListRelationFilter
    Positions?: PositionsListRelationFilter
  }

  export type AccountsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    marketValue?: SortOrder
    buyingPower?: SortOrder
    cash?: SortOrder
    currency?: SortOrder
    daytradeCount?: SortOrder
    daytradeBuyingPower?: SortOrder
    regulationTBuyingPower?: SortOrder
    initialMargin?: SortOrder
    lastMaintenanceMargin?: SortOrder
    longMarketValue?: SortOrder
    shortMarketValue?: SortOrder
    maintenanceMargin?: SortOrder
    multiplier?: SortOrder
    sma?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Orders?: OrdersOrderByRelationAggregateInput
    Positions?: PositionsOrderByRelationAggregateInput
  }

  export type AccountsWhereUniqueInput = {
    id?: string
  }

  export type AccountsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    marketValue?: SortOrder
    buyingPower?: SortOrder
    cash?: SortOrder
    currency?: SortOrder
    daytradeCount?: SortOrder
    daytradeBuyingPower?: SortOrder
    regulationTBuyingPower?: SortOrder
    initialMargin?: SortOrder
    lastMaintenanceMargin?: SortOrder
    longMarketValue?: SortOrder
    shortMarketValue?: SortOrder
    maintenanceMargin?: SortOrder
    multiplier?: SortOrder
    sma?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountsCountOrderByAggregateInput
    _avg?: AccountsAvgOrderByAggregateInput
    _max?: AccountsMaxOrderByAggregateInput
    _min?: AccountsMinOrderByAggregateInput
    _sum?: AccountsSumOrderByAggregateInput
  }

  export type AccountsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    accountId?: StringNullableWithAggregatesFilter | string | null
    marketValue?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    buyingPower?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    cash?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter | string
    daytradeCount?: IntWithAggregatesFilter | number
    daytradeBuyingPower?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    initialMargin?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    multiplier?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    sma?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AmeritradeEventsWhereInput = {
    AND?: Enumerable<AmeritradeEventsWhereInput>
    OR?: Enumerable<AmeritradeEventsWhereInput>
    NOT?: Enumerable<AmeritradeEventsWhereInput>
    id?: StringFilter | string
    message?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type AmeritradeEventsOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmeritradeEventsWhereUniqueInput = {
    id?: string
  }

  export type AmeritradeEventsOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmeritradeEventsCountOrderByAggregateInput
    _max?: AmeritradeEventsMaxOrderByAggregateInput
    _min?: AmeritradeEventsMinOrderByAggregateInput
  }

  export type AmeritradeEventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AmeritradeEventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AmeritradeEventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AmeritradeEventsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    message?: JsonWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AmeritradeTokensWhereInput = {
    AND?: Enumerable<AmeritradeTokensWhereInput>
    OR?: Enumerable<AmeritradeTokensWhereInput>
    NOT?: Enumerable<AmeritradeTokensWhereInput>
    id?: IntFilter | number
    data?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type AmeritradeTokensOrderByWithRelationInput = {
    id?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmeritradeTokensWhereUniqueInput = {
    id?: number
  }

  export type AmeritradeTokensOrderByWithAggregationInput = {
    id?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmeritradeTokensCountOrderByAggregateInput
    _avg?: AmeritradeTokensAvgOrderByAggregateInput
    _max?: AmeritradeTokensMaxOrderByAggregateInput
    _min?: AmeritradeTokensMinOrderByAggregateInput
    _sum?: AmeritradeTokensSumOrderByAggregateInput
  }

  export type AmeritradeTokensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AmeritradeTokensScalarWhereWithAggregatesInput>
    OR?: Enumerable<AmeritradeTokensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AmeritradeTokensScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    data?: JsonWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BackTestingWhereInput = {
    AND?: Enumerable<BackTestingWhereInput>
    OR?: Enumerable<BackTestingWhereInput>
    NOT?: Enumerable<BackTestingWhereInput>
    id?: StringFilter | string
    strategy?: StringFilter | string
    strategyParameters?: JsonNullableFilter
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    resultLog?: StringNullableFilter | string | null
    marginPercentage?: DecimalFilter | Decimal | DecimalJsLike | number | string
    averageInterestRate?: DecimalFilter | Decimal | DecimalJsLike | number | string
    finalBalance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    profits?: DecimalFilter | Decimal | DecimalJsLike | number | string
    losses?: DecimalFilter | Decimal | DecimalJsLike | number | string
    highestInterestDay?: DecimalFilter | Decimal | DecimalJsLike | number | string
    lowestInterestDay?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    code?: StringNullableFilter | string | null
    unrealizedProfit?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type BackTestingOrderByWithRelationInput = {
    id?: SortOrder
    strategy?: SortOrder
    strategyParameters?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    resultLog?: SortOrder
    marginPercentage?: SortOrder
    averageInterestRate?: SortOrder
    finalBalance?: SortOrder
    profits?: SortOrder
    losses?: SortOrder
    highestInterestDay?: SortOrder
    lowestInterestDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    unrealizedProfit?: SortOrder
  }

  export type BackTestingWhereUniqueInput = {
    id?: string
  }

  export type BackTestingOrderByWithAggregationInput = {
    id?: SortOrder
    strategy?: SortOrder
    strategyParameters?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    resultLog?: SortOrder
    marginPercentage?: SortOrder
    averageInterestRate?: SortOrder
    finalBalance?: SortOrder
    profits?: SortOrder
    losses?: SortOrder
    highestInterestDay?: SortOrder
    lowestInterestDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    unrealizedProfit?: SortOrder
    _count?: BackTestingCountOrderByAggregateInput
    _avg?: BackTestingAvgOrderByAggregateInput
    _max?: BackTestingMaxOrderByAggregateInput
    _min?: BackTestingMinOrderByAggregateInput
    _sum?: BackTestingSumOrderByAggregateInput
  }

  export type BackTestingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BackTestingScalarWhereWithAggregatesInput>
    OR?: Enumerable<BackTestingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BackTestingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    strategy?: StringWithAggregatesFilter | string
    strategyParameters?: JsonNullableWithAggregatesFilter
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeWithAggregatesFilter | Date | string
    resultLog?: StringNullableWithAggregatesFilter | string | null
    marginPercentage?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    averageInterestRate?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    finalBalance?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    profits?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    losses?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    highestInterestDay?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    lowestInterestDay?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    code?: StringNullableWithAggregatesFilter | string | null
    unrealizedProfit?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type ExchangesWhereInput = {
    AND?: Enumerable<ExchangesWhereInput>
    OR?: Enumerable<ExchangesWhereInput>
    NOT?: Enumerable<ExchangesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    assetClass?: StringNullableFilter | string | null
    locale?: StringNullableFilter | string | null
    acronym?: StringNullableFilter | string | null
    mic?: StringNullableFilter | string | null
    operatingMic?: StringNullableFilter | string | null
    participantId?: StringNullableFilter | string | null
    url?: StringNullableFilter | string | null
    Trades?: TradesListRelationFilter
    AskQuotes?: QuotesListRelationFilter
    BidQuotes?: QuotesListRelationFilter
  }

  export type ExchangesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assetClass?: SortOrder
    locale?: SortOrder
    acronym?: SortOrder
    mic?: SortOrder
    operatingMic?: SortOrder
    participantId?: SortOrder
    url?: SortOrder
    Trades?: TradesOrderByRelationAggregateInput
    AskQuotes?: QuotesOrderByRelationAggregateInput
    BidQuotes?: QuotesOrderByRelationAggregateInput
  }

  export type ExchangesWhereUniqueInput = {
    id?: number
  }

  export type ExchangesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assetClass?: SortOrder
    locale?: SortOrder
    acronym?: SortOrder
    mic?: SortOrder
    operatingMic?: SortOrder
    participantId?: SortOrder
    url?: SortOrder
    _count?: ExchangesCountOrderByAggregateInput
    _avg?: ExchangesAvgOrderByAggregateInput
    _max?: ExchangesMaxOrderByAggregateInput
    _min?: ExchangesMinOrderByAggregateInput
    _sum?: ExchangesSumOrderByAggregateInput
  }

  export type ExchangesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExchangesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExchangesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExchangesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    assetClass?: StringNullableWithAggregatesFilter | string | null
    locale?: StringNullableWithAggregatesFilter | string | null
    acronym?: StringNullableWithAggregatesFilter | string | null
    mic?: StringNullableWithAggregatesFilter | string | null
    operatingMic?: StringNullableWithAggregatesFilter | string | null
    participantId?: StringNullableWithAggregatesFilter | string | null
    url?: StringNullableWithAggregatesFilter | string | null
  }

  export type migrationsWhereInput = {
    AND?: Enumerable<migrationsWhereInput>
    OR?: Enumerable<migrationsWhereInput>
    NOT?: Enumerable<migrationsWhereInput>
    id?: IntFilter | number
    timestamp?: BigIntFilter | bigint | number
    name?: StringFilter | string
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsWhereUniqueInput = {
    id?: number
  }

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<migrationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<migrationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<migrationsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    timestamp?: BigIntWithAggregatesFilter | bigint | number
    name?: StringWithAggregatesFilter | string
  }

  export type OrdersWhereInput = {
    AND?: Enumerable<OrdersWhereInput>
    OR?: Enumerable<OrdersWhereInput>
    NOT?: Enumerable<OrdersWhereInput>
    id?: StringFilter | string
    securityId?: IntFilter | number
    strategyName?: StringNullableFilter | string | null
    accountId?: StringNullableFilter | string | null
    symbol?: StringFilter | string
    name?: StringNullableFilter | string | null
    type?: StringFilter | string
    timeInForce?: StringFilter | string
    quantity?: DecimalFilter | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFilter | Decimal | DecimalJsLike | number | string
    filledTime?: DateTimeNullableFilter | Date | string | null
    stopPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    limitPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter | string | null
    orderType?: StringNullableFilter | string | null
    trailAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFilter | boolean
    submittedAt?: DateTimeNullableFilter | Date | string | null
    expiredAt?: DateTimeNullableFilter | Date | string | null
    canceledAt?: DateTimeNullableFilter | Date | string | null
    failedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    Account?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    PositionOrders?: PositionOrdersListRelationFilter
  }

  export type OrdersOrderByWithRelationInput = {
    id?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    accountId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    type?: SortOrder
    timeInForce?: SortOrder
    quantity?: SortOrder
    filledQuantity?: SortOrder
    filledTime?: SortOrder
    stopPrice?: SortOrder
    limitPrice?: SortOrder
    filledAveragePrice?: SortOrder
    status?: SortOrder
    orderType?: SortOrder
    trailAmount?: SortOrder
    extendedHours?: SortOrder
    submittedAt?: SortOrder
    expiredAt?: SortOrder
    canceledAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Account?: AccountsOrderByWithRelationInput
    PositionOrders?: PositionOrdersOrderByRelationAggregateInput
  }

  export type OrdersWhereUniqueInput = {
    id?: string
  }

  export type OrdersOrderByWithAggregationInput = {
    id?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    accountId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    type?: SortOrder
    timeInForce?: SortOrder
    quantity?: SortOrder
    filledQuantity?: SortOrder
    filledTime?: SortOrder
    stopPrice?: SortOrder
    limitPrice?: SortOrder
    filledAveragePrice?: SortOrder
    status?: SortOrder
    orderType?: SortOrder
    trailAmount?: SortOrder
    extendedHours?: SortOrder
    submittedAt?: SortOrder
    expiredAt?: SortOrder
    canceledAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrdersCountOrderByAggregateInput
    _avg?: OrdersAvgOrderByAggregateInput
    _max?: OrdersMaxOrderByAggregateInput
    _min?: OrdersMinOrderByAggregateInput
    _sum?: OrdersSumOrderByAggregateInput
  }

  export type OrdersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrdersScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrdersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrdersScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    securityId?: IntWithAggregatesFilter | number
    strategyName?: StringNullableWithAggregatesFilter | string | null
    accountId?: StringNullableWithAggregatesFilter | string | null
    symbol?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    type?: StringWithAggregatesFilter | string
    timeInForce?: StringWithAggregatesFilter | string
    quantity?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    filledTime?: DateTimeNullableWithAggregatesFilter | Date | string | null
    stopPrice?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    limitPrice?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    orderType?: StringNullableWithAggregatesFilter | string | null
    trailAmount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolWithAggregatesFilter | boolean
    submittedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    expiredAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PositionsWhereInput = {
    AND?: Enumerable<PositionsWhereInput>
    OR?: Enumerable<PositionsWhereInput>
    NOT?: Enumerable<PositionsWhereInput>
    id?: StringFilter | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    securityId?: IntFilter | number
    strategyName?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    accountId?: StringNullableFilter | string | null
    quantity?: DecimalFilter | Decimal | DecimalJsLike | number | string
    marketValue?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFilter | string
    exchange?: StringNullableFilter | string | null
    positionPercent?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    status?: StringNullableFilter | string | null
    type?: StringFilter | string
    sellLock?: BoolFilter | boolean
    Account?: XOR<AccountsRelationFilter, AccountsWhereInput> | null
    PositionOrders?: PositionOrdersListRelationFilter
  }

  export type PositionsOrderByWithRelationInput = {
    id?: SortOrder
    price?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    quantity?: SortOrder
    marketValue?: SortOrder
    symbol?: SortOrder
    exchange?: SortOrder
    positionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    sellLock?: SortOrder
    Account?: AccountsOrderByWithRelationInput
    PositionOrders?: PositionOrdersOrderByRelationAggregateInput
  }

  export type PositionsWhereUniqueInput = {
    id?: string
  }

  export type PositionsOrderByWithAggregationInput = {
    id?: SortOrder
    price?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    quantity?: SortOrder
    marketValue?: SortOrder
    symbol?: SortOrder
    exchange?: SortOrder
    positionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    sellLock?: SortOrder
    _count?: PositionsCountOrderByAggregateInput
    _avg?: PositionsAvgOrderByAggregateInput
    _max?: PositionsMaxOrderByAggregateInput
    _min?: PositionsMinOrderByAggregateInput
    _sum?: PositionsSumOrderByAggregateInput
  }

  export type PositionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PositionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<PositionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PositionsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    securityId?: IntWithAggregatesFilter | number
    strategyName?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    accountId?: StringNullableWithAggregatesFilter | string | null
    quantity?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    marketValue?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    symbol?: StringWithAggregatesFilter | string
    exchange?: StringNullableWithAggregatesFilter | string | null
    positionPercent?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    type?: StringWithAggregatesFilter | string
    sellLock?: BoolWithAggregatesFilter | boolean
  }

  export type PositionOrdersWhereInput = {
    AND?: Enumerable<PositionOrdersWhereInput>
    OR?: Enumerable<PositionOrdersWhereInput>
    NOT?: Enumerable<PositionOrdersWhereInput>
    positionId?: StringFilter | string
    orderId?: StringFilter | string
    intent?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    Position?: XOR<PositionsRelationFilter, PositionsWhereInput> | null
    Order?: XOR<OrdersRelationFilter, OrdersWhereInput> | null
  }

  export type PositionOrdersOrderByWithRelationInput = {
    positionId?: SortOrder
    orderId?: SortOrder
    intent?: SortOrder
    createdAt?: SortOrder
    Position?: PositionsOrderByWithRelationInput
    Order?: OrdersOrderByWithRelationInput
  }

  export type PositionOrdersWhereUniqueInput = {
    positionId_orderId_intent_createdAt?: PositionOrdersPositionIdOrderIdIntentCreatedAtCompoundUniqueInput
  }

  export type PositionOrdersOrderByWithAggregationInput = {
    positionId?: SortOrder
    orderId?: SortOrder
    intent?: SortOrder
    createdAt?: SortOrder
    _count?: PositionOrdersCountOrderByAggregateInput
    _max?: PositionOrdersMaxOrderByAggregateInput
    _min?: PositionOrdersMinOrderByAggregateInput
  }

  export type PositionOrdersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PositionOrdersScalarWhereWithAggregatesInput>
    OR?: Enumerable<PositionOrdersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PositionOrdersScalarWhereWithAggregatesInput>
    positionId?: StringWithAggregatesFilter | string
    orderId?: StringWithAggregatesFilter | string
    intent?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PreferencesWhereInput = {
    AND?: Enumerable<PreferencesWhereInput>
    OR?: Enumerable<PreferencesWhereInput>
    NOT?: Enumerable<PreferencesWhereInput>
    id?: IntFilter | number
    singleTradeRiskLevel?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PreferencesOrderByWithRelationInput = {
    id?: SortOrder
    singleTradeRiskLevel?: SortOrder
    allTradeRiskLevel?: SortOrder
    singleTradeVolatilityLevel?: SortOrder
    allTradeVolatilityLevel?: SortOrder
    lowestStockPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreferencesWhereUniqueInput = {
    id?: number
  }

  export type PreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    singleTradeRiskLevel?: SortOrder
    allTradeRiskLevel?: SortOrder
    singleTradeVolatilityLevel?: SortOrder
    allTradeVolatilityLevel?: SortOrder
    lowestStockPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PreferencesCountOrderByAggregateInput
    _avg?: PreferencesAvgOrderByAggregateInput
    _max?: PreferencesMaxOrderByAggregateInput
    _min?: PreferencesMinOrderByAggregateInput
    _sum?: PreferencesSumOrderByAggregateInput
  }

  export type PreferencesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PreferencesScalarWhereWithAggregatesInput>
    OR?: Enumerable<PreferencesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PreferencesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    singleTradeRiskLevel?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SectorDailyWhereInput = {
    AND?: Enumerable<SectorDailyWhereInput>
    OR?: Enumerable<SectorDailyWhereInput>
    NOT?: Enumerable<SectorDailyWhereInput>
    id?: IntFilter | number
    sectorId?: IntFilter | number
    calendarDate?: DateTimeFilter | Date | string
    realtimeReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    Sector?: XOR<SectorsRelationFilter, SectorsWhereInput>
  }

  export type SectorDailyOrderByWithRelationInput = {
    id?: SortOrder
    sectorId?: SortOrder
    calendarDate?: SortOrder
    realtimeReturn?: SortOrder
    oneDayReturn?: SortOrder
    fiveDayReturn?: SortOrder
    oneMonthReturn?: SortOrder
    threeMonthReturn?: SortOrder
    oneYearReturn?: SortOrder
    threeYearReturn?: SortOrder
    fiveYearReturn?: SortOrder
    tenYearReturn?: SortOrder
    ytdReturn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Sector?: SectorsOrderByWithRelationInput
  }

  export type SectorDailyWhereUniqueInput = {
    id?: number
  }

  export type SectorDailyOrderByWithAggregationInput = {
    id?: SortOrder
    sectorId?: SortOrder
    calendarDate?: SortOrder
    realtimeReturn?: SortOrder
    oneDayReturn?: SortOrder
    fiveDayReturn?: SortOrder
    oneMonthReturn?: SortOrder
    threeMonthReturn?: SortOrder
    oneYearReturn?: SortOrder
    threeYearReturn?: SortOrder
    fiveYearReturn?: SortOrder
    tenYearReturn?: SortOrder
    ytdReturn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectorDailyCountOrderByAggregateInput
    _avg?: SectorDailyAvgOrderByAggregateInput
    _max?: SectorDailyMaxOrderByAggregateInput
    _min?: SectorDailyMinOrderByAggregateInput
    _sum?: SectorDailySumOrderByAggregateInput
  }

  export type SectorDailyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SectorDailyScalarWhereWithAggregatesInput>
    OR?: Enumerable<SectorDailyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SectorDailyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sectorId?: IntWithAggregatesFilter | number
    calendarDate?: DateTimeWithAggregatesFilter | Date | string
    realtimeReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SectorsWhereInput = {
    AND?: Enumerable<SectorsWhereInput>
    OR?: Enumerable<SectorsWhereInput>
    NOT?: Enumerable<SectorsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    SectorDaily?: SectorDailyListRelationFilter
  }

  export type SectorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SectorDaily?: SectorDailyOrderByRelationAggregateInput
  }

  export type SectorsWhereUniqueInput = {
    id?: number
  }

  export type SectorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectorsCountOrderByAggregateInput
    _avg?: SectorsAvgOrderByAggregateInput
    _max?: SectorsMaxOrderByAggregateInput
    _min?: SectorsMinOrderByAggregateInput
    _sum?: SectorsSumOrderByAggregateInput
  }

  export type SectorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SectorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SectorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SectorsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SecuritiesWhereInput = {
    AND?: Enumerable<SecuritiesWhereInput>
    OR?: Enumerable<SecuritiesWhereInput>
    NOT?: Enumerable<SecuritiesWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    symbol?: StringNullableFilter | string | null
    cusip?: StringNullableFilter | string | null
    exchange?: StringNullableFilter | string | null
    securityTypeId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    marketCap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    companyName?: StringNullableFilter | string | null
    sector?: StringNullableFilter | string | null
    active?: BoolFilter | boolean
    delistedCalendarDate?: DateTimeNullableFilter | Date | string | null
    companyDescription?: StringNullableFilter | string | null
    url?: StringNullableFilter | string | null
    sharesOutstanding?: IntNullableFilter | number | null
    numberOfEmployees?: IntNullableFilter | number | null
    SecurityDaily?: SecurityDailyListRelationFilter
    SecurityDividends?: SecurityDividendsListRelationFilter
    SecurityMinutely?: SecurityMinutelyListRelationFilter
    SecuritySecondly?: SecuritySecondlyListRelationFilter
    SecuritySplits?: SecuritySplitsListRelationFilter
    Trades?: TradesListRelationFilter
    Quotes?: QuotesListRelationFilter
  }

  export type SecuritiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    cusip?: SortOrder
    exchange?: SortOrder
    securityTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketCap?: SortOrder
    companyName?: SortOrder
    sector?: SortOrder
    active?: SortOrder
    delistedCalendarDate?: SortOrder
    companyDescription?: SortOrder
    url?: SortOrder
    sharesOutstanding?: SortOrder
    numberOfEmployees?: SortOrder
    SecurityDaily?: SecurityDailyOrderByRelationAggregateInput
    SecurityDividends?: SecurityDividendsOrderByRelationAggregateInput
    SecurityMinutely?: SecurityMinutelyOrderByRelationAggregateInput
    SecuritySecondly?: SecuritySecondlyOrderByRelationAggregateInput
    SecuritySplits?: SecuritySplitsOrderByRelationAggregateInput
    Trades?: TradesOrderByRelationAggregateInput
    Quotes?: QuotesOrderByRelationAggregateInput
  }

  export type SecuritiesWhereUniqueInput = {
    id?: number
    symbol?: string
  }

  export type SecuritiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    cusip?: SortOrder
    exchange?: SortOrder
    securityTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketCap?: SortOrder
    companyName?: SortOrder
    sector?: SortOrder
    active?: SortOrder
    delistedCalendarDate?: SortOrder
    companyDescription?: SortOrder
    url?: SortOrder
    sharesOutstanding?: SortOrder
    numberOfEmployees?: SortOrder
    _count?: SecuritiesCountOrderByAggregateInput
    _avg?: SecuritiesAvgOrderByAggregateInput
    _max?: SecuritiesMaxOrderByAggregateInput
    _min?: SecuritiesMinOrderByAggregateInput
    _sum?: SecuritiesSumOrderByAggregateInput
  }

  export type SecuritiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SecuritiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<SecuritiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SecuritiesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    symbol?: StringNullableWithAggregatesFilter | string | null
    cusip?: StringNullableWithAggregatesFilter | string | null
    exchange?: StringNullableWithAggregatesFilter | string | null
    securityTypeId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    marketCap?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    companyName?: StringNullableWithAggregatesFilter | string | null
    sector?: StringNullableWithAggregatesFilter | string | null
    active?: BoolWithAggregatesFilter | boolean
    delistedCalendarDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    companyDescription?: StringNullableWithAggregatesFilter | string | null
    url?: StringNullableWithAggregatesFilter | string | null
    sharesOutstanding?: IntNullableWithAggregatesFilter | number | null
    numberOfEmployees?: IntNullableWithAggregatesFilter | number | null
  }

  export type SecurityDailyWhereInput = {
    AND?: Enumerable<SecurityDailyWhereInput>
    OR?: Enumerable<SecurityDailyWhereInput>
    NOT?: Enumerable<SecurityDailyWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    open?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketCap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    peRatio?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    pbRatio?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    volume?: IntFilter | number
    adjusted?: BoolFilter | boolean
    calendarDate?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    Security?: XOR<SecuritiesRelationFilter, SecuritiesWhereInput>
  }

  export type SecurityDailyOrderByWithRelationInput = {
    id?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    adjustedClose?: SortOrder
    marketCap?: SortOrder
    enterpriseValue?: SortOrder
    peRatio?: SortOrder
    pbRatio?: SortOrder
    trailingOneYearPegRatio?: SortOrder
    dividendAmount?: SortOrder
    splitCoefficient?: SortOrder
    volume?: SortOrder
    adjusted?: SortOrder
    calendarDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Security?: SecuritiesOrderByWithRelationInput
  }

  export type SecurityDailyWhereUniqueInput = {
    id?: number
    securityId_calendarDate?: SecurityDailySecurityIdCalendarDateCompoundUniqueInput
  }

  export type SecurityDailyOrderByWithAggregationInput = {
    id?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    adjustedClose?: SortOrder
    marketCap?: SortOrder
    enterpriseValue?: SortOrder
    peRatio?: SortOrder
    pbRatio?: SortOrder
    trailingOneYearPegRatio?: SortOrder
    dividendAmount?: SortOrder
    splitCoefficient?: SortOrder
    volume?: SortOrder
    adjusted?: SortOrder
    calendarDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityDailyCountOrderByAggregateInput
    _avg?: SecurityDailyAvgOrderByAggregateInput
    _max?: SecurityDailyMaxOrderByAggregateInput
    _min?: SecurityDailyMinOrderByAggregateInput
    _sum?: SecurityDailySumOrderByAggregateInput
  }

  export type SecurityDailyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SecurityDailyScalarWhereWithAggregatesInput>
    OR?: Enumerable<SecurityDailyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SecurityDailyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    securityId?: IntWithAggregatesFilter | number
    open?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    marketCap?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    peRatio?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    pbRatio?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    volume?: IntWithAggregatesFilter | number
    adjusted?: BoolWithAggregatesFilter | boolean
    calendarDate?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SecurityDividendsWhereInput = {
    AND?: Enumerable<SecurityDividendsWhereInput>
    OR?: Enumerable<SecurityDividendsWhereInput>
    NOT?: Enumerable<SecurityDividendsWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    expirationDate?: DateTimeNullableFilter | Date | string | null
    paymentDate?: DateTimeFilter | Date | string
    recordDate?: DateTimeFilter | Date | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    Security?: XOR<SecuritiesRelationFilter, SecuritiesWhereInput>
  }

  export type SecurityDividendsOrderByWithRelationInput = {
    id?: SortOrder
    securityId?: SortOrder
    expirationDate?: SortOrder
    paymentDate?: SortOrder
    recordDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Security?: SecuritiesOrderByWithRelationInput
  }

  export type SecurityDividendsWhereUniqueInput = {
    id?: number
  }

  export type SecurityDividendsOrderByWithAggregationInput = {
    id?: SortOrder
    securityId?: SortOrder
    expirationDate?: SortOrder
    paymentDate?: SortOrder
    recordDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecurityDividendsCountOrderByAggregateInput
    _avg?: SecurityDividendsAvgOrderByAggregateInput
    _max?: SecurityDividendsMaxOrderByAggregateInput
    _min?: SecurityDividendsMinOrderByAggregateInput
    _sum?: SecurityDividendsSumOrderByAggregateInput
  }

  export type SecurityDividendsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SecurityDividendsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SecurityDividendsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SecurityDividendsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    securityId?: IntWithAggregatesFilter | number
    expirationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    paymentDate?: DateTimeWithAggregatesFilter | Date | string
    recordDate?: DateTimeWithAggregatesFilter | Date | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SecurityIndexTypesWhereInput = {
    AND?: Enumerable<SecurityIndexTypesWhereInput>
    OR?: Enumerable<SecurityIndexTypesWhereInput>
    NOT?: Enumerable<SecurityIndexTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
  }

  export type SecurityIndexTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SecurityIndexTypesWhereUniqueInput = {
    id?: number
  }

  export type SecurityIndexTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: SecurityIndexTypesCountOrderByAggregateInput
    _avg?: SecurityIndexTypesAvgOrderByAggregateInput
    _max?: SecurityIndexTypesMaxOrderByAggregateInput
    _min?: SecurityIndexTypesMinOrderByAggregateInput
    _sum?: SecurityIndexTypesSumOrderByAggregateInput
  }

  export type SecurityIndexTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SecurityIndexTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<SecurityIndexTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SecurityIndexTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type SecurityMinutelyWhereInput = {
    AND?: Enumerable<SecurityMinutelyWhereInput>
    OR?: Enumerable<SecurityMinutelyWhereInput>
    NOT?: Enumerable<SecurityMinutelyWhereInput>
    securityId?: IntFilter | number
    calendarDate?: DateTimeFilter | Date | string
    minute?: StringNullableFilter | string | null
    label?: StringNullableFilter | string | null
    open?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    average?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    volume?: BigIntNullableFilter | bigint | number | null
    notional?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: BigIntNullableFilter | bigint | number | null
    marketHigh?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketLow?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketAverage?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketVolume?: BigIntNullableFilter | bigint | number | null
    marketNotional?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: BigIntNullableFilter | bigint | number | null
    marketOpen?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketClose?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    dateTime?: DateTimeNullableFilter | Date | string | null
    Security?: XOR<SecuritiesRelationFilter, SecuritiesWhereInput>
  }

  export type SecurityMinutelyOrderByWithRelationInput = {
    securityId?: SortOrder
    calendarDate?: SortOrder
    minute?: SortOrder
    label?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    marketHigh?: SortOrder
    marketLow?: SortOrder
    marketAverage?: SortOrder
    marketVolume?: SortOrder
    marketNotional?: SortOrder
    marketNumberOfTrades?: SortOrder
    marketOpen?: SortOrder
    marketClose?: SortOrder
    changeOverTime?: SortOrder
    marketChangeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateTime?: SortOrder
    Security?: SecuritiesOrderByWithRelationInput
  }

  export type SecurityMinutelyWhereUniqueInput = {
    securityId_calendarDate?: SecurityMinutelySecurityIdCalendarDateCompoundUniqueInput
  }

  export type SecurityMinutelyOrderByWithAggregationInput = {
    securityId?: SortOrder
    calendarDate?: SortOrder
    minute?: SortOrder
    label?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    marketHigh?: SortOrder
    marketLow?: SortOrder
    marketAverage?: SortOrder
    marketVolume?: SortOrder
    marketNotional?: SortOrder
    marketNumberOfTrades?: SortOrder
    marketOpen?: SortOrder
    marketClose?: SortOrder
    changeOverTime?: SortOrder
    marketChangeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateTime?: SortOrder
    _count?: SecurityMinutelyCountOrderByAggregateInput
    _avg?: SecurityMinutelyAvgOrderByAggregateInput
    _max?: SecurityMinutelyMaxOrderByAggregateInput
    _min?: SecurityMinutelyMinOrderByAggregateInput
    _sum?: SecurityMinutelySumOrderByAggregateInput
  }

  export type SecurityMinutelyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SecurityMinutelyScalarWhereWithAggregatesInput>
    OR?: Enumerable<SecurityMinutelyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SecurityMinutelyScalarWhereWithAggregatesInput>
    securityId?: IntWithAggregatesFilter | number
    calendarDate?: DateTimeWithAggregatesFilter | Date | string
    minute?: StringNullableWithAggregatesFilter | string | null
    label?: StringNullableWithAggregatesFilter | string | null
    open?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    average?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    volume?: BigIntNullableWithAggregatesFilter | bigint | number | null
    notional?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: BigIntNullableWithAggregatesFilter | bigint | number | null
    marketHigh?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    marketLow?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    marketAverage?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    marketVolume?: BigIntNullableWithAggregatesFilter | bigint | number | null
    marketNotional?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: BigIntNullableWithAggregatesFilter | bigint | number | null
    marketOpen?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    marketClose?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    dateTime?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SecuritySecondlyWhereInput = {
    AND?: Enumerable<SecuritySecondlyWhereInput>
    OR?: Enumerable<SecuritySecondlyWhereInput>
    NOT?: Enumerable<SecuritySecondlyWhereInput>
    calendarDate?: DateTimeFilter | Date | string
    securityId?: IntFilter | number
    open?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    average?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    volume?: BigIntNullableFilter | bigint | number | null
    notional?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: BigIntNullableFilter | bigint | number | null
    changeOverTime?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    Security?: XOR<SecuritiesRelationFilter, SecuritiesWhereInput>
  }

  export type SecuritySecondlyOrderByWithRelationInput = {
    calendarDate?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    changeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Security?: SecuritiesOrderByWithRelationInput
  }

  export type SecuritySecondlyWhereUniqueInput = {
    securityId_calendarDate?: SecuritySecondlySecurityIdCalendarDateCompoundUniqueInput
  }

  export type SecuritySecondlyOrderByWithAggregationInput = {
    calendarDate?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    changeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SecuritySecondlyCountOrderByAggregateInput
    _avg?: SecuritySecondlyAvgOrderByAggregateInput
    _max?: SecuritySecondlyMaxOrderByAggregateInput
    _min?: SecuritySecondlyMinOrderByAggregateInput
    _sum?: SecuritySecondlySumOrderByAggregateInput
  }

  export type SecuritySecondlyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SecuritySecondlyScalarWhereWithAggregatesInput>
    OR?: Enumerable<SecuritySecondlyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SecuritySecondlyScalarWhereWithAggregatesInput>
    calendarDate?: DateTimeWithAggregatesFilter | Date | string
    securityId?: IntWithAggregatesFilter | number
    open?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    average?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    volume?: BigIntNullableWithAggregatesFilter | bigint | number | null
    notional?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: BigIntNullableWithAggregatesFilter | bigint | number | null
    changeOverTime?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SecuritySplitsWhereInput = {
    AND?: Enumerable<SecuritySplitsWhereInput>
    OR?: Enumerable<SecuritySplitsWhereInput>
    NOT?: Enumerable<SecuritySplitsWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    paymentDate?: DateTimeFilter | Date | string
    ratio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    exercisedDate?: DateTimeFilter | Date | string
    declaredDate?: DateTimeFilter | Date | string
    toFactor?: IntFilter | number
    fromFactor?: IntFilter | number
    description?: StringNullableFilter | string | null
    Security?: XOR<SecuritiesRelationFilter, SecuritiesWhereInput>
  }

  export type SecuritySplitsOrderByWithRelationInput = {
    id?: SortOrder
    securityId?: SortOrder
    paymentDate?: SortOrder
    ratio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exercisedDate?: SortOrder
    declaredDate?: SortOrder
    toFactor?: SortOrder
    fromFactor?: SortOrder
    description?: SortOrder
    Security?: SecuritiesOrderByWithRelationInput
  }

  export type SecuritySplitsWhereUniqueInput = {
    id?: number
  }

  export type SecuritySplitsOrderByWithAggregationInput = {
    id?: SortOrder
    securityId?: SortOrder
    paymentDate?: SortOrder
    ratio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exercisedDate?: SortOrder
    declaredDate?: SortOrder
    toFactor?: SortOrder
    fromFactor?: SortOrder
    description?: SortOrder
    _count?: SecuritySplitsCountOrderByAggregateInput
    _avg?: SecuritySplitsAvgOrderByAggregateInput
    _max?: SecuritySplitsMaxOrderByAggregateInput
    _min?: SecuritySplitsMinOrderByAggregateInput
    _sum?: SecuritySplitsSumOrderByAggregateInput
  }

  export type SecuritySplitsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SecuritySplitsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SecuritySplitsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SecuritySplitsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    securityId?: IntWithAggregatesFilter | number
    paymentDate?: DateTimeWithAggregatesFilter | Date | string
    ratio?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    exercisedDate?: DateTimeWithAggregatesFilter | Date | string
    declaredDate?: DateTimeWithAggregatesFilter | Date | string
    toFactor?: IntWithAggregatesFilter | number
    fromFactor?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type SecurityTypesWhereInput = {
    AND?: Enumerable<SecurityTypesWhereInput>
    OR?: Enumerable<SecurityTypesWhereInput>
    NOT?: Enumerable<SecurityTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
  }

  export type SecurityTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SecurityTypesWhereUniqueInput = {
    id?: number
  }

  export type SecurityTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: SecurityTypesCountOrderByAggregateInput
    _avg?: SecurityTypesAvgOrderByAggregateInput
    _max?: SecurityTypesMaxOrderByAggregateInput
    _min?: SecurityTypesMinOrderByAggregateInput
    _sum?: SecurityTypesSumOrderByAggregateInput
  }

  export type SecurityTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SecurityTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<SecurityTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SecurityTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type StrategiesWhereInput = {
    AND?: Enumerable<StrategiesWhereInput>
    OR?: Enumerable<StrategiesWhereInput>
    NOT?: Enumerable<StrategiesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    StrategyParameters?: StrategyParametersListRelationFilter
  }

  export type StrategiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    StrategyParameters?: StrategyParametersOrderByRelationAggregateInput
  }

  export type StrategiesWhereUniqueInput = {
    id?: number
  }

  export type StrategiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: StrategiesCountOrderByAggregateInput
    _avg?: StrategiesAvgOrderByAggregateInput
    _max?: StrategiesMaxOrderByAggregateInput
    _min?: StrategiesMinOrderByAggregateInput
    _sum?: StrategiesSumOrderByAggregateInput
  }

  export type StrategiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StrategiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<StrategiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StrategiesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type StrategyParametersWhereInput = {
    AND?: Enumerable<StrategyParametersWhereInput>
    OR?: Enumerable<StrategyParametersWhereInput>
    NOT?: Enumerable<StrategyParametersWhereInput>
    id?: IntFilter | number
    strategyId?: IntFilter | number
    key?: StringFilter | string
    value?: StringFilter | string
    dataType?: StringNullableFilter | string | null
    Strategy?: XOR<StrategiesRelationFilter, StrategiesWhereInput>
  }

  export type StrategyParametersOrderByWithRelationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    dataType?: SortOrder
    Strategy?: StrategiesOrderByWithRelationInput
  }

  export type StrategyParametersWhereUniqueInput = {
    id?: number
  }

  export type StrategyParametersOrderByWithAggregationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    dataType?: SortOrder
    _count?: StrategyParametersCountOrderByAggregateInput
    _avg?: StrategyParametersAvgOrderByAggregateInput
    _max?: StrategyParametersMaxOrderByAggregateInput
    _min?: StrategyParametersMinOrderByAggregateInput
    _sum?: StrategyParametersSumOrderByAggregateInput
  }

  export type StrategyParametersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StrategyParametersScalarWhereWithAggregatesInput>
    OR?: Enumerable<StrategyParametersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StrategyParametersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    strategyId?: IntWithAggregatesFilter | number
    key?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    dataType?: StringNullableWithAggregatesFilter | string | null
  }

  export type TradesWhereInput = {
    AND?: Enumerable<TradesWhereInput>
    OR?: Enumerable<TradesWhereInput>
    NOT?: Enumerable<TradesWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    exchangeId?: IntFilter | number
    tradeDate?: DateTimeFilter | Date | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    Exchange?: XOR<ExchangesRelationFilter, ExchangesWhereInput>
    Security?: XOR<SecuritiesRelationFilter, SecuritiesWhereInput>
    Conditions?: ConditionsListRelationFilter
  }

  export type TradesOrderByWithRelationInput = {
    id?: SortOrder
    securityId?: SortOrder
    exchangeId?: SortOrder
    tradeDate?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    Exchange?: ExchangesOrderByWithRelationInput
    Security?: SecuritiesOrderByWithRelationInput
    Conditions?: ConditionsOrderByRelationAggregateInput
  }

  export type TradesWhereUniqueInput = {
    id?: number
  }

  export type TradesOrderByWithAggregationInput = {
    id?: SortOrder
    securityId?: SortOrder
    exchangeId?: SortOrder
    tradeDate?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    _count?: TradesCountOrderByAggregateInput
    _avg?: TradesAvgOrderByAggregateInput
    _max?: TradesMaxOrderByAggregateInput
    _min?: TradesMinOrderByAggregateInput
    _sum?: TradesSumOrderByAggregateInput
  }

  export type TradesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TradesScalarWhereWithAggregatesInput>
    OR?: Enumerable<TradesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TradesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    securityId?: IntWithAggregatesFilter | number
    exchangeId?: IntWithAggregatesFilter | number
    tradeDate?: DateTimeWithAggregatesFilter | Date | string
    price?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    quantity?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuotesWhereInput = {
    AND?: Enumerable<QuotesWhereInput>
    OR?: Enumerable<QuotesWhereInput>
    NOT?: Enumerable<QuotesWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    bidExchangeId?: IntFilter | number
    askExchangeId?: IntFilter | number
    bidPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    askPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    bidSize?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    askSize?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    AskExchange?: XOR<ExchangesRelationFilter, ExchangesWhereInput>
    BidExchange?: XOR<ExchangesRelationFilter, ExchangesWhereInput>
    Security?: XOR<SecuritiesRelationFilter, SecuritiesWhereInput>
    Conditions?: ConditionsListRelationFilter
  }

  export type QuotesOrderByWithRelationInput = {
    id?: SortOrder
    securityId?: SortOrder
    bidExchangeId?: SortOrder
    askExchangeId?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    bidSize?: SortOrder
    askSize?: SortOrder
    createdAt?: SortOrder
    AskExchange?: ExchangesOrderByWithRelationInput
    BidExchange?: ExchangesOrderByWithRelationInput
    Security?: SecuritiesOrderByWithRelationInput
    Conditions?: ConditionsOrderByRelationAggregateInput
  }

  export type QuotesWhereUniqueInput = {
    id?: number
  }

  export type QuotesOrderByWithAggregationInput = {
    id?: SortOrder
    securityId?: SortOrder
    bidExchangeId?: SortOrder
    askExchangeId?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    bidSize?: SortOrder
    askSize?: SortOrder
    createdAt?: SortOrder
    _count?: QuotesCountOrderByAggregateInput
    _avg?: QuotesAvgOrderByAggregateInput
    _max?: QuotesMaxOrderByAggregateInput
    _min?: QuotesMinOrderByAggregateInput
    _sum?: QuotesSumOrderByAggregateInput
  }

  export type QuotesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuotesScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuotesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuotesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    securityId?: IntWithAggregatesFilter | number
    bidExchangeId?: IntWithAggregatesFilter | number
    askExchangeId?: IntWithAggregatesFilter | number
    bidPrice?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    askPrice?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    bidSize?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    askSize?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ConditionsWhereInput = {
    AND?: Enumerable<ConditionsWhereInput>
    OR?: Enumerable<ConditionsWhereInput>
    NOT?: Enumerable<ConditionsWhereInput>
    id?: IntFilter | number
    tradeId?: IntFilter | number
    quoteId?: IntFilter | number
    condition?: StringFilter | string
    modifier?: IntFilter | number
    SIPMapping?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    Trade?: XOR<TradesRelationFilter, TradesWhereInput>
    Quote?: XOR<QuotesRelationFilter, QuotesWhereInput>
  }

  export type ConditionsOrderByWithRelationInput = {
    id?: SortOrder
    tradeId?: SortOrder
    quoteId?: SortOrder
    condition?: SortOrder
    modifier?: SortOrder
    SIPMapping?: SortOrder
    createdAt?: SortOrder
    Trade?: TradesOrderByWithRelationInput
    Quote?: QuotesOrderByWithRelationInput
  }

  export type ConditionsWhereUniqueInput = {
    id?: number
  }

  export type ConditionsOrderByWithAggregationInput = {
    id?: SortOrder
    tradeId?: SortOrder
    quoteId?: SortOrder
    condition?: SortOrder
    modifier?: SortOrder
    SIPMapping?: SortOrder
    createdAt?: SortOrder
    _count?: ConditionsCountOrderByAggregateInput
    _avg?: ConditionsAvgOrderByAggregateInput
    _max?: ConditionsMaxOrderByAggregateInput
    _min?: ConditionsMinOrderByAggregateInput
    _sum?: ConditionsSumOrderByAggregateInput
  }

  export type ConditionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConditionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConditionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConditionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tradeId?: IntWithAggregatesFilter | number
    quoteId?: IntWithAggregatesFilter | number
    condition?: StringWithAggregatesFilter | string
    modifier?: IntWithAggregatesFilter | number
    SIPMapping?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AccountsCreateInput = {
    id: string
    name: string
    accountId?: string | null
    marketValue?: Decimal | DecimalJsLike | number | string | null
    buyingPower?: Decimal | DecimalJsLike | number | string | null
    cash?: Decimal | DecimalJsLike | number | string | null
    currency: string
    daytradeCount?: number
    daytradeBuyingPower?: Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: Decimal | DecimalJsLike | number | string | null
    initialMargin?: Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    longMarketValue?: Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    multiplier?: Decimal | DecimalJsLike | number | string | null
    sma?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Orders?: OrdersCreateNestedManyWithoutAccountInput
    Positions?: PositionsCreateNestedManyWithoutAccountInput
  }

  export type AccountsUncheckedCreateInput = {
    id: string
    name: string
    accountId?: string | null
    marketValue?: Decimal | DecimalJsLike | number | string | null
    buyingPower?: Decimal | DecimalJsLike | number | string | null
    cash?: Decimal | DecimalJsLike | number | string | null
    currency: string
    daytradeCount?: number
    daytradeBuyingPower?: Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: Decimal | DecimalJsLike | number | string | null
    initialMargin?: Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    longMarketValue?: Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    multiplier?: Decimal | DecimalJsLike | number | string | null
    sma?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountInput
    Positions?: PositionsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cash?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    daytradeCount?: IntFieldUpdateOperationsInput | number
    daytradeBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    initialMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sma?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Orders?: OrdersUpdateManyWithoutAccountNestedInput
    Positions?: PositionsUpdateManyWithoutAccountNestedInput
  }

  export type AccountsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cash?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    daytradeCount?: IntFieldUpdateOperationsInput | number
    daytradeBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    initialMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sma?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Orders?: OrdersUncheckedUpdateManyWithoutAccountNestedInput
    Positions?: PositionsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountsCreateManyInput = {
    id: string
    name: string
    accountId?: string | null
    marketValue?: Decimal | DecimalJsLike | number | string | null
    buyingPower?: Decimal | DecimalJsLike | number | string | null
    cash?: Decimal | DecimalJsLike | number | string | null
    currency: string
    daytradeCount?: number
    daytradeBuyingPower?: Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: Decimal | DecimalJsLike | number | string | null
    initialMargin?: Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    longMarketValue?: Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    multiplier?: Decimal | DecimalJsLike | number | string | null
    sma?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cash?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    daytradeCount?: IntFieldUpdateOperationsInput | number
    daytradeBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    initialMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sma?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cash?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    daytradeCount?: IntFieldUpdateOperationsInput | number
    daytradeBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    initialMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sma?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmeritradeEventsCreateInput = {
    id: string
    message: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AmeritradeEventsUncheckedCreateInput = {
    id: string
    message: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AmeritradeEventsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmeritradeEventsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmeritradeEventsCreateManyInput = {
    id: string
    message: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AmeritradeEventsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmeritradeEventsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmeritradeTokensCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AmeritradeTokensUncheckedCreateInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AmeritradeTokensUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmeritradeTokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmeritradeTokensCreateManyInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type AmeritradeTokensUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AmeritradeTokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BackTestingCreateInput = {
    id: string
    strategy: string
    strategyParameters?: NullableJsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    resultLog?: string | null
    marginPercentage: Decimal | DecimalJsLike | number | string
    averageInterestRate: Decimal | DecimalJsLike | number | string
    finalBalance: Decimal | DecimalJsLike | number | string
    profits: Decimal | DecimalJsLike | number | string
    losses: Decimal | DecimalJsLike | number | string
    highestInterestDay: Decimal | DecimalJsLike | number | string
    lowestInterestDay: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    code?: string | null
    unrealizedProfit?: Decimal | DecimalJsLike | number | string | null
  }

  export type BackTestingUncheckedCreateInput = {
    id: string
    strategy: string
    strategyParameters?: NullableJsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    resultLog?: string | null
    marginPercentage: Decimal | DecimalJsLike | number | string
    averageInterestRate: Decimal | DecimalJsLike | number | string
    finalBalance: Decimal | DecimalJsLike | number | string
    profits: Decimal | DecimalJsLike | number | string
    losses: Decimal | DecimalJsLike | number | string
    highestInterestDay: Decimal | DecimalJsLike | number | string
    lowestInterestDay: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    code?: string | null
    unrealizedProfit?: Decimal | DecimalJsLike | number | string | null
  }

  export type BackTestingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    strategyParameters?: NullableJsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    resultLog?: NullableStringFieldUpdateOperationsInput | string | null
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageInterestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    losses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestInterestDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lowestInterestDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unrealizedProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BackTestingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    strategyParameters?: NullableJsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    resultLog?: NullableStringFieldUpdateOperationsInput | string | null
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageInterestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    losses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestInterestDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lowestInterestDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unrealizedProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BackTestingCreateManyInput = {
    id: string
    strategy: string
    strategyParameters?: NullableJsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    resultLog?: string | null
    marginPercentage: Decimal | DecimalJsLike | number | string
    averageInterestRate: Decimal | DecimalJsLike | number | string
    finalBalance: Decimal | DecimalJsLike | number | string
    profits: Decimal | DecimalJsLike | number | string
    losses: Decimal | DecimalJsLike | number | string
    highestInterestDay: Decimal | DecimalJsLike | number | string
    lowestInterestDay: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    code?: string | null
    unrealizedProfit?: Decimal | DecimalJsLike | number | string | null
  }

  export type BackTestingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    strategyParameters?: NullableJsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    resultLog?: NullableStringFieldUpdateOperationsInput | string | null
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageInterestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    losses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestInterestDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lowestInterestDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unrealizedProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BackTestingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    strategyParameters?: NullableJsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    resultLog?: NullableStringFieldUpdateOperationsInput | string | null
    marginPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageInterestRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    finalBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profits?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    losses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestInterestDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lowestInterestDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unrealizedProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ExchangesCreateInput = {
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
    Trades?: TradesCreateNestedManyWithoutExchangeInput
    AskQuotes?: QuotesCreateNestedManyWithoutAskExchangeInput
    BidQuotes?: QuotesCreateNestedManyWithoutBidExchangeInput
  }

  export type ExchangesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
    Trades?: TradesUncheckedCreateNestedManyWithoutExchangeInput
    AskQuotes?: QuotesUncheckedCreateNestedManyWithoutAskExchangeInput
    BidQuotes?: QuotesUncheckedCreateNestedManyWithoutBidExchangeInput
  }

  export type ExchangesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    Trades?: TradesUpdateManyWithoutExchangeNestedInput
    AskQuotes?: QuotesUpdateManyWithoutAskExchangeNestedInput
    BidQuotes?: QuotesUpdateManyWithoutBidExchangeNestedInput
  }

  export type ExchangesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    Trades?: TradesUncheckedUpdateManyWithoutExchangeNestedInput
    AskQuotes?: QuotesUncheckedUpdateManyWithoutAskExchangeNestedInput
    BidQuotes?: QuotesUncheckedUpdateManyWithoutBidExchangeNestedInput
  }

  export type ExchangesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
  }

  export type ExchangesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExchangesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type migrationsCreateInput = {
    timestamp: bigint | number
    name: string
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    timestamp: bigint | number
    name: string
  }

  export type migrationsUpdateInput = {
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsCreateManyInput = {
    id?: number
    timestamp: bigint | number
    name: string
  }

  export type migrationsUpdateManyMutationInput = {
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OrdersCreateInput = {
    id: string
    securityId: number
    strategyName?: string | null
    symbol: string
    name?: string | null
    type: string
    timeInForce: string
    quantity: Decimal | DecimalJsLike | number | string
    filledQuantity: Decimal | DecimalJsLike | number | string
    filledTime?: Date | string | null
    stopPrice?: Decimal | DecimalJsLike | number | string | null
    limitPrice?: Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    orderType?: string | null
    trailAmount?: Decimal | DecimalJsLike | number | string | null
    extendedHours?: boolean
    submittedAt?: Date | string | null
    expiredAt?: Date | string | null
    canceledAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Account?: AccountsCreateNestedOneWithoutOrdersInput
    PositionOrders?: PositionOrdersCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateInput = {
    id: string
    securityId: number
    strategyName?: string | null
    accountId?: string | null
    symbol: string
    name?: string | null
    type: string
    timeInForce: string
    quantity: Decimal | DecimalJsLike | number | string
    filledQuantity: Decimal | DecimalJsLike | number | string
    filledTime?: Date | string | null
    stopPrice?: Decimal | DecimalJsLike | number | string | null
    limitPrice?: Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    orderType?: string | null
    trailAmount?: Decimal | DecimalJsLike | number | string | null
    extendedHours?: boolean
    submittedAt?: Date | string | null
    expiredAt?: Date | string | null
    canceledAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    PositionOrders?: PositionOrdersUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Account?: AccountsUpdateOneWithoutOrdersNestedInput
    PositionOrders?: PositionOrdersUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PositionOrders?: PositionOrdersUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersCreateManyInput = {
    id: string
    securityId: number
    strategyName?: string | null
    accountId?: string | null
    symbol: string
    name?: string | null
    type: string
    timeInForce: string
    quantity: Decimal | DecimalJsLike | number | string
    filledQuantity: Decimal | DecimalJsLike | number | string
    filledTime?: Date | string | null
    stopPrice?: Decimal | DecimalJsLike | number | string | null
    limitPrice?: Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    orderType?: string | null
    trailAmount?: Decimal | DecimalJsLike | number | string | null
    extendedHours?: boolean
    submittedAt?: Date | string | null
    expiredAt?: Date | string | null
    canceledAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OrdersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrdersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PositionsCreateInput = {
    id: string
    price: Decimal | DecimalJsLike | number | string
    securityId: number
    strategyName?: string | null
    name?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    marketValue?: Decimal | DecimalJsLike | number | string | null
    symbol: string
    exchange?: string | null
    positionPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string | null
    type: string
    sellLock: boolean
    Account?: AccountsCreateNestedOneWithoutPositionsInput
    PositionOrders?: PositionOrdersCreateNestedManyWithoutPositionInput
  }

  export type PositionsUncheckedCreateInput = {
    id: string
    price: Decimal | DecimalJsLike | number | string
    securityId: number
    strategyName?: string | null
    name?: string | null
    accountId?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    marketValue?: Decimal | DecimalJsLike | number | string | null
    symbol: string
    exchange?: string | null
    positionPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string | null
    type: string
    sellLock: boolean
    PositionOrders?: PositionOrdersUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
    Account?: AccountsUpdateOneWithoutPositionsNestedInput
    PositionOrders?: PositionOrdersUpdateManyWithoutPositionNestedInput
  }

  export type PositionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
    PositionOrders?: PositionOrdersUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionsCreateManyInput = {
    id: string
    price: Decimal | DecimalJsLike | number | string
    securityId: number
    strategyName?: string | null
    name?: string | null
    accountId?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    marketValue?: Decimal | DecimalJsLike | number | string | null
    symbol: string
    exchange?: string | null
    positionPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string | null
    type: string
    sellLock: boolean
  }

  export type PositionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PositionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PositionOrdersCreateInput = {
    intent: string
    createdAt?: Date | string
    Position?: PositionsCreateNestedOneWithoutPositionOrdersInput
    Order?: OrdersCreateNestedOneWithoutPositionOrdersInput
  }

  export type PositionOrdersUncheckedCreateInput = {
    positionId: string
    orderId: string
    intent: string
    createdAt?: Date | string
  }

  export type PositionOrdersUpdateInput = {
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Position?: PositionsUpdateOneWithoutPositionOrdersNestedInput
    Order?: OrdersUpdateOneWithoutPositionOrdersNestedInput
  }

  export type PositionOrdersUncheckedUpdateInput = {
    positionId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionOrdersCreateManyInput = {
    positionId: string
    orderId: string
    intent: string
    createdAt?: Date | string
  }

  export type PositionOrdersUpdateManyMutationInput = {
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionOrdersUncheckedUpdateManyInput = {
    positionId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreferencesCreateInput = {
    singleTradeRiskLevel?: Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PreferencesUncheckedCreateInput = {
    id?: number
    singleTradeRiskLevel?: Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PreferencesUpdateInput = {
    singleTradeRiskLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PreferencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    singleTradeRiskLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PreferencesCreateManyInput = {
    id?: number
    singleTradeRiskLevel?: Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PreferencesUpdateManyMutationInput = {
    singleTradeRiskLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PreferencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    singleTradeRiskLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allTradeRiskLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    singleTradeVolatilityLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allTradeVolatilityLevel?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lowestStockPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorDailyCreateInput = {
    calendarDate: Date | string
    realtimeReturn: Decimal | DecimalJsLike | number | string
    oneDayReturn: Decimal | DecimalJsLike | number | string
    fiveDayReturn: Decimal | DecimalJsLike | number | string
    oneMonthReturn: Decimal | DecimalJsLike | number | string
    threeMonthReturn: Decimal | DecimalJsLike | number | string
    oneYearReturn: Decimal | DecimalJsLike | number | string
    threeYearReturn: Decimal | DecimalJsLike | number | string
    fiveYearReturn: Decimal | DecimalJsLike | number | string
    tenYearReturn: Decimal | DecimalJsLike | number | string
    ytdReturn: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Sector: SectorsCreateNestedOneWithoutSectorDailyInput
  }

  export type SectorDailyUncheckedCreateInput = {
    id?: number
    sectorId: number
    calendarDate: Date | string
    realtimeReturn: Decimal | DecimalJsLike | number | string
    oneDayReturn: Decimal | DecimalJsLike | number | string
    fiveDayReturn: Decimal | DecimalJsLike | number | string
    oneMonthReturn: Decimal | DecimalJsLike | number | string
    threeMonthReturn: Decimal | DecimalJsLike | number | string
    oneYearReturn: Decimal | DecimalJsLike | number | string
    threeYearReturn: Decimal | DecimalJsLike | number | string
    fiveYearReturn: Decimal | DecimalJsLike | number | string
    tenYearReturn: Decimal | DecimalJsLike | number | string
    ytdReturn: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SectorDailyUpdateInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    realtimeReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sector?: SectorsUpdateOneRequiredWithoutSectorDailyNestedInput
  }

  export type SectorDailyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectorId?: IntFieldUpdateOperationsInput | number
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    realtimeReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorDailyCreateManyInput = {
    id?: number
    sectorId: number
    calendarDate: Date | string
    realtimeReturn: Decimal | DecimalJsLike | number | string
    oneDayReturn: Decimal | DecimalJsLike | number | string
    fiveDayReturn: Decimal | DecimalJsLike | number | string
    oneMonthReturn: Decimal | DecimalJsLike | number | string
    threeMonthReturn: Decimal | DecimalJsLike | number | string
    oneYearReturn: Decimal | DecimalJsLike | number | string
    threeYearReturn: Decimal | DecimalJsLike | number | string
    fiveYearReturn: Decimal | DecimalJsLike | number | string
    tenYearReturn: Decimal | DecimalJsLike | number | string
    ytdReturn: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SectorDailyUpdateManyMutationInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    realtimeReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorDailyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectorId?: IntFieldUpdateOperationsInput | number
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    realtimeReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorsCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SectorDaily?: SectorDailyCreateNestedManyWithoutSectorInput
  }

  export type SectorsUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SectorDaily?: SectorDailyUncheckedCreateNestedManyWithoutSectorInput
  }

  export type SectorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SectorDaily?: SectorDailyUpdateManyWithoutSectorNestedInput
  }

  export type SectorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SectorDaily?: SectorDailyUncheckedUpdateManyWithoutSectorNestedInput
  }

  export type SectorsCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SectorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritiesCreateInput = {
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsCreateNestedManyWithoutSecurityInput
    Trades?: TradesCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUncheckedCreateInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyUncheckedCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsUncheckedCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsUncheckedCreateNestedManyWithoutSecurityInput
    Trades?: TradesUncheckedCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUncheckedUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUncheckedUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesCreateManyInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
  }

  export type SecuritiesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SecuritiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SecurityDailyCreateInput = {
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    adjustedClose?: Decimal | DecimalJsLike | number | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: Decimal | DecimalJsLike | number | string | null
    peRatio?: Decimal | DecimalJsLike | number | string | null
    pbRatio?: Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: Decimal | DecimalJsLike | number | string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: Decimal | DecimalJsLike | number | string | null
    volume: number
    adjusted?: boolean
    calendarDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Security: SecuritiesCreateNestedOneWithoutSecurityDailyInput
  }

  export type SecurityDailyUncheckedCreateInput = {
    id?: number
    securityId: number
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    adjustedClose?: Decimal | DecimalJsLike | number | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: Decimal | DecimalJsLike | number | string | null
    peRatio?: Decimal | DecimalJsLike | number | string | null
    pbRatio?: Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: Decimal | DecimalJsLike | number | string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: Decimal | DecimalJsLike | number | string | null
    volume: number
    adjusted?: boolean
    calendarDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDailyUpdateInput = {
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    peRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pbRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: IntFieldUpdateOperationsInput | number
    adjusted?: BoolFieldUpdateOperationsInput | boolean
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Security?: SecuritiesUpdateOneRequiredWithoutSecurityDailyNestedInput
  }

  export type SecurityDailyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    peRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pbRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: IntFieldUpdateOperationsInput | number
    adjusted?: BoolFieldUpdateOperationsInput | boolean
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDailyCreateManyInput = {
    id?: number
    securityId: number
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    adjustedClose?: Decimal | DecimalJsLike | number | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: Decimal | DecimalJsLike | number | string | null
    peRatio?: Decimal | DecimalJsLike | number | string | null
    pbRatio?: Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: Decimal | DecimalJsLike | number | string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: Decimal | DecimalJsLike | number | string | null
    volume: number
    adjusted?: boolean
    calendarDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDailyUpdateManyMutationInput = {
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    peRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pbRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: IntFieldUpdateOperationsInput | number
    adjusted?: BoolFieldUpdateOperationsInput | boolean
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDailyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    peRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pbRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: IntFieldUpdateOperationsInput | number
    adjusted?: BoolFieldUpdateOperationsInput | boolean
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDividendsCreateInput = {
    expirationDate?: Date | string | null
    paymentDate: Date | string
    recordDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Security: SecuritiesCreateNestedOneWithoutSecurityDividendsInput
  }

  export type SecurityDividendsUncheckedCreateInput = {
    id?: number
    securityId: number
    expirationDate?: Date | string | null
    paymentDate: Date | string
    recordDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDividendsUpdateInput = {
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Security?: SecuritiesUpdateOneRequiredWithoutSecurityDividendsNestedInput
  }

  export type SecurityDividendsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDividendsCreateManyInput = {
    id?: number
    securityId: number
    expirationDate?: Date | string | null
    paymentDate: Date | string
    recordDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDividendsUpdateManyMutationInput = {
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDividendsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityIndexTypesCreateInput = {
    name: string
    description?: string | null
  }

  export type SecurityIndexTypesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type SecurityIndexTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityIndexTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityIndexTypesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type SecurityIndexTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityIndexTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityMinutelyCreateInput = {
    calendarDate: Date | string
    minute?: string | null
    label?: string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    marketHigh?: Decimal | DecimalJsLike | number | string | null
    marketLow?: Decimal | DecimalJsLike | number | string | null
    marketAverage?: Decimal | DecimalJsLike | number | string | null
    marketVolume?: bigint | number | null
    marketNotional?: Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: bigint | number | null
    marketOpen?: Decimal | DecimalJsLike | number | string | null
    marketClose?: Decimal | DecimalJsLike | number | string | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    dateTime?: Date | string | null
    Security: SecuritiesCreateNestedOneWithoutSecurityMinutelyInput
  }

  export type SecurityMinutelyUncheckedCreateInput = {
    securityId: number
    calendarDate: Date | string
    minute?: string | null
    label?: string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    marketHigh?: Decimal | DecimalJsLike | number | string | null
    marketLow?: Decimal | DecimalJsLike | number | string | null
    marketAverage?: Decimal | DecimalJsLike | number | string | null
    marketVolume?: bigint | number | null
    marketNotional?: Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: bigint | number | null
    marketOpen?: Decimal | DecimalJsLike | number | string | null
    marketClose?: Decimal | DecimalJsLike | number | string | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    dateTime?: Date | string | null
  }

  export type SecurityMinutelyUpdateInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minute?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketVolume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketNotional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketOpen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Security?: SecuritiesUpdateOneRequiredWithoutSecurityMinutelyNestedInput
  }

  export type SecurityMinutelyUncheckedUpdateInput = {
    securityId?: IntFieldUpdateOperationsInput | number
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minute?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketVolume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketNotional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketOpen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityMinutelyCreateManyInput = {
    securityId: number
    calendarDate: Date | string
    minute?: string | null
    label?: string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    marketHigh?: Decimal | DecimalJsLike | number | string | null
    marketLow?: Decimal | DecimalJsLike | number | string | null
    marketAverage?: Decimal | DecimalJsLike | number | string | null
    marketVolume?: bigint | number | null
    marketNotional?: Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: bigint | number | null
    marketOpen?: Decimal | DecimalJsLike | number | string | null
    marketClose?: Decimal | DecimalJsLike | number | string | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    dateTime?: Date | string | null
  }

  export type SecurityMinutelyUpdateManyMutationInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minute?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketVolume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketNotional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketOpen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityMinutelyUncheckedUpdateManyInput = {
    securityId?: IntFieldUpdateOperationsInput | number
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minute?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketVolume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketNotional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketOpen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritySecondlyCreateInput = {
    calendarDate: Date | string
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Security: SecuritiesCreateNestedOneWithoutSecuritySecondlyInput
  }

  export type SecuritySecondlyUncheckedCreateInput = {
    calendarDate: Date | string
    securityId: number
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecuritySecondlyUpdateInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Security?: SecuritiesUpdateOneRequiredWithoutSecuritySecondlyNestedInput
  }

  export type SecuritySecondlyUncheckedUpdateInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    securityId?: IntFieldUpdateOperationsInput | number
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritySecondlyCreateManyInput = {
    calendarDate: Date | string
    securityId: number
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecuritySecondlyUpdateManyMutationInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritySecondlyUncheckedUpdateManyInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    securityId?: IntFieldUpdateOperationsInput | number
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritySplitsCreateInput = {
    paymentDate: Date | string
    ratio: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exercisedDate: Date | string
    declaredDate: Date | string
    toFactor: number
    fromFactor: number
    description?: string | null
    Security: SecuritiesCreateNestedOneWithoutSecuritySplitsInput
  }

  export type SecuritySplitsUncheckedCreateInput = {
    id?: number
    securityId: number
    paymentDate: Date | string
    ratio: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exercisedDate: Date | string
    declaredDate: Date | string
    toFactor: number
    fromFactor: number
    description?: string | null
  }

  export type SecuritySplitsUpdateInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ratio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercisedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    declaredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toFactor?: IntFieldUpdateOperationsInput | number
    fromFactor?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Security?: SecuritiesUpdateOneRequiredWithoutSecuritySplitsNestedInput
  }

  export type SecuritySplitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ratio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercisedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    declaredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toFactor?: IntFieldUpdateOperationsInput | number
    fromFactor?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecuritySplitsCreateManyInput = {
    id?: number
    securityId: number
    paymentDate: Date | string
    ratio: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exercisedDate: Date | string
    declaredDate: Date | string
    toFactor: number
    fromFactor: number
    description?: string | null
  }

  export type SecuritySplitsUpdateManyMutationInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ratio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercisedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    declaredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toFactor?: IntFieldUpdateOperationsInput | number
    fromFactor?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecuritySplitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ratio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercisedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    declaredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toFactor?: IntFieldUpdateOperationsInput | number
    fromFactor?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityTypesCreateInput = {
    name: string
    description?: string | null
  }

  export type SecurityTypesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type SecurityTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityTypesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type SecurityTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecurityTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategiesCreateInput = {
    name: string
    description?: string | null
    StrategyParameters?: StrategyParametersCreateNestedManyWithoutStrategyInput
  }

  export type StrategiesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    StrategyParameters?: StrategyParametersUncheckedCreateNestedManyWithoutStrategyInput
  }

  export type StrategiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    StrategyParameters?: StrategyParametersUpdateManyWithoutStrategyNestedInput
  }

  export type StrategiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    StrategyParameters?: StrategyParametersUncheckedUpdateManyWithoutStrategyNestedInput
  }

  export type StrategiesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type StrategiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategyParametersCreateInput = {
    key: string
    value: string
    dataType?: string | null
    Strategy: StrategiesCreateNestedOneWithoutStrategyParametersInput
  }

  export type StrategyParametersUncheckedCreateInput = {
    id?: number
    strategyId: number
    key: string
    value: string
    dataType?: string | null
  }

  export type StrategyParametersUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
    Strategy?: StrategiesUpdateOneRequiredWithoutStrategyParametersNestedInput
  }

  export type StrategyParametersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    strategyId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategyParametersCreateManyInput = {
    id?: number
    strategyId: number
    key: string
    value: string
    dataType?: string | null
  }

  export type StrategyParametersUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategyParametersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    strategyId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TradesCreateInput = {
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Exchange: ExchangesCreateNestedOneWithoutTradesInput
    Security: SecuritiesCreateNestedOneWithoutTradesInput
    Conditions?: ConditionsCreateNestedManyWithoutTradeInput
  }

  export type TradesUncheckedCreateInput = {
    id?: number
    securityId: number
    exchangeId: number
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Conditions?: ConditionsUncheckedCreateNestedManyWithoutTradeInput
  }

  export type TradesUpdateInput = {
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Exchange?: ExchangesUpdateOneRequiredWithoutTradesNestedInput
    Security?: SecuritiesUpdateOneRequiredWithoutTradesNestedInput
    Conditions?: ConditionsUpdateManyWithoutTradeNestedInput
  }

  export type TradesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    exchangeId?: IntFieldUpdateOperationsInput | number
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conditions?: ConditionsUncheckedUpdateManyWithoutTradeNestedInput
  }

  export type TradesCreateManyInput = {
    id?: number
    securityId: number
    exchangeId: number
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TradesUpdateManyMutationInput = {
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    exchangeId?: IntFieldUpdateOperationsInput | number
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesCreateInput = {
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    AskExchange: ExchangesCreateNestedOneWithoutAskQuotesInput
    BidExchange: ExchangesCreateNestedOneWithoutBidQuotesInput
    Security: SecuritiesCreateNestedOneWithoutQuotesInput
    Conditions?: ConditionsCreateNestedManyWithoutQuoteInput
  }

  export type QuotesUncheckedCreateInput = {
    id?: number
    securityId: number
    bidExchangeId: number
    askExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    Conditions?: ConditionsUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuotesUpdateInput = {
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AskExchange?: ExchangesUpdateOneRequiredWithoutAskQuotesNestedInput
    BidExchange?: ExchangesUpdateOneRequiredWithoutBidQuotesNestedInput
    Security?: SecuritiesUpdateOneRequiredWithoutQuotesNestedInput
    Conditions?: ConditionsUpdateManyWithoutQuoteNestedInput
  }

  export type QuotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    bidExchangeId?: IntFieldUpdateOperationsInput | number
    askExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conditions?: ConditionsUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuotesCreateManyInput = {
    id?: number
    securityId: number
    bidExchangeId: number
    askExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type QuotesUpdateManyMutationInput = {
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    bidExchangeId?: IntFieldUpdateOperationsInput | number
    askExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionsCreateInput = {
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
    Trade: TradesCreateNestedOneWithoutConditionsInput
    Quote: QuotesCreateNestedOneWithoutConditionsInput
  }

  export type ConditionsUncheckedCreateInput = {
    id?: number
    tradeId: number
    quoteId: number
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
  }

  export type ConditionsUpdateInput = {
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Trade?: TradesUpdateOneRequiredWithoutConditionsNestedInput
    Quote?: QuotesUpdateOneRequiredWithoutConditionsNestedInput
  }

  export type ConditionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tradeId?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionsCreateManyInput = {
    id?: number
    tradeId: number
    quoteId: number
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
  }

  export type ConditionsUpdateManyMutationInput = {
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tradeId?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type OrdersListRelationFilter = {
    every?: OrdersWhereInput
    some?: OrdersWhereInput
    none?: OrdersWhereInput
  }

  export type PositionsListRelationFilter = {
    every?: PositionsWhereInput
    some?: PositionsWhereInput
    none?: PositionsWhereInput
  }

  export type OrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    marketValue?: SortOrder
    buyingPower?: SortOrder
    cash?: SortOrder
    currency?: SortOrder
    daytradeCount?: SortOrder
    daytradeBuyingPower?: SortOrder
    regulationTBuyingPower?: SortOrder
    initialMargin?: SortOrder
    lastMaintenanceMargin?: SortOrder
    longMarketValue?: SortOrder
    shortMarketValue?: SortOrder
    maintenanceMargin?: SortOrder
    multiplier?: SortOrder
    sma?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountsAvgOrderByAggregateInput = {
    marketValue?: SortOrder
    buyingPower?: SortOrder
    cash?: SortOrder
    daytradeCount?: SortOrder
    daytradeBuyingPower?: SortOrder
    regulationTBuyingPower?: SortOrder
    initialMargin?: SortOrder
    lastMaintenanceMargin?: SortOrder
    longMarketValue?: SortOrder
    shortMarketValue?: SortOrder
    maintenanceMargin?: SortOrder
    multiplier?: SortOrder
    sma?: SortOrder
  }

  export type AccountsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    marketValue?: SortOrder
    buyingPower?: SortOrder
    cash?: SortOrder
    currency?: SortOrder
    daytradeCount?: SortOrder
    daytradeBuyingPower?: SortOrder
    regulationTBuyingPower?: SortOrder
    initialMargin?: SortOrder
    lastMaintenanceMargin?: SortOrder
    longMarketValue?: SortOrder
    shortMarketValue?: SortOrder
    maintenanceMargin?: SortOrder
    multiplier?: SortOrder
    sma?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    marketValue?: SortOrder
    buyingPower?: SortOrder
    cash?: SortOrder
    currency?: SortOrder
    daytradeCount?: SortOrder
    daytradeBuyingPower?: SortOrder
    regulationTBuyingPower?: SortOrder
    initialMargin?: SortOrder
    lastMaintenanceMargin?: SortOrder
    longMarketValue?: SortOrder
    shortMarketValue?: SortOrder
    maintenanceMargin?: SortOrder
    multiplier?: SortOrder
    sma?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountsSumOrderByAggregateInput = {
    marketValue?: SortOrder
    buyingPower?: SortOrder
    cash?: SortOrder
    daytradeCount?: SortOrder
    daytradeBuyingPower?: SortOrder
    regulationTBuyingPower?: SortOrder
    initialMargin?: SortOrder
    lastMaintenanceMargin?: SortOrder
    longMarketValue?: SortOrder
    shortMarketValue?: SortOrder
    maintenanceMargin?: SortOrder
    multiplier?: SortOrder
    sma?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type AmeritradeEventsCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmeritradeEventsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmeritradeEventsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type AmeritradeTokensCountOrderByAggregateInput = {
    id?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmeritradeTokensAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AmeritradeTokensMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmeritradeTokensMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmeritradeTokensSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type BackTestingCountOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    strategyParameters?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    resultLog?: SortOrder
    marginPercentage?: SortOrder
    averageInterestRate?: SortOrder
    finalBalance?: SortOrder
    profits?: SortOrder
    losses?: SortOrder
    highestInterestDay?: SortOrder
    lowestInterestDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    unrealizedProfit?: SortOrder
  }

  export type BackTestingAvgOrderByAggregateInput = {
    marginPercentage?: SortOrder
    averageInterestRate?: SortOrder
    finalBalance?: SortOrder
    profits?: SortOrder
    losses?: SortOrder
    highestInterestDay?: SortOrder
    lowestInterestDay?: SortOrder
    unrealizedProfit?: SortOrder
  }

  export type BackTestingMaxOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    resultLog?: SortOrder
    marginPercentage?: SortOrder
    averageInterestRate?: SortOrder
    finalBalance?: SortOrder
    profits?: SortOrder
    losses?: SortOrder
    highestInterestDay?: SortOrder
    lowestInterestDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    unrealizedProfit?: SortOrder
  }

  export type BackTestingMinOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    resultLog?: SortOrder
    marginPercentage?: SortOrder
    averageInterestRate?: SortOrder
    finalBalance?: SortOrder
    profits?: SortOrder
    losses?: SortOrder
    highestInterestDay?: SortOrder
    lowestInterestDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    unrealizedProfit?: SortOrder
  }

  export type BackTestingSumOrderByAggregateInput = {
    marginPercentage?: SortOrder
    averageInterestRate?: SortOrder
    finalBalance?: SortOrder
    profits?: SortOrder
    losses?: SortOrder
    highestInterestDay?: SortOrder
    lowestInterestDay?: SortOrder
    unrealizedProfit?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type TradesListRelationFilter = {
    every?: TradesWhereInput
    some?: TradesWhereInput
    none?: TradesWhereInput
  }

  export type QuotesListRelationFilter = {
    every?: QuotesWhereInput
    some?: QuotesWhereInput
    none?: QuotesWhereInput
  }

  export type TradesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExchangesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assetClass?: SortOrder
    locale?: SortOrder
    acronym?: SortOrder
    mic?: SortOrder
    operatingMic?: SortOrder
    participantId?: SortOrder
    url?: SortOrder
  }

  export type ExchangesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExchangesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assetClass?: SortOrder
    locale?: SortOrder
    acronym?: SortOrder
    mic?: SortOrder
    operatingMic?: SortOrder
    participantId?: SortOrder
    url?: SortOrder
  }

  export type ExchangesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assetClass?: SortOrder
    locale?: SortOrder
    acronym?: SortOrder
    mic?: SortOrder
    operatingMic?: SortOrder
    participantId?: SortOrder
    url?: SortOrder
  }

  export type ExchangesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type AccountsRelationFilter = {
    is?: AccountsWhereInput | null
    isNot?: AccountsWhereInput | null
  }

  export type PositionOrdersListRelationFilter = {
    every?: PositionOrdersWhereInput
    some?: PositionOrdersWhereInput
    none?: PositionOrdersWhereInput
  }

  export type PositionOrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersCountOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    accountId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    type?: SortOrder
    timeInForce?: SortOrder
    quantity?: SortOrder
    filledQuantity?: SortOrder
    filledTime?: SortOrder
    stopPrice?: SortOrder
    limitPrice?: SortOrder
    filledAveragePrice?: SortOrder
    status?: SortOrder
    orderType?: SortOrder
    trailAmount?: SortOrder
    extendedHours?: SortOrder
    submittedAt?: SortOrder
    expiredAt?: SortOrder
    canceledAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdersAvgOrderByAggregateInput = {
    securityId?: SortOrder
    quantity?: SortOrder
    filledQuantity?: SortOrder
    stopPrice?: SortOrder
    limitPrice?: SortOrder
    filledAveragePrice?: SortOrder
    trailAmount?: SortOrder
  }

  export type OrdersMaxOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    accountId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    type?: SortOrder
    timeInForce?: SortOrder
    quantity?: SortOrder
    filledQuantity?: SortOrder
    filledTime?: SortOrder
    stopPrice?: SortOrder
    limitPrice?: SortOrder
    filledAveragePrice?: SortOrder
    status?: SortOrder
    orderType?: SortOrder
    trailAmount?: SortOrder
    extendedHours?: SortOrder
    submittedAt?: SortOrder
    expiredAt?: SortOrder
    canceledAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdersMinOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    accountId?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    type?: SortOrder
    timeInForce?: SortOrder
    quantity?: SortOrder
    filledQuantity?: SortOrder
    filledTime?: SortOrder
    stopPrice?: SortOrder
    limitPrice?: SortOrder
    filledAveragePrice?: SortOrder
    status?: SortOrder
    orderType?: SortOrder
    trailAmount?: SortOrder
    extendedHours?: SortOrder
    submittedAt?: SortOrder
    expiredAt?: SortOrder
    canceledAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdersSumOrderByAggregateInput = {
    securityId?: SortOrder
    quantity?: SortOrder
    filledQuantity?: SortOrder
    stopPrice?: SortOrder
    limitPrice?: SortOrder
    filledAveragePrice?: SortOrder
    trailAmount?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type PositionsCountOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    quantity?: SortOrder
    marketValue?: SortOrder
    symbol?: SortOrder
    exchange?: SortOrder
    positionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    sellLock?: SortOrder
  }

  export type PositionsAvgOrderByAggregateInput = {
    price?: SortOrder
    securityId?: SortOrder
    quantity?: SortOrder
    marketValue?: SortOrder
    positionPercent?: SortOrder
  }

  export type PositionsMaxOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    quantity?: SortOrder
    marketValue?: SortOrder
    symbol?: SortOrder
    exchange?: SortOrder
    positionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    sellLock?: SortOrder
  }

  export type PositionsMinOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    securityId?: SortOrder
    strategyName?: SortOrder
    name?: SortOrder
    accountId?: SortOrder
    quantity?: SortOrder
    marketValue?: SortOrder
    symbol?: SortOrder
    exchange?: SortOrder
    positionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    sellLock?: SortOrder
  }

  export type PositionsSumOrderByAggregateInput = {
    price?: SortOrder
    securityId?: SortOrder
    quantity?: SortOrder
    marketValue?: SortOrder
    positionPercent?: SortOrder
  }

  export type PositionsRelationFilter = {
    is?: PositionsWhereInput | null
    isNot?: PositionsWhereInput | null
  }

  export type OrdersRelationFilter = {
    is?: OrdersWhereInput | null
    isNot?: OrdersWhereInput | null
  }

  export type PositionOrdersPositionIdOrderIdIntentCreatedAtCompoundUniqueInput = {
    positionId: string
    orderId: string
    intent: string
    createdAt: Date | string
  }

  export type PositionOrdersCountOrderByAggregateInput = {
    positionId?: SortOrder
    orderId?: SortOrder
    intent?: SortOrder
    createdAt?: SortOrder
  }

  export type PositionOrdersMaxOrderByAggregateInput = {
    positionId?: SortOrder
    orderId?: SortOrder
    intent?: SortOrder
    createdAt?: SortOrder
  }

  export type PositionOrdersMinOrderByAggregateInput = {
    positionId?: SortOrder
    orderId?: SortOrder
    intent?: SortOrder
    createdAt?: SortOrder
  }

  export type PreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    singleTradeRiskLevel?: SortOrder
    allTradeRiskLevel?: SortOrder
    singleTradeVolatilityLevel?: SortOrder
    allTradeVolatilityLevel?: SortOrder
    lowestStockPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreferencesAvgOrderByAggregateInput = {
    id?: SortOrder
    singleTradeRiskLevel?: SortOrder
    allTradeRiskLevel?: SortOrder
    singleTradeVolatilityLevel?: SortOrder
    allTradeVolatilityLevel?: SortOrder
    lowestStockPrice?: SortOrder
  }

  export type PreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    singleTradeRiskLevel?: SortOrder
    allTradeRiskLevel?: SortOrder
    singleTradeVolatilityLevel?: SortOrder
    allTradeVolatilityLevel?: SortOrder
    lowestStockPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    singleTradeRiskLevel?: SortOrder
    allTradeRiskLevel?: SortOrder
    singleTradeVolatilityLevel?: SortOrder
    allTradeVolatilityLevel?: SortOrder
    lowestStockPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PreferencesSumOrderByAggregateInput = {
    id?: SortOrder
    singleTradeRiskLevel?: SortOrder
    allTradeRiskLevel?: SortOrder
    singleTradeVolatilityLevel?: SortOrder
    allTradeVolatilityLevel?: SortOrder
    lowestStockPrice?: SortOrder
  }

  export type SectorsRelationFilter = {
    is?: SectorsWhereInput
    isNot?: SectorsWhereInput
  }

  export type SectorDailyCountOrderByAggregateInput = {
    id?: SortOrder
    sectorId?: SortOrder
    calendarDate?: SortOrder
    realtimeReturn?: SortOrder
    oneDayReturn?: SortOrder
    fiveDayReturn?: SortOrder
    oneMonthReturn?: SortOrder
    threeMonthReturn?: SortOrder
    oneYearReturn?: SortOrder
    threeYearReturn?: SortOrder
    fiveYearReturn?: SortOrder
    tenYearReturn?: SortOrder
    ytdReturn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorDailyAvgOrderByAggregateInput = {
    id?: SortOrder
    sectorId?: SortOrder
    realtimeReturn?: SortOrder
    oneDayReturn?: SortOrder
    fiveDayReturn?: SortOrder
    oneMonthReturn?: SortOrder
    threeMonthReturn?: SortOrder
    oneYearReturn?: SortOrder
    threeYearReturn?: SortOrder
    fiveYearReturn?: SortOrder
    tenYearReturn?: SortOrder
    ytdReturn?: SortOrder
  }

  export type SectorDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    sectorId?: SortOrder
    calendarDate?: SortOrder
    realtimeReturn?: SortOrder
    oneDayReturn?: SortOrder
    fiveDayReturn?: SortOrder
    oneMonthReturn?: SortOrder
    threeMonthReturn?: SortOrder
    oneYearReturn?: SortOrder
    threeYearReturn?: SortOrder
    fiveYearReturn?: SortOrder
    tenYearReturn?: SortOrder
    ytdReturn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorDailyMinOrderByAggregateInput = {
    id?: SortOrder
    sectorId?: SortOrder
    calendarDate?: SortOrder
    realtimeReturn?: SortOrder
    oneDayReturn?: SortOrder
    fiveDayReturn?: SortOrder
    oneMonthReturn?: SortOrder
    threeMonthReturn?: SortOrder
    oneYearReturn?: SortOrder
    threeYearReturn?: SortOrder
    fiveYearReturn?: SortOrder
    tenYearReturn?: SortOrder
    ytdReturn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorDailySumOrderByAggregateInput = {
    id?: SortOrder
    sectorId?: SortOrder
    realtimeReturn?: SortOrder
    oneDayReturn?: SortOrder
    fiveDayReturn?: SortOrder
    oneMonthReturn?: SortOrder
    threeMonthReturn?: SortOrder
    oneYearReturn?: SortOrder
    threeYearReturn?: SortOrder
    fiveYearReturn?: SortOrder
    tenYearReturn?: SortOrder
    ytdReturn?: SortOrder
  }

  export type SectorDailyListRelationFilter = {
    every?: SectorDailyWhereInput
    some?: SectorDailyWhereInput
    none?: SectorDailyWhereInput
  }

  export type SectorDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SectorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type SecurityDailyListRelationFilter = {
    every?: SecurityDailyWhereInput
    some?: SecurityDailyWhereInput
    none?: SecurityDailyWhereInput
  }

  export type SecurityDividendsListRelationFilter = {
    every?: SecurityDividendsWhereInput
    some?: SecurityDividendsWhereInput
    none?: SecurityDividendsWhereInput
  }

  export type SecurityMinutelyListRelationFilter = {
    every?: SecurityMinutelyWhereInput
    some?: SecurityMinutelyWhereInput
    none?: SecurityMinutelyWhereInput
  }

  export type SecuritySecondlyListRelationFilter = {
    every?: SecuritySecondlyWhereInput
    some?: SecuritySecondlyWhereInput
    none?: SecuritySecondlyWhereInput
  }

  export type SecuritySplitsListRelationFilter = {
    every?: SecuritySplitsWhereInput
    some?: SecuritySplitsWhereInput
    none?: SecuritySplitsWhereInput
  }

  export type SecurityDailyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityDividendsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecurityMinutelyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecuritySecondlyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecuritySplitsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SecuritiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    cusip?: SortOrder
    exchange?: SortOrder
    securityTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketCap?: SortOrder
    companyName?: SortOrder
    sector?: SortOrder
    active?: SortOrder
    delistedCalendarDate?: SortOrder
    companyDescription?: SortOrder
    url?: SortOrder
    sharesOutstanding?: SortOrder
    numberOfEmployees?: SortOrder
  }

  export type SecuritiesAvgOrderByAggregateInput = {
    id?: SortOrder
    securityTypeId?: SortOrder
    marketCap?: SortOrder
    sharesOutstanding?: SortOrder
    numberOfEmployees?: SortOrder
  }

  export type SecuritiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    cusip?: SortOrder
    exchange?: SortOrder
    securityTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketCap?: SortOrder
    companyName?: SortOrder
    sector?: SortOrder
    active?: SortOrder
    delistedCalendarDate?: SortOrder
    companyDescription?: SortOrder
    url?: SortOrder
    sharesOutstanding?: SortOrder
    numberOfEmployees?: SortOrder
  }

  export type SecuritiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    cusip?: SortOrder
    exchange?: SortOrder
    securityTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketCap?: SortOrder
    companyName?: SortOrder
    sector?: SortOrder
    active?: SortOrder
    delistedCalendarDate?: SortOrder
    companyDescription?: SortOrder
    url?: SortOrder
    sharesOutstanding?: SortOrder
    numberOfEmployees?: SortOrder
  }

  export type SecuritiesSumOrderByAggregateInput = {
    id?: SortOrder
    securityTypeId?: SortOrder
    marketCap?: SortOrder
    sharesOutstanding?: SortOrder
    numberOfEmployees?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type SecuritiesRelationFilter = {
    is?: SecuritiesWhereInput
    isNot?: SecuritiesWhereInput
  }

  export type SecurityDailySecurityIdCalendarDateCompoundUniqueInput = {
    securityId: number
    calendarDate: Date | string
  }

  export type SecurityDailyCountOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    adjustedClose?: SortOrder
    marketCap?: SortOrder
    enterpriseValue?: SortOrder
    peRatio?: SortOrder
    pbRatio?: SortOrder
    trailingOneYearPegRatio?: SortOrder
    dividendAmount?: SortOrder
    splitCoefficient?: SortOrder
    volume?: SortOrder
    adjusted?: SortOrder
    calendarDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityDailyAvgOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    adjustedClose?: SortOrder
    marketCap?: SortOrder
    enterpriseValue?: SortOrder
    peRatio?: SortOrder
    pbRatio?: SortOrder
    trailingOneYearPegRatio?: SortOrder
    dividendAmount?: SortOrder
    splitCoefficient?: SortOrder
    volume?: SortOrder
  }

  export type SecurityDailyMaxOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    adjustedClose?: SortOrder
    marketCap?: SortOrder
    enterpriseValue?: SortOrder
    peRatio?: SortOrder
    pbRatio?: SortOrder
    trailingOneYearPegRatio?: SortOrder
    dividendAmount?: SortOrder
    splitCoefficient?: SortOrder
    volume?: SortOrder
    adjusted?: SortOrder
    calendarDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityDailyMinOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    adjustedClose?: SortOrder
    marketCap?: SortOrder
    enterpriseValue?: SortOrder
    peRatio?: SortOrder
    pbRatio?: SortOrder
    trailingOneYearPegRatio?: SortOrder
    dividendAmount?: SortOrder
    splitCoefficient?: SortOrder
    volume?: SortOrder
    adjusted?: SortOrder
    calendarDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityDailySumOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    high?: SortOrder
    low?: SortOrder
    close?: SortOrder
    adjustedClose?: SortOrder
    marketCap?: SortOrder
    enterpriseValue?: SortOrder
    peRatio?: SortOrder
    pbRatio?: SortOrder
    trailingOneYearPegRatio?: SortOrder
    dividendAmount?: SortOrder
    splitCoefficient?: SortOrder
    volume?: SortOrder
  }

  export type SecurityDividendsCountOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    expirationDate?: SortOrder
    paymentDate?: SortOrder
    recordDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityDividendsAvgOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    amount?: SortOrder
  }

  export type SecurityDividendsMaxOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    expirationDate?: SortOrder
    paymentDate?: SortOrder
    recordDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityDividendsMinOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    expirationDate?: SortOrder
    paymentDate?: SortOrder
    recordDate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecurityDividendsSumOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    amount?: SortOrder
  }

  export type SecurityIndexTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SecurityIndexTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SecurityIndexTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SecurityIndexTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SecurityIndexTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type SecurityMinutelySecurityIdCalendarDateCompoundUniqueInput = {
    securityId: number
    calendarDate: Date | string
  }

  export type SecurityMinutelyCountOrderByAggregateInput = {
    securityId?: SortOrder
    calendarDate?: SortOrder
    minute?: SortOrder
    label?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    marketHigh?: SortOrder
    marketLow?: SortOrder
    marketAverage?: SortOrder
    marketVolume?: SortOrder
    marketNotional?: SortOrder
    marketNumberOfTrades?: SortOrder
    marketOpen?: SortOrder
    marketClose?: SortOrder
    changeOverTime?: SortOrder
    marketChangeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateTime?: SortOrder
  }

  export type SecurityMinutelyAvgOrderByAggregateInput = {
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    marketHigh?: SortOrder
    marketLow?: SortOrder
    marketAverage?: SortOrder
    marketVolume?: SortOrder
    marketNotional?: SortOrder
    marketNumberOfTrades?: SortOrder
    marketOpen?: SortOrder
    marketClose?: SortOrder
    changeOverTime?: SortOrder
    marketChangeOverTime?: SortOrder
  }

  export type SecurityMinutelyMaxOrderByAggregateInput = {
    securityId?: SortOrder
    calendarDate?: SortOrder
    minute?: SortOrder
    label?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    marketHigh?: SortOrder
    marketLow?: SortOrder
    marketAverage?: SortOrder
    marketVolume?: SortOrder
    marketNotional?: SortOrder
    marketNumberOfTrades?: SortOrder
    marketOpen?: SortOrder
    marketClose?: SortOrder
    changeOverTime?: SortOrder
    marketChangeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateTime?: SortOrder
  }

  export type SecurityMinutelyMinOrderByAggregateInput = {
    securityId?: SortOrder
    calendarDate?: SortOrder
    minute?: SortOrder
    label?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    marketHigh?: SortOrder
    marketLow?: SortOrder
    marketAverage?: SortOrder
    marketVolume?: SortOrder
    marketNotional?: SortOrder
    marketNumberOfTrades?: SortOrder
    marketOpen?: SortOrder
    marketClose?: SortOrder
    changeOverTime?: SortOrder
    marketChangeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dateTime?: SortOrder
  }

  export type SecurityMinutelySumOrderByAggregateInput = {
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    marketHigh?: SortOrder
    marketLow?: SortOrder
    marketAverage?: SortOrder
    marketVolume?: SortOrder
    marketNotional?: SortOrder
    marketNumberOfTrades?: SortOrder
    marketOpen?: SortOrder
    marketClose?: SortOrder
    changeOverTime?: SortOrder
    marketChangeOverTime?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type SecuritySecondlySecurityIdCalendarDateCompoundUniqueInput = {
    securityId: number
    calendarDate: Date | string
  }

  export type SecuritySecondlyCountOrderByAggregateInput = {
    calendarDate?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    changeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecuritySecondlyAvgOrderByAggregateInput = {
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    changeOverTime?: SortOrder
  }

  export type SecuritySecondlyMaxOrderByAggregateInput = {
    calendarDate?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    changeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecuritySecondlyMinOrderByAggregateInput = {
    calendarDate?: SortOrder
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    changeOverTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SecuritySecondlySumOrderByAggregateInput = {
    securityId?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    average?: SortOrder
    volume?: SortOrder
    notional?: SortOrder
    numberOfTrades?: SortOrder
    changeOverTime?: SortOrder
  }

  export type SecuritySplitsCountOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    paymentDate?: SortOrder
    ratio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exercisedDate?: SortOrder
    declaredDate?: SortOrder
    toFactor?: SortOrder
    fromFactor?: SortOrder
    description?: SortOrder
  }

  export type SecuritySplitsAvgOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    ratio?: SortOrder
    toFactor?: SortOrder
    fromFactor?: SortOrder
  }

  export type SecuritySplitsMaxOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    paymentDate?: SortOrder
    ratio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exercisedDate?: SortOrder
    declaredDate?: SortOrder
    toFactor?: SortOrder
    fromFactor?: SortOrder
    description?: SortOrder
  }

  export type SecuritySplitsMinOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    paymentDate?: SortOrder
    ratio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exercisedDate?: SortOrder
    declaredDate?: SortOrder
    toFactor?: SortOrder
    fromFactor?: SortOrder
    description?: SortOrder
  }

  export type SecuritySplitsSumOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    ratio?: SortOrder
    toFactor?: SortOrder
    fromFactor?: SortOrder
  }

  export type SecurityTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SecurityTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SecurityTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SecurityTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SecurityTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StrategyParametersListRelationFilter = {
    every?: StrategyParametersWhereInput
    some?: StrategyParametersWhereInput
    none?: StrategyParametersWhereInput
  }

  export type StrategyParametersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrategiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type StrategiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StrategiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type StrategiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type StrategiesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StrategiesRelationFilter = {
    is?: StrategiesWhereInput
    isNot?: StrategiesWhereInput
  }

  export type StrategyParametersCountOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    dataType?: SortOrder
  }

  export type StrategyParametersAvgOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
  }

  export type StrategyParametersMaxOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    dataType?: SortOrder
  }

  export type StrategyParametersMinOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    dataType?: SortOrder
  }

  export type StrategyParametersSumOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
  }

  export type ExchangesRelationFilter = {
    is?: ExchangesWhereInput
    isNot?: ExchangesWhereInput
  }

  export type ConditionsListRelationFilter = {
    every?: ConditionsWhereInput
    some?: ConditionsWhereInput
    none?: ConditionsWhereInput
  }

  export type ConditionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradesCountOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    exchangeId?: SortOrder
    tradeDate?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type TradesAvgOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    exchangeId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type TradesMaxOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    exchangeId?: SortOrder
    tradeDate?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type TradesMinOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    exchangeId?: SortOrder
    tradeDate?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type TradesSumOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    exchangeId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type QuotesCountOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    bidExchangeId?: SortOrder
    askExchangeId?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    bidSize?: SortOrder
    askSize?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotesAvgOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    bidExchangeId?: SortOrder
    askExchangeId?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    bidSize?: SortOrder
    askSize?: SortOrder
  }

  export type QuotesMaxOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    bidExchangeId?: SortOrder
    askExchangeId?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    bidSize?: SortOrder
    askSize?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotesMinOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    bidExchangeId?: SortOrder
    askExchangeId?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    bidSize?: SortOrder
    askSize?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotesSumOrderByAggregateInput = {
    id?: SortOrder
    securityId?: SortOrder
    bidExchangeId?: SortOrder
    askExchangeId?: SortOrder
    bidPrice?: SortOrder
    askPrice?: SortOrder
    bidSize?: SortOrder
    askSize?: SortOrder
  }

  export type TradesRelationFilter = {
    is?: TradesWhereInput
    isNot?: TradesWhereInput
  }

  export type QuotesRelationFilter = {
    is?: QuotesWhereInput
    isNot?: QuotesWhereInput
  }

  export type ConditionsCountOrderByAggregateInput = {
    id?: SortOrder
    tradeId?: SortOrder
    quoteId?: SortOrder
    condition?: SortOrder
    modifier?: SortOrder
    SIPMapping?: SortOrder
    createdAt?: SortOrder
  }

  export type ConditionsAvgOrderByAggregateInput = {
    id?: SortOrder
    tradeId?: SortOrder
    quoteId?: SortOrder
    modifier?: SortOrder
  }

  export type ConditionsMaxOrderByAggregateInput = {
    id?: SortOrder
    tradeId?: SortOrder
    quoteId?: SortOrder
    condition?: SortOrder
    modifier?: SortOrder
    SIPMapping?: SortOrder
    createdAt?: SortOrder
  }

  export type ConditionsMinOrderByAggregateInput = {
    id?: SortOrder
    tradeId?: SortOrder
    quoteId?: SortOrder
    condition?: SortOrder
    modifier?: SortOrder
    SIPMapping?: SortOrder
    createdAt?: SortOrder
  }

  export type ConditionsSumOrderByAggregateInput = {
    id?: SortOrder
    tradeId?: SortOrder
    quoteId?: SortOrder
    modifier?: SortOrder
  }

  export type OrdersCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutAccountInput>, Enumerable<OrdersUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutAccountInput>
    createMany?: OrdersCreateManyAccountInputEnvelope
    connect?: Enumerable<OrdersWhereUniqueInput>
  }

  export type PositionsCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<PositionsCreateWithoutAccountInput>, Enumerable<PositionsUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<PositionsCreateOrConnectWithoutAccountInput>
    createMany?: PositionsCreateManyAccountInputEnvelope
    connect?: Enumerable<PositionsWhereUniqueInput>
  }

  export type OrdersUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutAccountInput>, Enumerable<OrdersUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutAccountInput>
    createMany?: OrdersCreateManyAccountInputEnvelope
    connect?: Enumerable<OrdersWhereUniqueInput>
  }

  export type PositionsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<Enumerable<PositionsCreateWithoutAccountInput>, Enumerable<PositionsUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<PositionsCreateOrConnectWithoutAccountInput>
    createMany?: PositionsCreateManyAccountInputEnvelope
    connect?: Enumerable<PositionsWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrdersUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutAccountInput>, Enumerable<OrdersUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<OrdersUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: OrdersCreateManyAccountInputEnvelope
    set?: Enumerable<OrdersWhereUniqueInput>
    disconnect?: Enumerable<OrdersWhereUniqueInput>
    delete?: Enumerable<OrdersWhereUniqueInput>
    connect?: Enumerable<OrdersWhereUniqueInput>
    update?: Enumerable<OrdersUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<OrdersUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<OrdersScalarWhereInput>
  }

  export type PositionsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<PositionsCreateWithoutAccountInput>, Enumerable<PositionsUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<PositionsCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<PositionsUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: PositionsCreateManyAccountInputEnvelope
    set?: Enumerable<PositionsWhereUniqueInput>
    disconnect?: Enumerable<PositionsWhereUniqueInput>
    delete?: Enumerable<PositionsWhereUniqueInput>
    connect?: Enumerable<PositionsWhereUniqueInput>
    update?: Enumerable<PositionsUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<PositionsUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<PositionsScalarWhereInput>
  }

  export type OrdersUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<OrdersCreateWithoutAccountInput>, Enumerable<OrdersUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<OrdersCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<OrdersUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: OrdersCreateManyAccountInputEnvelope
    set?: Enumerable<OrdersWhereUniqueInput>
    disconnect?: Enumerable<OrdersWhereUniqueInput>
    delete?: Enumerable<OrdersWhereUniqueInput>
    connect?: Enumerable<OrdersWhereUniqueInput>
    update?: Enumerable<OrdersUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<OrdersUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<OrdersScalarWhereInput>
  }

  export type PositionsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<Enumerable<PositionsCreateWithoutAccountInput>, Enumerable<PositionsUncheckedCreateWithoutAccountInput>>
    connectOrCreate?: Enumerable<PositionsCreateOrConnectWithoutAccountInput>
    upsert?: Enumerable<PositionsUpsertWithWhereUniqueWithoutAccountInput>
    createMany?: PositionsCreateManyAccountInputEnvelope
    set?: Enumerable<PositionsWhereUniqueInput>
    disconnect?: Enumerable<PositionsWhereUniqueInput>
    delete?: Enumerable<PositionsWhereUniqueInput>
    connect?: Enumerable<PositionsWhereUniqueInput>
    update?: Enumerable<PositionsUpdateWithWhereUniqueWithoutAccountInput>
    updateMany?: Enumerable<PositionsUpdateManyWithWhereWithoutAccountInput>
    deleteMany?: Enumerable<PositionsScalarWhereInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TradesCreateNestedManyWithoutExchangeInput = {
    create?: XOR<Enumerable<TradesCreateWithoutExchangeInput>, Enumerable<TradesUncheckedCreateWithoutExchangeInput>>
    connectOrCreate?: Enumerable<TradesCreateOrConnectWithoutExchangeInput>
    createMany?: TradesCreateManyExchangeInputEnvelope
    connect?: Enumerable<TradesWhereUniqueInput>
  }

  export type QuotesCreateNestedManyWithoutAskExchangeInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutAskExchangeInput>, Enumerable<QuotesUncheckedCreateWithoutAskExchangeInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutAskExchangeInput>
    createMany?: QuotesCreateManyAskExchangeInputEnvelope
    connect?: Enumerable<QuotesWhereUniqueInput>
  }

  export type QuotesCreateNestedManyWithoutBidExchangeInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutBidExchangeInput>, Enumerable<QuotesUncheckedCreateWithoutBidExchangeInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutBidExchangeInput>
    createMany?: QuotesCreateManyBidExchangeInputEnvelope
    connect?: Enumerable<QuotesWhereUniqueInput>
  }

  export type TradesUncheckedCreateNestedManyWithoutExchangeInput = {
    create?: XOR<Enumerable<TradesCreateWithoutExchangeInput>, Enumerable<TradesUncheckedCreateWithoutExchangeInput>>
    connectOrCreate?: Enumerable<TradesCreateOrConnectWithoutExchangeInput>
    createMany?: TradesCreateManyExchangeInputEnvelope
    connect?: Enumerable<TradesWhereUniqueInput>
  }

  export type QuotesUncheckedCreateNestedManyWithoutAskExchangeInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutAskExchangeInput>, Enumerable<QuotesUncheckedCreateWithoutAskExchangeInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutAskExchangeInput>
    createMany?: QuotesCreateManyAskExchangeInputEnvelope
    connect?: Enumerable<QuotesWhereUniqueInput>
  }

  export type QuotesUncheckedCreateNestedManyWithoutBidExchangeInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutBidExchangeInput>, Enumerable<QuotesUncheckedCreateWithoutBidExchangeInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutBidExchangeInput>
    createMany?: QuotesCreateManyBidExchangeInputEnvelope
    connect?: Enumerable<QuotesWhereUniqueInput>
  }

  export type TradesUpdateManyWithoutExchangeNestedInput = {
    create?: XOR<Enumerable<TradesCreateWithoutExchangeInput>, Enumerable<TradesUncheckedCreateWithoutExchangeInput>>
    connectOrCreate?: Enumerable<TradesCreateOrConnectWithoutExchangeInput>
    upsert?: Enumerable<TradesUpsertWithWhereUniqueWithoutExchangeInput>
    createMany?: TradesCreateManyExchangeInputEnvelope
    set?: Enumerable<TradesWhereUniqueInput>
    disconnect?: Enumerable<TradesWhereUniqueInput>
    delete?: Enumerable<TradesWhereUniqueInput>
    connect?: Enumerable<TradesWhereUniqueInput>
    update?: Enumerable<TradesUpdateWithWhereUniqueWithoutExchangeInput>
    updateMany?: Enumerable<TradesUpdateManyWithWhereWithoutExchangeInput>
    deleteMany?: Enumerable<TradesScalarWhereInput>
  }

  export type QuotesUpdateManyWithoutAskExchangeNestedInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutAskExchangeInput>, Enumerable<QuotesUncheckedCreateWithoutAskExchangeInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutAskExchangeInput>
    upsert?: Enumerable<QuotesUpsertWithWhereUniqueWithoutAskExchangeInput>
    createMany?: QuotesCreateManyAskExchangeInputEnvelope
    set?: Enumerable<QuotesWhereUniqueInput>
    disconnect?: Enumerable<QuotesWhereUniqueInput>
    delete?: Enumerable<QuotesWhereUniqueInput>
    connect?: Enumerable<QuotesWhereUniqueInput>
    update?: Enumerable<QuotesUpdateWithWhereUniqueWithoutAskExchangeInput>
    updateMany?: Enumerable<QuotesUpdateManyWithWhereWithoutAskExchangeInput>
    deleteMany?: Enumerable<QuotesScalarWhereInput>
  }

  export type QuotesUpdateManyWithoutBidExchangeNestedInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutBidExchangeInput>, Enumerable<QuotesUncheckedCreateWithoutBidExchangeInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutBidExchangeInput>
    upsert?: Enumerable<QuotesUpsertWithWhereUniqueWithoutBidExchangeInput>
    createMany?: QuotesCreateManyBidExchangeInputEnvelope
    set?: Enumerable<QuotesWhereUniqueInput>
    disconnect?: Enumerable<QuotesWhereUniqueInput>
    delete?: Enumerable<QuotesWhereUniqueInput>
    connect?: Enumerable<QuotesWhereUniqueInput>
    update?: Enumerable<QuotesUpdateWithWhereUniqueWithoutBidExchangeInput>
    updateMany?: Enumerable<QuotesUpdateManyWithWhereWithoutBidExchangeInput>
    deleteMany?: Enumerable<QuotesScalarWhereInput>
  }

  export type TradesUncheckedUpdateManyWithoutExchangeNestedInput = {
    create?: XOR<Enumerable<TradesCreateWithoutExchangeInput>, Enumerable<TradesUncheckedCreateWithoutExchangeInput>>
    connectOrCreate?: Enumerable<TradesCreateOrConnectWithoutExchangeInput>
    upsert?: Enumerable<TradesUpsertWithWhereUniqueWithoutExchangeInput>
    createMany?: TradesCreateManyExchangeInputEnvelope
    set?: Enumerable<TradesWhereUniqueInput>
    disconnect?: Enumerable<TradesWhereUniqueInput>
    delete?: Enumerable<TradesWhereUniqueInput>
    connect?: Enumerable<TradesWhereUniqueInput>
    update?: Enumerable<TradesUpdateWithWhereUniqueWithoutExchangeInput>
    updateMany?: Enumerable<TradesUpdateManyWithWhereWithoutExchangeInput>
    deleteMany?: Enumerable<TradesScalarWhereInput>
  }

  export type QuotesUncheckedUpdateManyWithoutAskExchangeNestedInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutAskExchangeInput>, Enumerable<QuotesUncheckedCreateWithoutAskExchangeInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutAskExchangeInput>
    upsert?: Enumerable<QuotesUpsertWithWhereUniqueWithoutAskExchangeInput>
    createMany?: QuotesCreateManyAskExchangeInputEnvelope
    set?: Enumerable<QuotesWhereUniqueInput>
    disconnect?: Enumerable<QuotesWhereUniqueInput>
    delete?: Enumerable<QuotesWhereUniqueInput>
    connect?: Enumerable<QuotesWhereUniqueInput>
    update?: Enumerable<QuotesUpdateWithWhereUniqueWithoutAskExchangeInput>
    updateMany?: Enumerable<QuotesUpdateManyWithWhereWithoutAskExchangeInput>
    deleteMany?: Enumerable<QuotesScalarWhereInput>
  }

  export type QuotesUncheckedUpdateManyWithoutBidExchangeNestedInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutBidExchangeInput>, Enumerable<QuotesUncheckedCreateWithoutBidExchangeInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutBidExchangeInput>
    upsert?: Enumerable<QuotesUpsertWithWhereUniqueWithoutBidExchangeInput>
    createMany?: QuotesCreateManyBidExchangeInputEnvelope
    set?: Enumerable<QuotesWhereUniqueInput>
    disconnect?: Enumerable<QuotesWhereUniqueInput>
    delete?: Enumerable<QuotesWhereUniqueInput>
    connect?: Enumerable<QuotesWhereUniqueInput>
    update?: Enumerable<QuotesUpdateWithWhereUniqueWithoutBidExchangeInput>
    updateMany?: Enumerable<QuotesUpdateManyWithWhereWithoutBidExchangeInput>
    deleteMany?: Enumerable<QuotesScalarWhereInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type AccountsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AccountsCreateWithoutOrdersInput, AccountsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutOrdersInput
    connect?: AccountsWhereUniqueInput
  }

  export type PositionOrdersCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<PositionOrdersCreateWithoutOrderInput>, Enumerable<PositionOrdersUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<PositionOrdersCreateOrConnectWithoutOrderInput>
    createMany?: PositionOrdersCreateManyOrderInputEnvelope
    connect?: Enumerable<PositionOrdersWhereUniqueInput>
  }

  export type PositionOrdersUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<PositionOrdersCreateWithoutOrderInput>, Enumerable<PositionOrdersUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<PositionOrdersCreateOrConnectWithoutOrderInput>
    createMany?: PositionOrdersCreateManyOrderInputEnvelope
    connect?: Enumerable<PositionOrdersWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AccountsUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<AccountsCreateWithoutOrdersInput, AccountsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutOrdersInput
    upsert?: AccountsUpsertWithoutOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutOrdersInput, AccountsUncheckedUpdateWithoutOrdersInput>
  }

  export type PositionOrdersUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<PositionOrdersCreateWithoutOrderInput>, Enumerable<PositionOrdersUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<PositionOrdersCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<PositionOrdersUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: PositionOrdersCreateManyOrderInputEnvelope
    set?: Enumerable<PositionOrdersWhereUniqueInput>
    disconnect?: Enumerable<PositionOrdersWhereUniqueInput>
    delete?: Enumerable<PositionOrdersWhereUniqueInput>
    connect?: Enumerable<PositionOrdersWhereUniqueInput>
    update?: Enumerable<PositionOrdersUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<PositionOrdersUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<PositionOrdersScalarWhereInput>
  }

  export type PositionOrdersUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<Enumerable<PositionOrdersCreateWithoutOrderInput>, Enumerable<PositionOrdersUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<PositionOrdersCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<PositionOrdersUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: PositionOrdersCreateManyOrderInputEnvelope
    set?: Enumerable<PositionOrdersWhereUniqueInput>
    disconnect?: Enumerable<PositionOrdersWhereUniqueInput>
    delete?: Enumerable<PositionOrdersWhereUniqueInput>
    connect?: Enumerable<PositionOrdersWhereUniqueInput>
    update?: Enumerable<PositionOrdersUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<PositionOrdersUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<PositionOrdersScalarWhereInput>
  }

  export type AccountsCreateNestedOneWithoutPositionsInput = {
    create?: XOR<AccountsCreateWithoutPositionsInput, AccountsUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutPositionsInput
    connect?: AccountsWhereUniqueInput
  }

  export type PositionOrdersCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<PositionOrdersCreateWithoutPositionInput>, Enumerable<PositionOrdersUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PositionOrdersCreateOrConnectWithoutPositionInput>
    createMany?: PositionOrdersCreateManyPositionInputEnvelope
    connect?: Enumerable<PositionOrdersWhereUniqueInput>
  }

  export type PositionOrdersUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<PositionOrdersCreateWithoutPositionInput>, Enumerable<PositionOrdersUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PositionOrdersCreateOrConnectWithoutPositionInput>
    createMany?: PositionOrdersCreateManyPositionInputEnvelope
    connect?: Enumerable<PositionOrdersWhereUniqueInput>
  }

  export type AccountsUpdateOneWithoutPositionsNestedInput = {
    create?: XOR<AccountsCreateWithoutPositionsInput, AccountsUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: AccountsCreateOrConnectWithoutPositionsInput
    upsert?: AccountsUpsertWithoutPositionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AccountsWhereUniqueInput
    update?: XOR<AccountsUpdateWithoutPositionsInput, AccountsUncheckedUpdateWithoutPositionsInput>
  }

  export type PositionOrdersUpdateManyWithoutPositionNestedInput = {
    create?: XOR<Enumerable<PositionOrdersCreateWithoutPositionInput>, Enumerable<PositionOrdersUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PositionOrdersCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<PositionOrdersUpsertWithWhereUniqueWithoutPositionInput>
    createMany?: PositionOrdersCreateManyPositionInputEnvelope
    set?: Enumerable<PositionOrdersWhereUniqueInput>
    disconnect?: Enumerable<PositionOrdersWhereUniqueInput>
    delete?: Enumerable<PositionOrdersWhereUniqueInput>
    connect?: Enumerable<PositionOrdersWhereUniqueInput>
    update?: Enumerable<PositionOrdersUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<PositionOrdersUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<PositionOrdersScalarWhereInput>
  }

  export type PositionOrdersUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<Enumerable<PositionOrdersCreateWithoutPositionInput>, Enumerable<PositionOrdersUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PositionOrdersCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<PositionOrdersUpsertWithWhereUniqueWithoutPositionInput>
    createMany?: PositionOrdersCreateManyPositionInputEnvelope
    set?: Enumerable<PositionOrdersWhereUniqueInput>
    disconnect?: Enumerable<PositionOrdersWhereUniqueInput>
    delete?: Enumerable<PositionOrdersWhereUniqueInput>
    connect?: Enumerable<PositionOrdersWhereUniqueInput>
    update?: Enumerable<PositionOrdersUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<PositionOrdersUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<PositionOrdersScalarWhereInput>
  }

  export type PositionsCreateNestedOneWithoutPositionOrdersInput = {
    create?: XOR<PositionsCreateWithoutPositionOrdersInput, PositionsUncheckedCreateWithoutPositionOrdersInput>
    connectOrCreate?: PositionsCreateOrConnectWithoutPositionOrdersInput
    connect?: PositionsWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutPositionOrdersInput = {
    create?: XOR<OrdersCreateWithoutPositionOrdersInput, OrdersUncheckedCreateWithoutPositionOrdersInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutPositionOrdersInput
    connect?: OrdersWhereUniqueInput
  }

  export type PositionsUpdateOneWithoutPositionOrdersNestedInput = {
    create?: XOR<PositionsCreateWithoutPositionOrdersInput, PositionsUncheckedCreateWithoutPositionOrdersInput>
    connectOrCreate?: PositionsCreateOrConnectWithoutPositionOrdersInput
    upsert?: PositionsUpsertWithoutPositionOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: PositionsWhereUniqueInput
    update?: XOR<PositionsUpdateWithoutPositionOrdersInput, PositionsUncheckedUpdateWithoutPositionOrdersInput>
  }

  export type OrdersUpdateOneWithoutPositionOrdersNestedInput = {
    create?: XOR<OrdersCreateWithoutPositionOrdersInput, OrdersUncheckedCreateWithoutPositionOrdersInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutPositionOrdersInput
    upsert?: OrdersUpsertWithoutPositionOrdersInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<OrdersUpdateWithoutPositionOrdersInput, OrdersUncheckedUpdateWithoutPositionOrdersInput>
  }

  export type SectorsCreateNestedOneWithoutSectorDailyInput = {
    create?: XOR<SectorsCreateWithoutSectorDailyInput, SectorsUncheckedCreateWithoutSectorDailyInput>
    connectOrCreate?: SectorsCreateOrConnectWithoutSectorDailyInput
    connect?: SectorsWhereUniqueInput
  }

  export type SectorsUpdateOneRequiredWithoutSectorDailyNestedInput = {
    create?: XOR<SectorsCreateWithoutSectorDailyInput, SectorsUncheckedCreateWithoutSectorDailyInput>
    connectOrCreate?: SectorsCreateOrConnectWithoutSectorDailyInput
    upsert?: SectorsUpsertWithoutSectorDailyInput
    connect?: SectorsWhereUniqueInput
    update?: XOR<SectorsUpdateWithoutSectorDailyInput, SectorsUncheckedUpdateWithoutSectorDailyInput>
  }

  export type SectorDailyCreateNestedManyWithoutSectorInput = {
    create?: XOR<Enumerable<SectorDailyCreateWithoutSectorInput>, Enumerable<SectorDailyUncheckedCreateWithoutSectorInput>>
    connectOrCreate?: Enumerable<SectorDailyCreateOrConnectWithoutSectorInput>
    createMany?: SectorDailyCreateManySectorInputEnvelope
    connect?: Enumerable<SectorDailyWhereUniqueInput>
  }

  export type SectorDailyUncheckedCreateNestedManyWithoutSectorInput = {
    create?: XOR<Enumerable<SectorDailyCreateWithoutSectorInput>, Enumerable<SectorDailyUncheckedCreateWithoutSectorInput>>
    connectOrCreate?: Enumerable<SectorDailyCreateOrConnectWithoutSectorInput>
    createMany?: SectorDailyCreateManySectorInputEnvelope
    connect?: Enumerable<SectorDailyWhereUniqueInput>
  }

  export type SectorDailyUpdateManyWithoutSectorNestedInput = {
    create?: XOR<Enumerable<SectorDailyCreateWithoutSectorInput>, Enumerable<SectorDailyUncheckedCreateWithoutSectorInput>>
    connectOrCreate?: Enumerable<SectorDailyCreateOrConnectWithoutSectorInput>
    upsert?: Enumerable<SectorDailyUpsertWithWhereUniqueWithoutSectorInput>
    createMany?: SectorDailyCreateManySectorInputEnvelope
    set?: Enumerable<SectorDailyWhereUniqueInput>
    disconnect?: Enumerable<SectorDailyWhereUniqueInput>
    delete?: Enumerable<SectorDailyWhereUniqueInput>
    connect?: Enumerable<SectorDailyWhereUniqueInput>
    update?: Enumerable<SectorDailyUpdateWithWhereUniqueWithoutSectorInput>
    updateMany?: Enumerable<SectorDailyUpdateManyWithWhereWithoutSectorInput>
    deleteMany?: Enumerable<SectorDailyScalarWhereInput>
  }

  export type SectorDailyUncheckedUpdateManyWithoutSectorNestedInput = {
    create?: XOR<Enumerable<SectorDailyCreateWithoutSectorInput>, Enumerable<SectorDailyUncheckedCreateWithoutSectorInput>>
    connectOrCreate?: Enumerable<SectorDailyCreateOrConnectWithoutSectorInput>
    upsert?: Enumerable<SectorDailyUpsertWithWhereUniqueWithoutSectorInput>
    createMany?: SectorDailyCreateManySectorInputEnvelope
    set?: Enumerable<SectorDailyWhereUniqueInput>
    disconnect?: Enumerable<SectorDailyWhereUniqueInput>
    delete?: Enumerable<SectorDailyWhereUniqueInput>
    connect?: Enumerable<SectorDailyWhereUniqueInput>
    update?: Enumerable<SectorDailyUpdateWithWhereUniqueWithoutSectorInput>
    updateMany?: Enumerable<SectorDailyUpdateManyWithWhereWithoutSectorInput>
    deleteMany?: Enumerable<SectorDailyScalarWhereInput>
  }

  export type SecurityDailyCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecurityDailyCreateWithoutSecurityInput>, Enumerable<SecurityDailyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityDailyCreateOrConnectWithoutSecurityInput>
    createMany?: SecurityDailyCreateManySecurityInputEnvelope
    connect?: Enumerable<SecurityDailyWhereUniqueInput>
  }

  export type SecurityDividendsCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecurityDividendsCreateWithoutSecurityInput>, Enumerable<SecurityDividendsUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityDividendsCreateOrConnectWithoutSecurityInput>
    createMany?: SecurityDividendsCreateManySecurityInputEnvelope
    connect?: Enumerable<SecurityDividendsWhereUniqueInput>
  }

  export type SecurityMinutelyCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecurityMinutelyCreateWithoutSecurityInput>, Enumerable<SecurityMinutelyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityMinutelyCreateOrConnectWithoutSecurityInput>
    createMany?: SecurityMinutelyCreateManySecurityInputEnvelope
    connect?: Enumerable<SecurityMinutelyWhereUniqueInput>
  }

  export type SecuritySecondlyCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecuritySecondlyCreateWithoutSecurityInput>, Enumerable<SecuritySecondlyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecuritySecondlyCreateOrConnectWithoutSecurityInput>
    createMany?: SecuritySecondlyCreateManySecurityInputEnvelope
    connect?: Enumerable<SecuritySecondlyWhereUniqueInput>
  }

  export type SecuritySplitsCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecuritySplitsCreateWithoutSecurityInput>, Enumerable<SecuritySplitsUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecuritySplitsCreateOrConnectWithoutSecurityInput>
    createMany?: SecuritySplitsCreateManySecurityInputEnvelope
    connect?: Enumerable<SecuritySplitsWhereUniqueInput>
  }

  export type TradesCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<TradesCreateWithoutSecurityInput>, Enumerable<TradesUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<TradesCreateOrConnectWithoutSecurityInput>
    createMany?: TradesCreateManySecurityInputEnvelope
    connect?: Enumerable<TradesWhereUniqueInput>
  }

  export type QuotesCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutSecurityInput>, Enumerable<QuotesUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutSecurityInput>
    createMany?: QuotesCreateManySecurityInputEnvelope
    connect?: Enumerable<QuotesWhereUniqueInput>
  }

  export type SecurityDailyUncheckedCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecurityDailyCreateWithoutSecurityInput>, Enumerable<SecurityDailyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityDailyCreateOrConnectWithoutSecurityInput>
    createMany?: SecurityDailyCreateManySecurityInputEnvelope
    connect?: Enumerable<SecurityDailyWhereUniqueInput>
  }

  export type SecurityDividendsUncheckedCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecurityDividendsCreateWithoutSecurityInput>, Enumerable<SecurityDividendsUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityDividendsCreateOrConnectWithoutSecurityInput>
    createMany?: SecurityDividendsCreateManySecurityInputEnvelope
    connect?: Enumerable<SecurityDividendsWhereUniqueInput>
  }

  export type SecurityMinutelyUncheckedCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecurityMinutelyCreateWithoutSecurityInput>, Enumerable<SecurityMinutelyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityMinutelyCreateOrConnectWithoutSecurityInput>
    createMany?: SecurityMinutelyCreateManySecurityInputEnvelope
    connect?: Enumerable<SecurityMinutelyWhereUniqueInput>
  }

  export type SecuritySecondlyUncheckedCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecuritySecondlyCreateWithoutSecurityInput>, Enumerable<SecuritySecondlyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecuritySecondlyCreateOrConnectWithoutSecurityInput>
    createMany?: SecuritySecondlyCreateManySecurityInputEnvelope
    connect?: Enumerable<SecuritySecondlyWhereUniqueInput>
  }

  export type SecuritySplitsUncheckedCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<SecuritySplitsCreateWithoutSecurityInput>, Enumerable<SecuritySplitsUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecuritySplitsCreateOrConnectWithoutSecurityInput>
    createMany?: SecuritySplitsCreateManySecurityInputEnvelope
    connect?: Enumerable<SecuritySplitsWhereUniqueInput>
  }

  export type TradesUncheckedCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<TradesCreateWithoutSecurityInput>, Enumerable<TradesUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<TradesCreateOrConnectWithoutSecurityInput>
    createMany?: TradesCreateManySecurityInputEnvelope
    connect?: Enumerable<TradesWhereUniqueInput>
  }

  export type QuotesUncheckedCreateNestedManyWithoutSecurityInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutSecurityInput>, Enumerable<QuotesUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutSecurityInput>
    createMany?: QuotesCreateManySecurityInputEnvelope
    connect?: Enumerable<QuotesWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SecurityDailyUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecurityDailyCreateWithoutSecurityInput>, Enumerable<SecurityDailyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityDailyCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecurityDailyUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecurityDailyCreateManySecurityInputEnvelope
    set?: Enumerable<SecurityDailyWhereUniqueInput>
    disconnect?: Enumerable<SecurityDailyWhereUniqueInput>
    delete?: Enumerable<SecurityDailyWhereUniqueInput>
    connect?: Enumerable<SecurityDailyWhereUniqueInput>
    update?: Enumerable<SecurityDailyUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecurityDailyUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecurityDailyScalarWhereInput>
  }

  export type SecurityDividendsUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecurityDividendsCreateWithoutSecurityInput>, Enumerable<SecurityDividendsUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityDividendsCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecurityDividendsUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecurityDividendsCreateManySecurityInputEnvelope
    set?: Enumerable<SecurityDividendsWhereUniqueInput>
    disconnect?: Enumerable<SecurityDividendsWhereUniqueInput>
    delete?: Enumerable<SecurityDividendsWhereUniqueInput>
    connect?: Enumerable<SecurityDividendsWhereUniqueInput>
    update?: Enumerable<SecurityDividendsUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecurityDividendsUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecurityDividendsScalarWhereInput>
  }

  export type SecurityMinutelyUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecurityMinutelyCreateWithoutSecurityInput>, Enumerable<SecurityMinutelyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityMinutelyCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecurityMinutelyUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecurityMinutelyCreateManySecurityInputEnvelope
    set?: Enumerable<SecurityMinutelyWhereUniqueInput>
    disconnect?: Enumerable<SecurityMinutelyWhereUniqueInput>
    delete?: Enumerable<SecurityMinutelyWhereUniqueInput>
    connect?: Enumerable<SecurityMinutelyWhereUniqueInput>
    update?: Enumerable<SecurityMinutelyUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecurityMinutelyUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecurityMinutelyScalarWhereInput>
  }

  export type SecuritySecondlyUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecuritySecondlyCreateWithoutSecurityInput>, Enumerable<SecuritySecondlyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecuritySecondlyCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecuritySecondlyUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecuritySecondlyCreateManySecurityInputEnvelope
    set?: Enumerable<SecuritySecondlyWhereUniqueInput>
    disconnect?: Enumerable<SecuritySecondlyWhereUniqueInput>
    delete?: Enumerable<SecuritySecondlyWhereUniqueInput>
    connect?: Enumerable<SecuritySecondlyWhereUniqueInput>
    update?: Enumerable<SecuritySecondlyUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecuritySecondlyUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecuritySecondlyScalarWhereInput>
  }

  export type SecuritySplitsUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecuritySplitsCreateWithoutSecurityInput>, Enumerable<SecuritySplitsUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecuritySplitsCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecuritySplitsUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecuritySplitsCreateManySecurityInputEnvelope
    set?: Enumerable<SecuritySplitsWhereUniqueInput>
    disconnect?: Enumerable<SecuritySplitsWhereUniqueInput>
    delete?: Enumerable<SecuritySplitsWhereUniqueInput>
    connect?: Enumerable<SecuritySplitsWhereUniqueInput>
    update?: Enumerable<SecuritySplitsUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecuritySplitsUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecuritySplitsScalarWhereInput>
  }

  export type TradesUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<TradesCreateWithoutSecurityInput>, Enumerable<TradesUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<TradesCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<TradesUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: TradesCreateManySecurityInputEnvelope
    set?: Enumerable<TradesWhereUniqueInput>
    disconnect?: Enumerable<TradesWhereUniqueInput>
    delete?: Enumerable<TradesWhereUniqueInput>
    connect?: Enumerable<TradesWhereUniqueInput>
    update?: Enumerable<TradesUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<TradesUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<TradesScalarWhereInput>
  }

  export type QuotesUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutSecurityInput>, Enumerable<QuotesUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<QuotesUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: QuotesCreateManySecurityInputEnvelope
    set?: Enumerable<QuotesWhereUniqueInput>
    disconnect?: Enumerable<QuotesWhereUniqueInput>
    delete?: Enumerable<QuotesWhereUniqueInput>
    connect?: Enumerable<QuotesWhereUniqueInput>
    update?: Enumerable<QuotesUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<QuotesUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<QuotesScalarWhereInput>
  }

  export type SecurityDailyUncheckedUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecurityDailyCreateWithoutSecurityInput>, Enumerable<SecurityDailyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityDailyCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecurityDailyUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecurityDailyCreateManySecurityInputEnvelope
    set?: Enumerable<SecurityDailyWhereUniqueInput>
    disconnect?: Enumerable<SecurityDailyWhereUniqueInput>
    delete?: Enumerable<SecurityDailyWhereUniqueInput>
    connect?: Enumerable<SecurityDailyWhereUniqueInput>
    update?: Enumerable<SecurityDailyUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecurityDailyUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecurityDailyScalarWhereInput>
  }

  export type SecurityDividendsUncheckedUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecurityDividendsCreateWithoutSecurityInput>, Enumerable<SecurityDividendsUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityDividendsCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecurityDividendsUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecurityDividendsCreateManySecurityInputEnvelope
    set?: Enumerable<SecurityDividendsWhereUniqueInput>
    disconnect?: Enumerable<SecurityDividendsWhereUniqueInput>
    delete?: Enumerable<SecurityDividendsWhereUniqueInput>
    connect?: Enumerable<SecurityDividendsWhereUniqueInput>
    update?: Enumerable<SecurityDividendsUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecurityDividendsUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecurityDividendsScalarWhereInput>
  }

  export type SecurityMinutelyUncheckedUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecurityMinutelyCreateWithoutSecurityInput>, Enumerable<SecurityMinutelyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecurityMinutelyCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecurityMinutelyUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecurityMinutelyCreateManySecurityInputEnvelope
    set?: Enumerable<SecurityMinutelyWhereUniqueInput>
    disconnect?: Enumerable<SecurityMinutelyWhereUniqueInput>
    delete?: Enumerable<SecurityMinutelyWhereUniqueInput>
    connect?: Enumerable<SecurityMinutelyWhereUniqueInput>
    update?: Enumerable<SecurityMinutelyUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecurityMinutelyUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecurityMinutelyScalarWhereInput>
  }

  export type SecuritySecondlyUncheckedUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecuritySecondlyCreateWithoutSecurityInput>, Enumerable<SecuritySecondlyUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecuritySecondlyCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecuritySecondlyUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecuritySecondlyCreateManySecurityInputEnvelope
    set?: Enumerable<SecuritySecondlyWhereUniqueInput>
    disconnect?: Enumerable<SecuritySecondlyWhereUniqueInput>
    delete?: Enumerable<SecuritySecondlyWhereUniqueInput>
    connect?: Enumerable<SecuritySecondlyWhereUniqueInput>
    update?: Enumerable<SecuritySecondlyUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecuritySecondlyUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecuritySecondlyScalarWhereInput>
  }

  export type SecuritySplitsUncheckedUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<SecuritySplitsCreateWithoutSecurityInput>, Enumerable<SecuritySplitsUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<SecuritySplitsCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<SecuritySplitsUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: SecuritySplitsCreateManySecurityInputEnvelope
    set?: Enumerable<SecuritySplitsWhereUniqueInput>
    disconnect?: Enumerable<SecuritySplitsWhereUniqueInput>
    delete?: Enumerable<SecuritySplitsWhereUniqueInput>
    connect?: Enumerable<SecuritySplitsWhereUniqueInput>
    update?: Enumerable<SecuritySplitsUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<SecuritySplitsUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<SecuritySplitsScalarWhereInput>
  }

  export type TradesUncheckedUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<TradesCreateWithoutSecurityInput>, Enumerable<TradesUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<TradesCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<TradesUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: TradesCreateManySecurityInputEnvelope
    set?: Enumerable<TradesWhereUniqueInput>
    disconnect?: Enumerable<TradesWhereUniqueInput>
    delete?: Enumerable<TradesWhereUniqueInput>
    connect?: Enumerable<TradesWhereUniqueInput>
    update?: Enumerable<TradesUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<TradesUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<TradesScalarWhereInput>
  }

  export type QuotesUncheckedUpdateManyWithoutSecurityNestedInput = {
    create?: XOR<Enumerable<QuotesCreateWithoutSecurityInput>, Enumerable<QuotesUncheckedCreateWithoutSecurityInput>>
    connectOrCreate?: Enumerable<QuotesCreateOrConnectWithoutSecurityInput>
    upsert?: Enumerable<QuotesUpsertWithWhereUniqueWithoutSecurityInput>
    createMany?: QuotesCreateManySecurityInputEnvelope
    set?: Enumerable<QuotesWhereUniqueInput>
    disconnect?: Enumerable<QuotesWhereUniqueInput>
    delete?: Enumerable<QuotesWhereUniqueInput>
    connect?: Enumerable<QuotesWhereUniqueInput>
    update?: Enumerable<QuotesUpdateWithWhereUniqueWithoutSecurityInput>
    updateMany?: Enumerable<QuotesUpdateManyWithWhereWithoutSecurityInput>
    deleteMany?: Enumerable<QuotesScalarWhereInput>
  }

  export type SecuritiesCreateNestedOneWithoutSecurityDailyInput = {
    create?: XOR<SecuritiesCreateWithoutSecurityDailyInput, SecuritiesUncheckedCreateWithoutSecurityDailyInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecurityDailyInput
    connect?: SecuritiesWhereUniqueInput
  }

  export type SecuritiesUpdateOneRequiredWithoutSecurityDailyNestedInput = {
    create?: XOR<SecuritiesCreateWithoutSecurityDailyInput, SecuritiesUncheckedCreateWithoutSecurityDailyInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecurityDailyInput
    upsert?: SecuritiesUpsertWithoutSecurityDailyInput
    connect?: SecuritiesWhereUniqueInput
    update?: XOR<SecuritiesUpdateWithoutSecurityDailyInput, SecuritiesUncheckedUpdateWithoutSecurityDailyInput>
  }

  export type SecuritiesCreateNestedOneWithoutSecurityDividendsInput = {
    create?: XOR<SecuritiesCreateWithoutSecurityDividendsInput, SecuritiesUncheckedCreateWithoutSecurityDividendsInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecurityDividendsInput
    connect?: SecuritiesWhereUniqueInput
  }

  export type SecuritiesUpdateOneRequiredWithoutSecurityDividendsNestedInput = {
    create?: XOR<SecuritiesCreateWithoutSecurityDividendsInput, SecuritiesUncheckedCreateWithoutSecurityDividendsInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecurityDividendsInput
    upsert?: SecuritiesUpsertWithoutSecurityDividendsInput
    connect?: SecuritiesWhereUniqueInput
    update?: XOR<SecuritiesUpdateWithoutSecurityDividendsInput, SecuritiesUncheckedUpdateWithoutSecurityDividendsInput>
  }

  export type SecuritiesCreateNestedOneWithoutSecurityMinutelyInput = {
    create?: XOR<SecuritiesCreateWithoutSecurityMinutelyInput, SecuritiesUncheckedCreateWithoutSecurityMinutelyInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecurityMinutelyInput
    connect?: SecuritiesWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type SecuritiesUpdateOneRequiredWithoutSecurityMinutelyNestedInput = {
    create?: XOR<SecuritiesCreateWithoutSecurityMinutelyInput, SecuritiesUncheckedCreateWithoutSecurityMinutelyInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecurityMinutelyInput
    upsert?: SecuritiesUpsertWithoutSecurityMinutelyInput
    connect?: SecuritiesWhereUniqueInput
    update?: XOR<SecuritiesUpdateWithoutSecurityMinutelyInput, SecuritiesUncheckedUpdateWithoutSecurityMinutelyInput>
  }

  export type SecuritiesCreateNestedOneWithoutSecuritySecondlyInput = {
    create?: XOR<SecuritiesCreateWithoutSecuritySecondlyInput, SecuritiesUncheckedCreateWithoutSecuritySecondlyInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecuritySecondlyInput
    connect?: SecuritiesWhereUniqueInput
  }

  export type SecuritiesUpdateOneRequiredWithoutSecuritySecondlyNestedInput = {
    create?: XOR<SecuritiesCreateWithoutSecuritySecondlyInput, SecuritiesUncheckedCreateWithoutSecuritySecondlyInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecuritySecondlyInput
    upsert?: SecuritiesUpsertWithoutSecuritySecondlyInput
    connect?: SecuritiesWhereUniqueInput
    update?: XOR<SecuritiesUpdateWithoutSecuritySecondlyInput, SecuritiesUncheckedUpdateWithoutSecuritySecondlyInput>
  }

  export type SecuritiesCreateNestedOneWithoutSecuritySplitsInput = {
    create?: XOR<SecuritiesCreateWithoutSecuritySplitsInput, SecuritiesUncheckedCreateWithoutSecuritySplitsInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecuritySplitsInput
    connect?: SecuritiesWhereUniqueInput
  }

  export type SecuritiesUpdateOneRequiredWithoutSecuritySplitsNestedInput = {
    create?: XOR<SecuritiesCreateWithoutSecuritySplitsInput, SecuritiesUncheckedCreateWithoutSecuritySplitsInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutSecuritySplitsInput
    upsert?: SecuritiesUpsertWithoutSecuritySplitsInput
    connect?: SecuritiesWhereUniqueInput
    update?: XOR<SecuritiesUpdateWithoutSecuritySplitsInput, SecuritiesUncheckedUpdateWithoutSecuritySplitsInput>
  }

  export type StrategyParametersCreateNestedManyWithoutStrategyInput = {
    create?: XOR<Enumerable<StrategyParametersCreateWithoutStrategyInput>, Enumerable<StrategyParametersUncheckedCreateWithoutStrategyInput>>
    connectOrCreate?: Enumerable<StrategyParametersCreateOrConnectWithoutStrategyInput>
    createMany?: StrategyParametersCreateManyStrategyInputEnvelope
    connect?: Enumerable<StrategyParametersWhereUniqueInput>
  }

  export type StrategyParametersUncheckedCreateNestedManyWithoutStrategyInput = {
    create?: XOR<Enumerable<StrategyParametersCreateWithoutStrategyInput>, Enumerable<StrategyParametersUncheckedCreateWithoutStrategyInput>>
    connectOrCreate?: Enumerable<StrategyParametersCreateOrConnectWithoutStrategyInput>
    createMany?: StrategyParametersCreateManyStrategyInputEnvelope
    connect?: Enumerable<StrategyParametersWhereUniqueInput>
  }

  export type StrategyParametersUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<Enumerable<StrategyParametersCreateWithoutStrategyInput>, Enumerable<StrategyParametersUncheckedCreateWithoutStrategyInput>>
    connectOrCreate?: Enumerable<StrategyParametersCreateOrConnectWithoutStrategyInput>
    upsert?: Enumerable<StrategyParametersUpsertWithWhereUniqueWithoutStrategyInput>
    createMany?: StrategyParametersCreateManyStrategyInputEnvelope
    set?: Enumerable<StrategyParametersWhereUniqueInput>
    disconnect?: Enumerable<StrategyParametersWhereUniqueInput>
    delete?: Enumerable<StrategyParametersWhereUniqueInput>
    connect?: Enumerable<StrategyParametersWhereUniqueInput>
    update?: Enumerable<StrategyParametersUpdateWithWhereUniqueWithoutStrategyInput>
    updateMany?: Enumerable<StrategyParametersUpdateManyWithWhereWithoutStrategyInput>
    deleteMany?: Enumerable<StrategyParametersScalarWhereInput>
  }

  export type StrategyParametersUncheckedUpdateManyWithoutStrategyNestedInput = {
    create?: XOR<Enumerable<StrategyParametersCreateWithoutStrategyInput>, Enumerable<StrategyParametersUncheckedCreateWithoutStrategyInput>>
    connectOrCreate?: Enumerable<StrategyParametersCreateOrConnectWithoutStrategyInput>
    upsert?: Enumerable<StrategyParametersUpsertWithWhereUniqueWithoutStrategyInput>
    createMany?: StrategyParametersCreateManyStrategyInputEnvelope
    set?: Enumerable<StrategyParametersWhereUniqueInput>
    disconnect?: Enumerable<StrategyParametersWhereUniqueInput>
    delete?: Enumerable<StrategyParametersWhereUniqueInput>
    connect?: Enumerable<StrategyParametersWhereUniqueInput>
    update?: Enumerable<StrategyParametersUpdateWithWhereUniqueWithoutStrategyInput>
    updateMany?: Enumerable<StrategyParametersUpdateManyWithWhereWithoutStrategyInput>
    deleteMany?: Enumerable<StrategyParametersScalarWhereInput>
  }

  export type StrategiesCreateNestedOneWithoutStrategyParametersInput = {
    create?: XOR<StrategiesCreateWithoutStrategyParametersInput, StrategiesUncheckedCreateWithoutStrategyParametersInput>
    connectOrCreate?: StrategiesCreateOrConnectWithoutStrategyParametersInput
    connect?: StrategiesWhereUniqueInput
  }

  export type StrategiesUpdateOneRequiredWithoutStrategyParametersNestedInput = {
    create?: XOR<StrategiesCreateWithoutStrategyParametersInput, StrategiesUncheckedCreateWithoutStrategyParametersInput>
    connectOrCreate?: StrategiesCreateOrConnectWithoutStrategyParametersInput
    upsert?: StrategiesUpsertWithoutStrategyParametersInput
    connect?: StrategiesWhereUniqueInput
    update?: XOR<StrategiesUpdateWithoutStrategyParametersInput, StrategiesUncheckedUpdateWithoutStrategyParametersInput>
  }

  export type ExchangesCreateNestedOneWithoutTradesInput = {
    create?: XOR<ExchangesCreateWithoutTradesInput, ExchangesUncheckedCreateWithoutTradesInput>
    connectOrCreate?: ExchangesCreateOrConnectWithoutTradesInput
    connect?: ExchangesWhereUniqueInput
  }

  export type SecuritiesCreateNestedOneWithoutTradesInput = {
    create?: XOR<SecuritiesCreateWithoutTradesInput, SecuritiesUncheckedCreateWithoutTradesInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutTradesInput
    connect?: SecuritiesWhereUniqueInput
  }

  export type ConditionsCreateNestedManyWithoutTradeInput = {
    create?: XOR<Enumerable<ConditionsCreateWithoutTradeInput>, Enumerable<ConditionsUncheckedCreateWithoutTradeInput>>
    connectOrCreate?: Enumerable<ConditionsCreateOrConnectWithoutTradeInput>
    createMany?: ConditionsCreateManyTradeInputEnvelope
    connect?: Enumerable<ConditionsWhereUniqueInput>
  }

  export type ConditionsUncheckedCreateNestedManyWithoutTradeInput = {
    create?: XOR<Enumerable<ConditionsCreateWithoutTradeInput>, Enumerable<ConditionsUncheckedCreateWithoutTradeInput>>
    connectOrCreate?: Enumerable<ConditionsCreateOrConnectWithoutTradeInput>
    createMany?: ConditionsCreateManyTradeInputEnvelope
    connect?: Enumerable<ConditionsWhereUniqueInput>
  }

  export type ExchangesUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<ExchangesCreateWithoutTradesInput, ExchangesUncheckedCreateWithoutTradesInput>
    connectOrCreate?: ExchangesCreateOrConnectWithoutTradesInput
    upsert?: ExchangesUpsertWithoutTradesInput
    connect?: ExchangesWhereUniqueInput
    update?: XOR<ExchangesUpdateWithoutTradesInput, ExchangesUncheckedUpdateWithoutTradesInput>
  }

  export type SecuritiesUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<SecuritiesCreateWithoutTradesInput, SecuritiesUncheckedCreateWithoutTradesInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutTradesInput
    upsert?: SecuritiesUpsertWithoutTradesInput
    connect?: SecuritiesWhereUniqueInput
    update?: XOR<SecuritiesUpdateWithoutTradesInput, SecuritiesUncheckedUpdateWithoutTradesInput>
  }

  export type ConditionsUpdateManyWithoutTradeNestedInput = {
    create?: XOR<Enumerable<ConditionsCreateWithoutTradeInput>, Enumerable<ConditionsUncheckedCreateWithoutTradeInput>>
    connectOrCreate?: Enumerable<ConditionsCreateOrConnectWithoutTradeInput>
    upsert?: Enumerable<ConditionsUpsertWithWhereUniqueWithoutTradeInput>
    createMany?: ConditionsCreateManyTradeInputEnvelope
    set?: Enumerable<ConditionsWhereUniqueInput>
    disconnect?: Enumerable<ConditionsWhereUniqueInput>
    delete?: Enumerable<ConditionsWhereUniqueInput>
    connect?: Enumerable<ConditionsWhereUniqueInput>
    update?: Enumerable<ConditionsUpdateWithWhereUniqueWithoutTradeInput>
    updateMany?: Enumerable<ConditionsUpdateManyWithWhereWithoutTradeInput>
    deleteMany?: Enumerable<ConditionsScalarWhereInput>
  }

  export type ConditionsUncheckedUpdateManyWithoutTradeNestedInput = {
    create?: XOR<Enumerable<ConditionsCreateWithoutTradeInput>, Enumerable<ConditionsUncheckedCreateWithoutTradeInput>>
    connectOrCreate?: Enumerable<ConditionsCreateOrConnectWithoutTradeInput>
    upsert?: Enumerable<ConditionsUpsertWithWhereUniqueWithoutTradeInput>
    createMany?: ConditionsCreateManyTradeInputEnvelope
    set?: Enumerable<ConditionsWhereUniqueInput>
    disconnect?: Enumerable<ConditionsWhereUniqueInput>
    delete?: Enumerable<ConditionsWhereUniqueInput>
    connect?: Enumerable<ConditionsWhereUniqueInput>
    update?: Enumerable<ConditionsUpdateWithWhereUniqueWithoutTradeInput>
    updateMany?: Enumerable<ConditionsUpdateManyWithWhereWithoutTradeInput>
    deleteMany?: Enumerable<ConditionsScalarWhereInput>
  }

  export type ExchangesCreateNestedOneWithoutAskQuotesInput = {
    create?: XOR<ExchangesCreateWithoutAskQuotesInput, ExchangesUncheckedCreateWithoutAskQuotesInput>
    connectOrCreate?: ExchangesCreateOrConnectWithoutAskQuotesInput
    connect?: ExchangesWhereUniqueInput
  }

  export type ExchangesCreateNestedOneWithoutBidQuotesInput = {
    create?: XOR<ExchangesCreateWithoutBidQuotesInput, ExchangesUncheckedCreateWithoutBidQuotesInput>
    connectOrCreate?: ExchangesCreateOrConnectWithoutBidQuotesInput
    connect?: ExchangesWhereUniqueInput
  }

  export type SecuritiesCreateNestedOneWithoutQuotesInput = {
    create?: XOR<SecuritiesCreateWithoutQuotesInput, SecuritiesUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutQuotesInput
    connect?: SecuritiesWhereUniqueInput
  }

  export type ConditionsCreateNestedManyWithoutQuoteInput = {
    create?: XOR<Enumerable<ConditionsCreateWithoutQuoteInput>, Enumerable<ConditionsUncheckedCreateWithoutQuoteInput>>
    connectOrCreate?: Enumerable<ConditionsCreateOrConnectWithoutQuoteInput>
    createMany?: ConditionsCreateManyQuoteInputEnvelope
    connect?: Enumerable<ConditionsWhereUniqueInput>
  }

  export type ConditionsUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<Enumerable<ConditionsCreateWithoutQuoteInput>, Enumerable<ConditionsUncheckedCreateWithoutQuoteInput>>
    connectOrCreate?: Enumerable<ConditionsCreateOrConnectWithoutQuoteInput>
    createMany?: ConditionsCreateManyQuoteInputEnvelope
    connect?: Enumerable<ConditionsWhereUniqueInput>
  }

  export type ExchangesUpdateOneRequiredWithoutAskQuotesNestedInput = {
    create?: XOR<ExchangesCreateWithoutAskQuotesInput, ExchangesUncheckedCreateWithoutAskQuotesInput>
    connectOrCreate?: ExchangesCreateOrConnectWithoutAskQuotesInput
    upsert?: ExchangesUpsertWithoutAskQuotesInput
    connect?: ExchangesWhereUniqueInput
    update?: XOR<ExchangesUpdateWithoutAskQuotesInput, ExchangesUncheckedUpdateWithoutAskQuotesInput>
  }

  export type ExchangesUpdateOneRequiredWithoutBidQuotesNestedInput = {
    create?: XOR<ExchangesCreateWithoutBidQuotesInput, ExchangesUncheckedCreateWithoutBidQuotesInput>
    connectOrCreate?: ExchangesCreateOrConnectWithoutBidQuotesInput
    upsert?: ExchangesUpsertWithoutBidQuotesInput
    connect?: ExchangesWhereUniqueInput
    update?: XOR<ExchangesUpdateWithoutBidQuotesInput, ExchangesUncheckedUpdateWithoutBidQuotesInput>
  }

  export type SecuritiesUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<SecuritiesCreateWithoutQuotesInput, SecuritiesUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: SecuritiesCreateOrConnectWithoutQuotesInput
    upsert?: SecuritiesUpsertWithoutQuotesInput
    connect?: SecuritiesWhereUniqueInput
    update?: XOR<SecuritiesUpdateWithoutQuotesInput, SecuritiesUncheckedUpdateWithoutQuotesInput>
  }

  export type ConditionsUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<Enumerable<ConditionsCreateWithoutQuoteInput>, Enumerable<ConditionsUncheckedCreateWithoutQuoteInput>>
    connectOrCreate?: Enumerable<ConditionsCreateOrConnectWithoutQuoteInput>
    upsert?: Enumerable<ConditionsUpsertWithWhereUniqueWithoutQuoteInput>
    createMany?: ConditionsCreateManyQuoteInputEnvelope
    set?: Enumerable<ConditionsWhereUniqueInput>
    disconnect?: Enumerable<ConditionsWhereUniqueInput>
    delete?: Enumerable<ConditionsWhereUniqueInput>
    connect?: Enumerable<ConditionsWhereUniqueInput>
    update?: Enumerable<ConditionsUpdateWithWhereUniqueWithoutQuoteInput>
    updateMany?: Enumerable<ConditionsUpdateManyWithWhereWithoutQuoteInput>
    deleteMany?: Enumerable<ConditionsScalarWhereInput>
  }

  export type ConditionsUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<Enumerable<ConditionsCreateWithoutQuoteInput>, Enumerable<ConditionsUncheckedCreateWithoutQuoteInput>>
    connectOrCreate?: Enumerable<ConditionsCreateOrConnectWithoutQuoteInput>
    upsert?: Enumerable<ConditionsUpsertWithWhereUniqueWithoutQuoteInput>
    createMany?: ConditionsCreateManyQuoteInputEnvelope
    set?: Enumerable<ConditionsWhereUniqueInput>
    disconnect?: Enumerable<ConditionsWhereUniqueInput>
    delete?: Enumerable<ConditionsWhereUniqueInput>
    connect?: Enumerable<ConditionsWhereUniqueInput>
    update?: Enumerable<ConditionsUpdateWithWhereUniqueWithoutQuoteInput>
    updateMany?: Enumerable<ConditionsUpdateManyWithWhereWithoutQuoteInput>
    deleteMany?: Enumerable<ConditionsScalarWhereInput>
  }

  export type TradesCreateNestedOneWithoutConditionsInput = {
    create?: XOR<TradesCreateWithoutConditionsInput, TradesUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: TradesCreateOrConnectWithoutConditionsInput
    connect?: TradesWhereUniqueInput
  }

  export type QuotesCreateNestedOneWithoutConditionsInput = {
    create?: XOR<QuotesCreateWithoutConditionsInput, QuotesUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: QuotesCreateOrConnectWithoutConditionsInput
    connect?: QuotesWhereUniqueInput
  }

  export type TradesUpdateOneRequiredWithoutConditionsNestedInput = {
    create?: XOR<TradesCreateWithoutConditionsInput, TradesUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: TradesCreateOrConnectWithoutConditionsInput
    upsert?: TradesUpsertWithoutConditionsInput
    connect?: TradesWhereUniqueInput
    update?: XOR<TradesUpdateWithoutConditionsInput, TradesUncheckedUpdateWithoutConditionsInput>
  }

  export type QuotesUpdateOneRequiredWithoutConditionsNestedInput = {
    create?: XOR<QuotesCreateWithoutConditionsInput, QuotesUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: QuotesCreateOrConnectWithoutConditionsInput
    upsert?: QuotesUpsertWithoutConditionsInput
    connect?: QuotesWhereUniqueInput
    update?: XOR<QuotesUpdateWithoutConditionsInput, QuotesUncheckedUpdateWithoutConditionsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type OrdersCreateWithoutAccountInput = {
    id: string
    securityId: number
    strategyName?: string | null
    symbol: string
    name?: string | null
    type: string
    timeInForce: string
    quantity: Decimal | DecimalJsLike | number | string
    filledQuantity: Decimal | DecimalJsLike | number | string
    filledTime?: Date | string | null
    stopPrice?: Decimal | DecimalJsLike | number | string | null
    limitPrice?: Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    orderType?: string | null
    trailAmount?: Decimal | DecimalJsLike | number | string | null
    extendedHours?: boolean
    submittedAt?: Date | string | null
    expiredAt?: Date | string | null
    canceledAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    PositionOrders?: PositionOrdersCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutAccountInput = {
    id: string
    securityId: number
    strategyName?: string | null
    symbol: string
    name?: string | null
    type: string
    timeInForce: string
    quantity: Decimal | DecimalJsLike | number | string
    filledQuantity: Decimal | DecimalJsLike | number | string
    filledTime?: Date | string | null
    stopPrice?: Decimal | DecimalJsLike | number | string | null
    limitPrice?: Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    orderType?: string | null
    trailAmount?: Decimal | DecimalJsLike | number | string | null
    extendedHours?: boolean
    submittedAt?: Date | string | null
    expiredAt?: Date | string | null
    canceledAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    PositionOrders?: PositionOrdersUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutAccountInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutAccountInput, OrdersUncheckedCreateWithoutAccountInput>
  }

  export type OrdersCreateManyAccountInputEnvelope = {
    data: Enumerable<OrdersCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type PositionsCreateWithoutAccountInput = {
    id: string
    price: Decimal | DecimalJsLike | number | string
    securityId: number
    strategyName?: string | null
    name?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    marketValue?: Decimal | DecimalJsLike | number | string | null
    symbol: string
    exchange?: string | null
    positionPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string | null
    type: string
    sellLock: boolean
    PositionOrders?: PositionOrdersCreateNestedManyWithoutPositionInput
  }

  export type PositionsUncheckedCreateWithoutAccountInput = {
    id: string
    price: Decimal | DecimalJsLike | number | string
    securityId: number
    strategyName?: string | null
    name?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    marketValue?: Decimal | DecimalJsLike | number | string | null
    symbol: string
    exchange?: string | null
    positionPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string | null
    type: string
    sellLock: boolean
    PositionOrders?: PositionOrdersUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionsCreateOrConnectWithoutAccountInput = {
    where: PositionsWhereUniqueInput
    create: XOR<PositionsCreateWithoutAccountInput, PositionsUncheckedCreateWithoutAccountInput>
  }

  export type PositionsCreateManyAccountInputEnvelope = {
    data: Enumerable<PositionsCreateManyAccountInput>
    skipDuplicates?: boolean
  }

  export type OrdersUpsertWithWhereUniqueWithoutAccountInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutAccountInput, OrdersUncheckedUpdateWithoutAccountInput>
    create: XOR<OrdersCreateWithoutAccountInput, OrdersUncheckedCreateWithoutAccountInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutAccountInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutAccountInput, OrdersUncheckedUpdateWithoutAccountInput>
  }

  export type OrdersUpdateManyWithWhereWithoutAccountInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrdersScalarWhereInput = {
    AND?: Enumerable<OrdersScalarWhereInput>
    OR?: Enumerable<OrdersScalarWhereInput>
    NOT?: Enumerable<OrdersScalarWhereInput>
    id?: StringFilter | string
    securityId?: IntFilter | number
    strategyName?: StringNullableFilter | string | null
    accountId?: StringNullableFilter | string | null
    symbol?: StringFilter | string
    name?: StringNullableFilter | string | null
    type?: StringFilter | string
    timeInForce?: StringFilter | string
    quantity?: DecimalFilter | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFilter | Decimal | DecimalJsLike | number | string
    filledTime?: DateTimeNullableFilter | Date | string | null
    stopPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    limitPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter | string | null
    orderType?: StringNullableFilter | string | null
    trailAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFilter | boolean
    submittedAt?: DateTimeNullableFilter | Date | string | null
    expiredAt?: DateTimeNullableFilter | Date | string | null
    canceledAt?: DateTimeNullableFilter | Date | string | null
    failedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PositionsUpsertWithWhereUniqueWithoutAccountInput = {
    where: PositionsWhereUniqueInput
    update: XOR<PositionsUpdateWithoutAccountInput, PositionsUncheckedUpdateWithoutAccountInput>
    create: XOR<PositionsCreateWithoutAccountInput, PositionsUncheckedCreateWithoutAccountInput>
  }

  export type PositionsUpdateWithWhereUniqueWithoutAccountInput = {
    where: PositionsWhereUniqueInput
    data: XOR<PositionsUpdateWithoutAccountInput, PositionsUncheckedUpdateWithoutAccountInput>
  }

  export type PositionsUpdateManyWithWhereWithoutAccountInput = {
    where: PositionsScalarWhereInput
    data: XOR<PositionsUpdateManyMutationInput, PositionsUncheckedUpdateManyWithoutPositionsInput>
  }

  export type PositionsScalarWhereInput = {
    AND?: Enumerable<PositionsScalarWhereInput>
    OR?: Enumerable<PositionsScalarWhereInput>
    NOT?: Enumerable<PositionsScalarWhereInput>
    id?: StringFilter | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    securityId?: IntFilter | number
    strategyName?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    accountId?: StringNullableFilter | string | null
    quantity?: DecimalFilter | Decimal | DecimalJsLike | number | string
    marketValue?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFilter | string
    exchange?: StringNullableFilter | string | null
    positionPercent?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    status?: StringNullableFilter | string | null
    type?: StringFilter | string
    sellLock?: BoolFilter | boolean
  }

  export type TradesCreateWithoutExchangeInput = {
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Security: SecuritiesCreateNestedOneWithoutTradesInput
    Conditions?: ConditionsCreateNestedManyWithoutTradeInput
  }

  export type TradesUncheckedCreateWithoutExchangeInput = {
    id?: number
    securityId: number
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Conditions?: ConditionsUncheckedCreateNestedManyWithoutTradeInput
  }

  export type TradesCreateOrConnectWithoutExchangeInput = {
    where: TradesWhereUniqueInput
    create: XOR<TradesCreateWithoutExchangeInput, TradesUncheckedCreateWithoutExchangeInput>
  }

  export type TradesCreateManyExchangeInputEnvelope = {
    data: Enumerable<TradesCreateManyExchangeInput>
    skipDuplicates?: boolean
  }

  export type QuotesCreateWithoutAskExchangeInput = {
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    BidExchange: ExchangesCreateNestedOneWithoutBidQuotesInput
    Security: SecuritiesCreateNestedOneWithoutQuotesInput
    Conditions?: ConditionsCreateNestedManyWithoutQuoteInput
  }

  export type QuotesUncheckedCreateWithoutAskExchangeInput = {
    id?: number
    securityId: number
    bidExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    Conditions?: ConditionsUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuotesCreateOrConnectWithoutAskExchangeInput = {
    where: QuotesWhereUniqueInput
    create: XOR<QuotesCreateWithoutAskExchangeInput, QuotesUncheckedCreateWithoutAskExchangeInput>
  }

  export type QuotesCreateManyAskExchangeInputEnvelope = {
    data: Enumerable<QuotesCreateManyAskExchangeInput>
    skipDuplicates?: boolean
  }

  export type QuotesCreateWithoutBidExchangeInput = {
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    AskExchange: ExchangesCreateNestedOneWithoutAskQuotesInput
    Security: SecuritiesCreateNestedOneWithoutQuotesInput
    Conditions?: ConditionsCreateNestedManyWithoutQuoteInput
  }

  export type QuotesUncheckedCreateWithoutBidExchangeInput = {
    id?: number
    securityId: number
    askExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    Conditions?: ConditionsUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuotesCreateOrConnectWithoutBidExchangeInput = {
    where: QuotesWhereUniqueInput
    create: XOR<QuotesCreateWithoutBidExchangeInput, QuotesUncheckedCreateWithoutBidExchangeInput>
  }

  export type QuotesCreateManyBidExchangeInputEnvelope = {
    data: Enumerable<QuotesCreateManyBidExchangeInput>
    skipDuplicates?: boolean
  }

  export type TradesUpsertWithWhereUniqueWithoutExchangeInput = {
    where: TradesWhereUniqueInput
    update: XOR<TradesUpdateWithoutExchangeInput, TradesUncheckedUpdateWithoutExchangeInput>
    create: XOR<TradesCreateWithoutExchangeInput, TradesUncheckedCreateWithoutExchangeInput>
  }

  export type TradesUpdateWithWhereUniqueWithoutExchangeInput = {
    where: TradesWhereUniqueInput
    data: XOR<TradesUpdateWithoutExchangeInput, TradesUncheckedUpdateWithoutExchangeInput>
  }

  export type TradesUpdateManyWithWhereWithoutExchangeInput = {
    where: TradesScalarWhereInput
    data: XOR<TradesUpdateManyMutationInput, TradesUncheckedUpdateManyWithoutTradesInput>
  }

  export type TradesScalarWhereInput = {
    AND?: Enumerable<TradesScalarWhereInput>
    OR?: Enumerable<TradesScalarWhereInput>
    NOT?: Enumerable<TradesScalarWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    exchangeId?: IntFilter | number
    tradeDate?: DateTimeFilter | Date | string
    price?: DecimalFilter | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type QuotesUpsertWithWhereUniqueWithoutAskExchangeInput = {
    where: QuotesWhereUniqueInput
    update: XOR<QuotesUpdateWithoutAskExchangeInput, QuotesUncheckedUpdateWithoutAskExchangeInput>
    create: XOR<QuotesCreateWithoutAskExchangeInput, QuotesUncheckedCreateWithoutAskExchangeInput>
  }

  export type QuotesUpdateWithWhereUniqueWithoutAskExchangeInput = {
    where: QuotesWhereUniqueInput
    data: XOR<QuotesUpdateWithoutAskExchangeInput, QuotesUncheckedUpdateWithoutAskExchangeInput>
  }

  export type QuotesUpdateManyWithWhereWithoutAskExchangeInput = {
    where: QuotesScalarWhereInput
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyWithoutAskQuotesInput>
  }

  export type QuotesScalarWhereInput = {
    AND?: Enumerable<QuotesScalarWhereInput>
    OR?: Enumerable<QuotesScalarWhereInput>
    NOT?: Enumerable<QuotesScalarWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    bidExchangeId?: IntFilter | number
    askExchangeId?: IntFilter | number
    bidPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    askPrice?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    bidSize?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    askSize?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type QuotesUpsertWithWhereUniqueWithoutBidExchangeInput = {
    where: QuotesWhereUniqueInput
    update: XOR<QuotesUpdateWithoutBidExchangeInput, QuotesUncheckedUpdateWithoutBidExchangeInput>
    create: XOR<QuotesCreateWithoutBidExchangeInput, QuotesUncheckedCreateWithoutBidExchangeInput>
  }

  export type QuotesUpdateWithWhereUniqueWithoutBidExchangeInput = {
    where: QuotesWhereUniqueInput
    data: XOR<QuotesUpdateWithoutBidExchangeInput, QuotesUncheckedUpdateWithoutBidExchangeInput>
  }

  export type QuotesUpdateManyWithWhereWithoutBidExchangeInput = {
    where: QuotesScalarWhereInput
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyWithoutBidQuotesInput>
  }

  export type AccountsCreateWithoutOrdersInput = {
    id: string
    name: string
    accountId?: string | null
    marketValue?: Decimal | DecimalJsLike | number | string | null
    buyingPower?: Decimal | DecimalJsLike | number | string | null
    cash?: Decimal | DecimalJsLike | number | string | null
    currency: string
    daytradeCount?: number
    daytradeBuyingPower?: Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: Decimal | DecimalJsLike | number | string | null
    initialMargin?: Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    longMarketValue?: Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    multiplier?: Decimal | DecimalJsLike | number | string | null
    sma?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Positions?: PositionsCreateNestedManyWithoutAccountInput
  }

  export type AccountsUncheckedCreateWithoutOrdersInput = {
    id: string
    name: string
    accountId?: string | null
    marketValue?: Decimal | DecimalJsLike | number | string | null
    buyingPower?: Decimal | DecimalJsLike | number | string | null
    cash?: Decimal | DecimalJsLike | number | string | null
    currency: string
    daytradeCount?: number
    daytradeBuyingPower?: Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: Decimal | DecimalJsLike | number | string | null
    initialMargin?: Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    longMarketValue?: Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    multiplier?: Decimal | DecimalJsLike | number | string | null
    sma?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Positions?: PositionsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountsCreateOrConnectWithoutOrdersInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutOrdersInput, AccountsUncheckedCreateWithoutOrdersInput>
  }

  export type PositionOrdersCreateWithoutOrderInput = {
    intent: string
    createdAt?: Date | string
    Position?: PositionsCreateNestedOneWithoutPositionOrdersInput
  }

  export type PositionOrdersUncheckedCreateWithoutOrderInput = {
    positionId: string
    intent: string
    createdAt?: Date | string
  }

  export type PositionOrdersCreateOrConnectWithoutOrderInput = {
    where: PositionOrdersWhereUniqueInput
    create: XOR<PositionOrdersCreateWithoutOrderInput, PositionOrdersUncheckedCreateWithoutOrderInput>
  }

  export type PositionOrdersCreateManyOrderInputEnvelope = {
    data: Enumerable<PositionOrdersCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutOrdersInput = {
    update: XOR<AccountsUpdateWithoutOrdersInput, AccountsUncheckedUpdateWithoutOrdersInput>
    create: XOR<AccountsCreateWithoutOrdersInput, AccountsUncheckedCreateWithoutOrdersInput>
  }

  export type AccountsUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cash?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    daytradeCount?: IntFieldUpdateOperationsInput | number
    daytradeBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    initialMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sma?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Positions?: PositionsUpdateManyWithoutAccountNestedInput
  }

  export type AccountsUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cash?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    daytradeCount?: IntFieldUpdateOperationsInput | number
    daytradeBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    initialMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sma?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Positions?: PositionsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PositionOrdersUpsertWithWhereUniqueWithoutOrderInput = {
    where: PositionOrdersWhereUniqueInput
    update: XOR<PositionOrdersUpdateWithoutOrderInput, PositionOrdersUncheckedUpdateWithoutOrderInput>
    create: XOR<PositionOrdersCreateWithoutOrderInput, PositionOrdersUncheckedCreateWithoutOrderInput>
  }

  export type PositionOrdersUpdateWithWhereUniqueWithoutOrderInput = {
    where: PositionOrdersWhereUniqueInput
    data: XOR<PositionOrdersUpdateWithoutOrderInput, PositionOrdersUncheckedUpdateWithoutOrderInput>
  }

  export type PositionOrdersUpdateManyWithWhereWithoutOrderInput = {
    where: PositionOrdersScalarWhereInput
    data: XOR<PositionOrdersUpdateManyMutationInput, PositionOrdersUncheckedUpdateManyWithoutPositionOrdersInput>
  }

  export type PositionOrdersScalarWhereInput = {
    AND?: Enumerable<PositionOrdersScalarWhereInput>
    OR?: Enumerable<PositionOrdersScalarWhereInput>
    NOT?: Enumerable<PositionOrdersScalarWhereInput>
    positionId?: StringFilter | string
    orderId?: StringFilter | string
    intent?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type AccountsCreateWithoutPositionsInput = {
    id: string
    name: string
    accountId?: string | null
    marketValue?: Decimal | DecimalJsLike | number | string | null
    buyingPower?: Decimal | DecimalJsLike | number | string | null
    cash?: Decimal | DecimalJsLike | number | string | null
    currency: string
    daytradeCount?: number
    daytradeBuyingPower?: Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: Decimal | DecimalJsLike | number | string | null
    initialMargin?: Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    longMarketValue?: Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    multiplier?: Decimal | DecimalJsLike | number | string | null
    sma?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Orders?: OrdersCreateNestedManyWithoutAccountInput
  }

  export type AccountsUncheckedCreateWithoutPositionsInput = {
    id: string
    name: string
    accountId?: string | null
    marketValue?: Decimal | DecimalJsLike | number | string | null
    buyingPower?: Decimal | DecimalJsLike | number | string | null
    cash?: Decimal | DecimalJsLike | number | string | null
    currency: string
    daytradeCount?: number
    daytradeBuyingPower?: Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: Decimal | DecimalJsLike | number | string | null
    initialMargin?: Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    longMarketValue?: Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: Decimal | DecimalJsLike | number | string | null
    multiplier?: Decimal | DecimalJsLike | number | string | null
    sma?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Orders?: OrdersUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountsCreateOrConnectWithoutPositionsInput = {
    where: AccountsWhereUniqueInput
    create: XOR<AccountsCreateWithoutPositionsInput, AccountsUncheckedCreateWithoutPositionsInput>
  }

  export type PositionOrdersCreateWithoutPositionInput = {
    intent: string
    createdAt?: Date | string
    Order?: OrdersCreateNestedOneWithoutPositionOrdersInput
  }

  export type PositionOrdersUncheckedCreateWithoutPositionInput = {
    orderId: string
    intent: string
    createdAt?: Date | string
  }

  export type PositionOrdersCreateOrConnectWithoutPositionInput = {
    where: PositionOrdersWhereUniqueInput
    create: XOR<PositionOrdersCreateWithoutPositionInput, PositionOrdersUncheckedCreateWithoutPositionInput>
  }

  export type PositionOrdersCreateManyPositionInputEnvelope = {
    data: Enumerable<PositionOrdersCreateManyPositionInput>
    skipDuplicates?: boolean
  }

  export type AccountsUpsertWithoutPositionsInput = {
    update: XOR<AccountsUpdateWithoutPositionsInput, AccountsUncheckedUpdateWithoutPositionsInput>
    create: XOR<AccountsCreateWithoutPositionsInput, AccountsUncheckedCreateWithoutPositionsInput>
  }

  export type AccountsUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cash?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    daytradeCount?: IntFieldUpdateOperationsInput | number
    daytradeBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    initialMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sma?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Orders?: OrdersUpdateManyWithoutAccountNestedInput
  }

  export type AccountsUncheckedUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    buyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cash?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    daytradeCount?: IntFieldUpdateOperationsInput | number
    daytradeBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    regulationTBuyingPower?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    initialMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastMaintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    shortMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maintenanceMargin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    multiplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sma?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Orders?: OrdersUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PositionOrdersUpsertWithWhereUniqueWithoutPositionInput = {
    where: PositionOrdersWhereUniqueInput
    update: XOR<PositionOrdersUpdateWithoutPositionInput, PositionOrdersUncheckedUpdateWithoutPositionInput>
    create: XOR<PositionOrdersCreateWithoutPositionInput, PositionOrdersUncheckedCreateWithoutPositionInput>
  }

  export type PositionOrdersUpdateWithWhereUniqueWithoutPositionInput = {
    where: PositionOrdersWhereUniqueInput
    data: XOR<PositionOrdersUpdateWithoutPositionInput, PositionOrdersUncheckedUpdateWithoutPositionInput>
  }

  export type PositionOrdersUpdateManyWithWhereWithoutPositionInput = {
    where: PositionOrdersScalarWhereInput
    data: XOR<PositionOrdersUpdateManyMutationInput, PositionOrdersUncheckedUpdateManyWithoutPositionOrdersInput>
  }

  export type PositionsCreateWithoutPositionOrdersInput = {
    id: string
    price: Decimal | DecimalJsLike | number | string
    securityId: number
    strategyName?: string | null
    name?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    marketValue?: Decimal | DecimalJsLike | number | string | null
    symbol: string
    exchange?: string | null
    positionPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string | null
    type: string
    sellLock: boolean
    Account?: AccountsCreateNestedOneWithoutPositionsInput
  }

  export type PositionsUncheckedCreateWithoutPositionOrdersInput = {
    id: string
    price: Decimal | DecimalJsLike | number | string
    securityId: number
    strategyName?: string | null
    name?: string | null
    accountId?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    marketValue?: Decimal | DecimalJsLike | number | string | null
    symbol: string
    exchange?: string | null
    positionPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string | null
    type: string
    sellLock: boolean
  }

  export type PositionsCreateOrConnectWithoutPositionOrdersInput = {
    where: PositionsWhereUniqueInput
    create: XOR<PositionsCreateWithoutPositionOrdersInput, PositionsUncheckedCreateWithoutPositionOrdersInput>
  }

  export type OrdersCreateWithoutPositionOrdersInput = {
    id: string
    securityId: number
    strategyName?: string | null
    symbol: string
    name?: string | null
    type: string
    timeInForce: string
    quantity: Decimal | DecimalJsLike | number | string
    filledQuantity: Decimal | DecimalJsLike | number | string
    filledTime?: Date | string | null
    stopPrice?: Decimal | DecimalJsLike | number | string | null
    limitPrice?: Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    orderType?: string | null
    trailAmount?: Decimal | DecimalJsLike | number | string | null
    extendedHours?: boolean
    submittedAt?: Date | string | null
    expiredAt?: Date | string | null
    canceledAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Account?: AccountsCreateNestedOneWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutPositionOrdersInput = {
    id: string
    securityId: number
    strategyName?: string | null
    accountId?: string | null
    symbol: string
    name?: string | null
    type: string
    timeInForce: string
    quantity: Decimal | DecimalJsLike | number | string
    filledQuantity: Decimal | DecimalJsLike | number | string
    filledTime?: Date | string | null
    stopPrice?: Decimal | DecimalJsLike | number | string | null
    limitPrice?: Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    orderType?: string | null
    trailAmount?: Decimal | DecimalJsLike | number | string | null
    extendedHours?: boolean
    submittedAt?: Date | string | null
    expiredAt?: Date | string | null
    canceledAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OrdersCreateOrConnectWithoutPositionOrdersInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutPositionOrdersInput, OrdersUncheckedCreateWithoutPositionOrdersInput>
  }

  export type PositionsUpsertWithoutPositionOrdersInput = {
    update: XOR<PositionsUpdateWithoutPositionOrdersInput, PositionsUncheckedUpdateWithoutPositionOrdersInput>
    create: XOR<PositionsCreateWithoutPositionOrdersInput, PositionsUncheckedCreateWithoutPositionOrdersInput>
  }

  export type PositionsUpdateWithoutPositionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
    Account?: AccountsUpdateOneWithoutPositionsNestedInput
  }

  export type PositionsUncheckedUpdateWithoutPositionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrdersUpsertWithoutPositionOrdersInput = {
    update: XOR<OrdersUpdateWithoutPositionOrdersInput, OrdersUncheckedUpdateWithoutPositionOrdersInput>
    create: XOR<OrdersCreateWithoutPositionOrdersInput, OrdersUncheckedCreateWithoutPositionOrdersInput>
  }

  export type OrdersUpdateWithoutPositionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Account?: AccountsUpdateOneWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutPositionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorsCreateWithoutSectorDailyInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SectorsUncheckedCreateWithoutSectorDailyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SectorsCreateOrConnectWithoutSectorDailyInput = {
    where: SectorsWhereUniqueInput
    create: XOR<SectorsCreateWithoutSectorDailyInput, SectorsUncheckedCreateWithoutSectorDailyInput>
  }

  export type SectorsUpsertWithoutSectorDailyInput = {
    update: XOR<SectorsUpdateWithoutSectorDailyInput, SectorsUncheckedUpdateWithoutSectorDailyInput>
    create: XOR<SectorsCreateWithoutSectorDailyInput, SectorsUncheckedCreateWithoutSectorDailyInput>
  }

  export type SectorsUpdateWithoutSectorDailyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorsUncheckedUpdateWithoutSectorDailyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorDailyCreateWithoutSectorInput = {
    calendarDate: Date | string
    realtimeReturn: Decimal | DecimalJsLike | number | string
    oneDayReturn: Decimal | DecimalJsLike | number | string
    fiveDayReturn: Decimal | DecimalJsLike | number | string
    oneMonthReturn: Decimal | DecimalJsLike | number | string
    threeMonthReturn: Decimal | DecimalJsLike | number | string
    oneYearReturn: Decimal | DecimalJsLike | number | string
    threeYearReturn: Decimal | DecimalJsLike | number | string
    fiveYearReturn: Decimal | DecimalJsLike | number | string
    tenYearReturn: Decimal | DecimalJsLike | number | string
    ytdReturn: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SectorDailyUncheckedCreateWithoutSectorInput = {
    id?: number
    calendarDate: Date | string
    realtimeReturn: Decimal | DecimalJsLike | number | string
    oneDayReturn: Decimal | DecimalJsLike | number | string
    fiveDayReturn: Decimal | DecimalJsLike | number | string
    oneMonthReturn: Decimal | DecimalJsLike | number | string
    threeMonthReturn: Decimal | DecimalJsLike | number | string
    oneYearReturn: Decimal | DecimalJsLike | number | string
    threeYearReturn: Decimal | DecimalJsLike | number | string
    fiveYearReturn: Decimal | DecimalJsLike | number | string
    tenYearReturn: Decimal | DecimalJsLike | number | string
    ytdReturn: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SectorDailyCreateOrConnectWithoutSectorInput = {
    where: SectorDailyWhereUniqueInput
    create: XOR<SectorDailyCreateWithoutSectorInput, SectorDailyUncheckedCreateWithoutSectorInput>
  }

  export type SectorDailyCreateManySectorInputEnvelope = {
    data: Enumerable<SectorDailyCreateManySectorInput>
    skipDuplicates?: boolean
  }

  export type SectorDailyUpsertWithWhereUniqueWithoutSectorInput = {
    where: SectorDailyWhereUniqueInput
    update: XOR<SectorDailyUpdateWithoutSectorInput, SectorDailyUncheckedUpdateWithoutSectorInput>
    create: XOR<SectorDailyCreateWithoutSectorInput, SectorDailyUncheckedCreateWithoutSectorInput>
  }

  export type SectorDailyUpdateWithWhereUniqueWithoutSectorInput = {
    where: SectorDailyWhereUniqueInput
    data: XOR<SectorDailyUpdateWithoutSectorInput, SectorDailyUncheckedUpdateWithoutSectorInput>
  }

  export type SectorDailyUpdateManyWithWhereWithoutSectorInput = {
    where: SectorDailyScalarWhereInput
    data: XOR<SectorDailyUpdateManyMutationInput, SectorDailyUncheckedUpdateManyWithoutSectorDailyInput>
  }

  export type SectorDailyScalarWhereInput = {
    AND?: Enumerable<SectorDailyScalarWhereInput>
    OR?: Enumerable<SectorDailyScalarWhereInput>
    NOT?: Enumerable<SectorDailyScalarWhereInput>
    id?: IntFilter | number
    sectorId?: IntFilter | number
    calendarDate?: DateTimeFilter | Date | string
    realtimeReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SecurityDailyCreateWithoutSecurityInput = {
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    adjustedClose?: Decimal | DecimalJsLike | number | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: Decimal | DecimalJsLike | number | string | null
    peRatio?: Decimal | DecimalJsLike | number | string | null
    pbRatio?: Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: Decimal | DecimalJsLike | number | string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: Decimal | DecimalJsLike | number | string | null
    volume: number
    adjusted?: boolean
    calendarDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDailyUncheckedCreateWithoutSecurityInput = {
    id?: number
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    adjustedClose?: Decimal | DecimalJsLike | number | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: Decimal | DecimalJsLike | number | string | null
    peRatio?: Decimal | DecimalJsLike | number | string | null
    pbRatio?: Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: Decimal | DecimalJsLike | number | string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: Decimal | DecimalJsLike | number | string | null
    volume: number
    adjusted?: boolean
    calendarDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDailyCreateOrConnectWithoutSecurityInput = {
    where: SecurityDailyWhereUniqueInput
    create: XOR<SecurityDailyCreateWithoutSecurityInput, SecurityDailyUncheckedCreateWithoutSecurityInput>
  }

  export type SecurityDailyCreateManySecurityInputEnvelope = {
    data: Enumerable<SecurityDailyCreateManySecurityInput>
    skipDuplicates?: boolean
  }

  export type SecurityDividendsCreateWithoutSecurityInput = {
    expirationDate?: Date | string | null
    paymentDate: Date | string
    recordDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDividendsUncheckedCreateWithoutSecurityInput = {
    id?: number
    expirationDate?: Date | string | null
    paymentDate: Date | string
    recordDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDividendsCreateOrConnectWithoutSecurityInput = {
    where: SecurityDividendsWhereUniqueInput
    create: XOR<SecurityDividendsCreateWithoutSecurityInput, SecurityDividendsUncheckedCreateWithoutSecurityInput>
  }

  export type SecurityDividendsCreateManySecurityInputEnvelope = {
    data: Enumerable<SecurityDividendsCreateManySecurityInput>
    skipDuplicates?: boolean
  }

  export type SecurityMinutelyCreateWithoutSecurityInput = {
    calendarDate: Date | string
    minute?: string | null
    label?: string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    marketHigh?: Decimal | DecimalJsLike | number | string | null
    marketLow?: Decimal | DecimalJsLike | number | string | null
    marketAverage?: Decimal | DecimalJsLike | number | string | null
    marketVolume?: bigint | number | null
    marketNotional?: Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: bigint | number | null
    marketOpen?: Decimal | DecimalJsLike | number | string | null
    marketClose?: Decimal | DecimalJsLike | number | string | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    dateTime?: Date | string | null
  }

  export type SecurityMinutelyUncheckedCreateWithoutSecurityInput = {
    calendarDate: Date | string
    minute?: string | null
    label?: string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    marketHigh?: Decimal | DecimalJsLike | number | string | null
    marketLow?: Decimal | DecimalJsLike | number | string | null
    marketAverage?: Decimal | DecimalJsLike | number | string | null
    marketVolume?: bigint | number | null
    marketNotional?: Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: bigint | number | null
    marketOpen?: Decimal | DecimalJsLike | number | string | null
    marketClose?: Decimal | DecimalJsLike | number | string | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    dateTime?: Date | string | null
  }

  export type SecurityMinutelyCreateOrConnectWithoutSecurityInput = {
    where: SecurityMinutelyWhereUniqueInput
    create: XOR<SecurityMinutelyCreateWithoutSecurityInput, SecurityMinutelyUncheckedCreateWithoutSecurityInput>
  }

  export type SecurityMinutelyCreateManySecurityInputEnvelope = {
    data: Enumerable<SecurityMinutelyCreateManySecurityInput>
    skipDuplicates?: boolean
  }

  export type SecuritySecondlyCreateWithoutSecurityInput = {
    calendarDate: Date | string
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecuritySecondlyUncheckedCreateWithoutSecurityInput = {
    calendarDate: Date | string
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecuritySecondlyCreateOrConnectWithoutSecurityInput = {
    where: SecuritySecondlyWhereUniqueInput
    create: XOR<SecuritySecondlyCreateWithoutSecurityInput, SecuritySecondlyUncheckedCreateWithoutSecurityInput>
  }

  export type SecuritySecondlyCreateManySecurityInputEnvelope = {
    data: Enumerable<SecuritySecondlyCreateManySecurityInput>
    skipDuplicates?: boolean
  }

  export type SecuritySplitsCreateWithoutSecurityInput = {
    paymentDate: Date | string
    ratio: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exercisedDate: Date | string
    declaredDate: Date | string
    toFactor: number
    fromFactor: number
    description?: string | null
  }

  export type SecuritySplitsUncheckedCreateWithoutSecurityInput = {
    id?: number
    paymentDate: Date | string
    ratio: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exercisedDate: Date | string
    declaredDate: Date | string
    toFactor: number
    fromFactor: number
    description?: string | null
  }

  export type SecuritySplitsCreateOrConnectWithoutSecurityInput = {
    where: SecuritySplitsWhereUniqueInput
    create: XOR<SecuritySplitsCreateWithoutSecurityInput, SecuritySplitsUncheckedCreateWithoutSecurityInput>
  }

  export type SecuritySplitsCreateManySecurityInputEnvelope = {
    data: Enumerable<SecuritySplitsCreateManySecurityInput>
    skipDuplicates?: boolean
  }

  export type TradesCreateWithoutSecurityInput = {
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Exchange: ExchangesCreateNestedOneWithoutTradesInput
    Conditions?: ConditionsCreateNestedManyWithoutTradeInput
  }

  export type TradesUncheckedCreateWithoutSecurityInput = {
    id?: number
    exchangeId: number
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Conditions?: ConditionsUncheckedCreateNestedManyWithoutTradeInput
  }

  export type TradesCreateOrConnectWithoutSecurityInput = {
    where: TradesWhereUniqueInput
    create: XOR<TradesCreateWithoutSecurityInput, TradesUncheckedCreateWithoutSecurityInput>
  }

  export type TradesCreateManySecurityInputEnvelope = {
    data: Enumerable<TradesCreateManySecurityInput>
    skipDuplicates?: boolean
  }

  export type QuotesCreateWithoutSecurityInput = {
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    AskExchange: ExchangesCreateNestedOneWithoutAskQuotesInput
    BidExchange: ExchangesCreateNestedOneWithoutBidQuotesInput
    Conditions?: ConditionsCreateNestedManyWithoutQuoteInput
  }

  export type QuotesUncheckedCreateWithoutSecurityInput = {
    id?: number
    bidExchangeId: number
    askExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    Conditions?: ConditionsUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuotesCreateOrConnectWithoutSecurityInput = {
    where: QuotesWhereUniqueInput
    create: XOR<QuotesCreateWithoutSecurityInput, QuotesUncheckedCreateWithoutSecurityInput>
  }

  export type QuotesCreateManySecurityInputEnvelope = {
    data: Enumerable<QuotesCreateManySecurityInput>
    skipDuplicates?: boolean
  }

  export type SecurityDailyUpsertWithWhereUniqueWithoutSecurityInput = {
    where: SecurityDailyWhereUniqueInput
    update: XOR<SecurityDailyUpdateWithoutSecurityInput, SecurityDailyUncheckedUpdateWithoutSecurityInput>
    create: XOR<SecurityDailyCreateWithoutSecurityInput, SecurityDailyUncheckedCreateWithoutSecurityInput>
  }

  export type SecurityDailyUpdateWithWhereUniqueWithoutSecurityInput = {
    where: SecurityDailyWhereUniqueInput
    data: XOR<SecurityDailyUpdateWithoutSecurityInput, SecurityDailyUncheckedUpdateWithoutSecurityInput>
  }

  export type SecurityDailyUpdateManyWithWhereWithoutSecurityInput = {
    where: SecurityDailyScalarWhereInput
    data: XOR<SecurityDailyUpdateManyMutationInput, SecurityDailyUncheckedUpdateManyWithoutSecurityDailyInput>
  }

  export type SecurityDailyScalarWhereInput = {
    AND?: Enumerable<SecurityDailyScalarWhereInput>
    OR?: Enumerable<SecurityDailyScalarWhereInput>
    NOT?: Enumerable<SecurityDailyScalarWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    open?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketCap?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    peRatio?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    pbRatio?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    volume?: IntFilter | number
    adjusted?: BoolFilter | boolean
    calendarDate?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SecurityDividendsUpsertWithWhereUniqueWithoutSecurityInput = {
    where: SecurityDividendsWhereUniqueInput
    update: XOR<SecurityDividendsUpdateWithoutSecurityInput, SecurityDividendsUncheckedUpdateWithoutSecurityInput>
    create: XOR<SecurityDividendsCreateWithoutSecurityInput, SecurityDividendsUncheckedCreateWithoutSecurityInput>
  }

  export type SecurityDividendsUpdateWithWhereUniqueWithoutSecurityInput = {
    where: SecurityDividendsWhereUniqueInput
    data: XOR<SecurityDividendsUpdateWithoutSecurityInput, SecurityDividendsUncheckedUpdateWithoutSecurityInput>
  }

  export type SecurityDividendsUpdateManyWithWhereWithoutSecurityInput = {
    where: SecurityDividendsScalarWhereInput
    data: XOR<SecurityDividendsUpdateManyMutationInput, SecurityDividendsUncheckedUpdateManyWithoutSecurityDividendsInput>
  }

  export type SecurityDividendsScalarWhereInput = {
    AND?: Enumerable<SecurityDividendsScalarWhereInput>
    OR?: Enumerable<SecurityDividendsScalarWhereInput>
    NOT?: Enumerable<SecurityDividendsScalarWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    expirationDate?: DateTimeNullableFilter | Date | string | null
    paymentDate?: DateTimeFilter | Date | string
    recordDate?: DateTimeFilter | Date | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SecurityMinutelyUpsertWithWhereUniqueWithoutSecurityInput = {
    where: SecurityMinutelyWhereUniqueInput
    update: XOR<SecurityMinutelyUpdateWithoutSecurityInput, SecurityMinutelyUncheckedUpdateWithoutSecurityInput>
    create: XOR<SecurityMinutelyCreateWithoutSecurityInput, SecurityMinutelyUncheckedCreateWithoutSecurityInput>
  }

  export type SecurityMinutelyUpdateWithWhereUniqueWithoutSecurityInput = {
    where: SecurityMinutelyWhereUniqueInput
    data: XOR<SecurityMinutelyUpdateWithoutSecurityInput, SecurityMinutelyUncheckedUpdateWithoutSecurityInput>
  }

  export type SecurityMinutelyUpdateManyWithWhereWithoutSecurityInput = {
    where: SecurityMinutelyScalarWhereInput
    data: XOR<SecurityMinutelyUpdateManyMutationInput, SecurityMinutelyUncheckedUpdateManyWithoutSecurityMinutelyInput>
  }

  export type SecurityMinutelyScalarWhereInput = {
    AND?: Enumerable<SecurityMinutelyScalarWhereInput>
    OR?: Enumerable<SecurityMinutelyScalarWhereInput>
    NOT?: Enumerable<SecurityMinutelyScalarWhereInput>
    securityId?: IntFilter | number
    calendarDate?: DateTimeFilter | Date | string
    minute?: StringNullableFilter | string | null
    label?: StringNullableFilter | string | null
    open?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    average?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    volume?: BigIntNullableFilter | bigint | number | null
    notional?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: BigIntNullableFilter | bigint | number | null
    marketHigh?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketLow?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketAverage?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketVolume?: BigIntNullableFilter | bigint | number | null
    marketNotional?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: BigIntNullableFilter | bigint | number | null
    marketOpen?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketClose?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    dateTime?: DateTimeNullableFilter | Date | string | null
  }

  export type SecuritySecondlyUpsertWithWhereUniqueWithoutSecurityInput = {
    where: SecuritySecondlyWhereUniqueInput
    update: XOR<SecuritySecondlyUpdateWithoutSecurityInput, SecuritySecondlyUncheckedUpdateWithoutSecurityInput>
    create: XOR<SecuritySecondlyCreateWithoutSecurityInput, SecuritySecondlyUncheckedCreateWithoutSecurityInput>
  }

  export type SecuritySecondlyUpdateWithWhereUniqueWithoutSecurityInput = {
    where: SecuritySecondlyWhereUniqueInput
    data: XOR<SecuritySecondlyUpdateWithoutSecurityInput, SecuritySecondlyUncheckedUpdateWithoutSecurityInput>
  }

  export type SecuritySecondlyUpdateManyWithWhereWithoutSecurityInput = {
    where: SecuritySecondlyScalarWhereInput
    data: XOR<SecuritySecondlyUpdateManyMutationInput, SecuritySecondlyUncheckedUpdateManyWithoutSecuritySecondlyInput>
  }

  export type SecuritySecondlyScalarWhereInput = {
    AND?: Enumerable<SecuritySecondlyScalarWhereInput>
    OR?: Enumerable<SecuritySecondlyScalarWhereInput>
    NOT?: Enumerable<SecuritySecondlyScalarWhereInput>
    calendarDate?: DateTimeFilter | Date | string
    securityId?: IntFilter | number
    open?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    close?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    high?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    low?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    average?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    volume?: BigIntNullableFilter | bigint | number | null
    notional?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: BigIntNullableFilter | bigint | number | null
    changeOverTime?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SecuritySplitsUpsertWithWhereUniqueWithoutSecurityInput = {
    where: SecuritySplitsWhereUniqueInput
    update: XOR<SecuritySplitsUpdateWithoutSecurityInput, SecuritySplitsUncheckedUpdateWithoutSecurityInput>
    create: XOR<SecuritySplitsCreateWithoutSecurityInput, SecuritySplitsUncheckedCreateWithoutSecurityInput>
  }

  export type SecuritySplitsUpdateWithWhereUniqueWithoutSecurityInput = {
    where: SecuritySplitsWhereUniqueInput
    data: XOR<SecuritySplitsUpdateWithoutSecurityInput, SecuritySplitsUncheckedUpdateWithoutSecurityInput>
  }

  export type SecuritySplitsUpdateManyWithWhereWithoutSecurityInput = {
    where: SecuritySplitsScalarWhereInput
    data: XOR<SecuritySplitsUpdateManyMutationInput, SecuritySplitsUncheckedUpdateManyWithoutSecuritySplitsInput>
  }

  export type SecuritySplitsScalarWhereInput = {
    AND?: Enumerable<SecuritySplitsScalarWhereInput>
    OR?: Enumerable<SecuritySplitsScalarWhereInput>
    NOT?: Enumerable<SecuritySplitsScalarWhereInput>
    id?: IntFilter | number
    securityId?: IntFilter | number
    paymentDate?: DateTimeFilter | Date | string
    ratio?: DecimalFilter | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    exercisedDate?: DateTimeFilter | Date | string
    declaredDate?: DateTimeFilter | Date | string
    toFactor?: IntFilter | number
    fromFactor?: IntFilter | number
    description?: StringNullableFilter | string | null
  }

  export type TradesUpsertWithWhereUniqueWithoutSecurityInput = {
    where: TradesWhereUniqueInput
    update: XOR<TradesUpdateWithoutSecurityInput, TradesUncheckedUpdateWithoutSecurityInput>
    create: XOR<TradesCreateWithoutSecurityInput, TradesUncheckedCreateWithoutSecurityInput>
  }

  export type TradesUpdateWithWhereUniqueWithoutSecurityInput = {
    where: TradesWhereUniqueInput
    data: XOR<TradesUpdateWithoutSecurityInput, TradesUncheckedUpdateWithoutSecurityInput>
  }

  export type TradesUpdateManyWithWhereWithoutSecurityInput = {
    where: TradesScalarWhereInput
    data: XOR<TradesUpdateManyMutationInput, TradesUncheckedUpdateManyWithoutTradesInput>
  }

  export type QuotesUpsertWithWhereUniqueWithoutSecurityInput = {
    where: QuotesWhereUniqueInput
    update: XOR<QuotesUpdateWithoutSecurityInput, QuotesUncheckedUpdateWithoutSecurityInput>
    create: XOR<QuotesCreateWithoutSecurityInput, QuotesUncheckedCreateWithoutSecurityInput>
  }

  export type QuotesUpdateWithWhereUniqueWithoutSecurityInput = {
    where: QuotesWhereUniqueInput
    data: XOR<QuotesUpdateWithoutSecurityInput, QuotesUncheckedUpdateWithoutSecurityInput>
  }

  export type QuotesUpdateManyWithWhereWithoutSecurityInput = {
    where: QuotesScalarWhereInput
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyWithoutQuotesInput>
  }

  export type SecuritiesCreateWithoutSecurityDailyInput = {
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDividends?: SecurityDividendsCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsCreateNestedManyWithoutSecurityInput
    Trades?: TradesCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUncheckedCreateWithoutSecurityDailyInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDividends?: SecurityDividendsUncheckedCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsUncheckedCreateNestedManyWithoutSecurityInput
    Trades?: TradesUncheckedCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesCreateOrConnectWithoutSecurityDailyInput = {
    where: SecuritiesWhereUniqueInput
    create: XOR<SecuritiesCreateWithoutSecurityDailyInput, SecuritiesUncheckedCreateWithoutSecurityDailyInput>
  }

  export type SecuritiesUpsertWithoutSecurityDailyInput = {
    update: XOR<SecuritiesUpdateWithoutSecurityDailyInput, SecuritiesUncheckedUpdateWithoutSecurityDailyInput>
    create: XOR<SecuritiesCreateWithoutSecurityDailyInput, SecuritiesUncheckedCreateWithoutSecurityDailyInput>
  }

  export type SecuritiesUpdateWithoutSecurityDailyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDividends?: SecurityDividendsUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesUncheckedUpdateWithoutSecurityDailyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDividends?: SecurityDividendsUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUncheckedUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUncheckedUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesCreateWithoutSecurityDividendsInput = {
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsCreateNestedManyWithoutSecurityInput
    Trades?: TradesCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUncheckedCreateWithoutSecurityDividendsInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyUncheckedCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsUncheckedCreateNestedManyWithoutSecurityInput
    Trades?: TradesUncheckedCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesCreateOrConnectWithoutSecurityDividendsInput = {
    where: SecuritiesWhereUniqueInput
    create: XOR<SecuritiesCreateWithoutSecurityDividendsInput, SecuritiesUncheckedCreateWithoutSecurityDividendsInput>
  }

  export type SecuritiesUpsertWithoutSecurityDividendsInput = {
    update: XOR<SecuritiesUpdateWithoutSecurityDividendsInput, SecuritiesUncheckedUpdateWithoutSecurityDividendsInput>
    create: XOR<SecuritiesCreateWithoutSecurityDividendsInput, SecuritiesUncheckedCreateWithoutSecurityDividendsInput>
  }

  export type SecuritiesUpdateWithoutSecurityDividendsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesUncheckedUpdateWithoutSecurityDividendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUncheckedUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUncheckedUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesCreateWithoutSecurityMinutelyInput = {
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsCreateNestedManyWithoutSecurityInput
    Trades?: TradesCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUncheckedCreateWithoutSecurityMinutelyInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyUncheckedCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsUncheckedCreateNestedManyWithoutSecurityInput
    Trades?: TradesUncheckedCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesCreateOrConnectWithoutSecurityMinutelyInput = {
    where: SecuritiesWhereUniqueInput
    create: XOR<SecuritiesCreateWithoutSecurityMinutelyInput, SecuritiesUncheckedCreateWithoutSecurityMinutelyInput>
  }

  export type SecuritiesUpsertWithoutSecurityMinutelyInput = {
    update: XOR<SecuritiesUpdateWithoutSecurityMinutelyInput, SecuritiesUncheckedUpdateWithoutSecurityMinutelyInput>
    create: XOR<SecuritiesCreateWithoutSecurityMinutelyInput, SecuritiesUncheckedCreateWithoutSecurityMinutelyInput>
  }

  export type SecuritiesUpdateWithoutSecurityMinutelyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesUncheckedUpdateWithoutSecurityMinutelyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUncheckedUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUncheckedUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesCreateWithoutSecuritySecondlyInput = {
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsCreateNestedManyWithoutSecurityInput
    Trades?: TradesCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUncheckedCreateWithoutSecuritySecondlyInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyUncheckedCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsUncheckedCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsUncheckedCreateNestedManyWithoutSecurityInput
    Trades?: TradesUncheckedCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesCreateOrConnectWithoutSecuritySecondlyInput = {
    where: SecuritiesWhereUniqueInput
    create: XOR<SecuritiesCreateWithoutSecuritySecondlyInput, SecuritiesUncheckedCreateWithoutSecuritySecondlyInput>
  }

  export type SecuritiesUpsertWithoutSecuritySecondlyInput = {
    update: XOR<SecuritiesUpdateWithoutSecuritySecondlyInput, SecuritiesUncheckedUpdateWithoutSecuritySecondlyInput>
    create: XOR<SecuritiesCreateWithoutSecuritySecondlyInput, SecuritiesUncheckedCreateWithoutSecuritySecondlyInput>
  }

  export type SecuritiesUpdateWithoutSecuritySecondlyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesUncheckedUpdateWithoutSecuritySecondlyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUncheckedUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUncheckedUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesCreateWithoutSecuritySplitsInput = {
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyCreateNestedManyWithoutSecurityInput
    Trades?: TradesCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUncheckedCreateWithoutSecuritySplitsInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyUncheckedCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsUncheckedCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyUncheckedCreateNestedManyWithoutSecurityInput
    Trades?: TradesUncheckedCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesCreateOrConnectWithoutSecuritySplitsInput = {
    where: SecuritiesWhereUniqueInput
    create: XOR<SecuritiesCreateWithoutSecuritySplitsInput, SecuritiesUncheckedCreateWithoutSecuritySplitsInput>
  }

  export type SecuritiesUpsertWithoutSecuritySplitsInput = {
    update: XOR<SecuritiesUpdateWithoutSecuritySplitsInput, SecuritiesUncheckedUpdateWithoutSecuritySplitsInput>
    create: XOR<SecuritiesCreateWithoutSecuritySplitsInput, SecuritiesUncheckedCreateWithoutSecuritySplitsInput>
  }

  export type SecuritiesUpdateWithoutSecuritySplitsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesUncheckedUpdateWithoutSecuritySplitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUncheckedUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUncheckedUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutSecurityNestedInput
  }

  export type StrategyParametersCreateWithoutStrategyInput = {
    key: string
    value: string
    dataType?: string | null
  }

  export type StrategyParametersUncheckedCreateWithoutStrategyInput = {
    id?: number
    key: string
    value: string
    dataType?: string | null
  }

  export type StrategyParametersCreateOrConnectWithoutStrategyInput = {
    where: StrategyParametersWhereUniqueInput
    create: XOR<StrategyParametersCreateWithoutStrategyInput, StrategyParametersUncheckedCreateWithoutStrategyInput>
  }

  export type StrategyParametersCreateManyStrategyInputEnvelope = {
    data: Enumerable<StrategyParametersCreateManyStrategyInput>
    skipDuplicates?: boolean
  }

  export type StrategyParametersUpsertWithWhereUniqueWithoutStrategyInput = {
    where: StrategyParametersWhereUniqueInput
    update: XOR<StrategyParametersUpdateWithoutStrategyInput, StrategyParametersUncheckedUpdateWithoutStrategyInput>
    create: XOR<StrategyParametersCreateWithoutStrategyInput, StrategyParametersUncheckedCreateWithoutStrategyInput>
  }

  export type StrategyParametersUpdateWithWhereUniqueWithoutStrategyInput = {
    where: StrategyParametersWhereUniqueInput
    data: XOR<StrategyParametersUpdateWithoutStrategyInput, StrategyParametersUncheckedUpdateWithoutStrategyInput>
  }

  export type StrategyParametersUpdateManyWithWhereWithoutStrategyInput = {
    where: StrategyParametersScalarWhereInput
    data: XOR<StrategyParametersUpdateManyMutationInput, StrategyParametersUncheckedUpdateManyWithoutStrategyParametersInput>
  }

  export type StrategyParametersScalarWhereInput = {
    AND?: Enumerable<StrategyParametersScalarWhereInput>
    OR?: Enumerable<StrategyParametersScalarWhereInput>
    NOT?: Enumerable<StrategyParametersScalarWhereInput>
    id?: IntFilter | number
    strategyId?: IntFilter | number
    key?: StringFilter | string
    value?: StringFilter | string
    dataType?: StringNullableFilter | string | null
  }

  export type StrategiesCreateWithoutStrategyParametersInput = {
    name: string
    description?: string | null
  }

  export type StrategiesUncheckedCreateWithoutStrategyParametersInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type StrategiesCreateOrConnectWithoutStrategyParametersInput = {
    where: StrategiesWhereUniqueInput
    create: XOR<StrategiesCreateWithoutStrategyParametersInput, StrategiesUncheckedCreateWithoutStrategyParametersInput>
  }

  export type StrategiesUpsertWithoutStrategyParametersInput = {
    update: XOR<StrategiesUpdateWithoutStrategyParametersInput, StrategiesUncheckedUpdateWithoutStrategyParametersInput>
    create: XOR<StrategiesCreateWithoutStrategyParametersInput, StrategiesUncheckedCreateWithoutStrategyParametersInput>
  }

  export type StrategiesUpdateWithoutStrategyParametersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategiesUncheckedUpdateWithoutStrategyParametersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExchangesCreateWithoutTradesInput = {
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
    AskQuotes?: QuotesCreateNestedManyWithoutAskExchangeInput
    BidQuotes?: QuotesCreateNestedManyWithoutBidExchangeInput
  }

  export type ExchangesUncheckedCreateWithoutTradesInput = {
    id?: number
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
    AskQuotes?: QuotesUncheckedCreateNestedManyWithoutAskExchangeInput
    BidQuotes?: QuotesUncheckedCreateNestedManyWithoutBidExchangeInput
  }

  export type ExchangesCreateOrConnectWithoutTradesInput = {
    where: ExchangesWhereUniqueInput
    create: XOR<ExchangesCreateWithoutTradesInput, ExchangesUncheckedCreateWithoutTradesInput>
  }

  export type SecuritiesCreateWithoutTradesInput = {
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUncheckedCreateWithoutTradesInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyUncheckedCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsUncheckedCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsUncheckedCreateNestedManyWithoutSecurityInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesCreateOrConnectWithoutTradesInput = {
    where: SecuritiesWhereUniqueInput
    create: XOR<SecuritiesCreateWithoutTradesInput, SecuritiesUncheckedCreateWithoutTradesInput>
  }

  export type ConditionsCreateWithoutTradeInput = {
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
    Quote: QuotesCreateNestedOneWithoutConditionsInput
  }

  export type ConditionsUncheckedCreateWithoutTradeInput = {
    id?: number
    quoteId: number
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
  }

  export type ConditionsCreateOrConnectWithoutTradeInput = {
    where: ConditionsWhereUniqueInput
    create: XOR<ConditionsCreateWithoutTradeInput, ConditionsUncheckedCreateWithoutTradeInput>
  }

  export type ConditionsCreateManyTradeInputEnvelope = {
    data: Enumerable<ConditionsCreateManyTradeInput>
    skipDuplicates?: boolean
  }

  export type ExchangesUpsertWithoutTradesInput = {
    update: XOR<ExchangesUpdateWithoutTradesInput, ExchangesUncheckedUpdateWithoutTradesInput>
    create: XOR<ExchangesCreateWithoutTradesInput, ExchangesUncheckedCreateWithoutTradesInput>
  }

  export type ExchangesUpdateWithoutTradesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    AskQuotes?: QuotesUpdateManyWithoutAskExchangeNestedInput
    BidQuotes?: QuotesUpdateManyWithoutBidExchangeNestedInput
  }

  export type ExchangesUncheckedUpdateWithoutTradesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    AskQuotes?: QuotesUncheckedUpdateManyWithoutAskExchangeNestedInput
    BidQuotes?: QuotesUncheckedUpdateManyWithoutBidExchangeNestedInput
  }

  export type SecuritiesUpsertWithoutTradesInput = {
    update: XOR<SecuritiesUpdateWithoutTradesInput, SecuritiesUncheckedUpdateWithoutTradesInput>
    create: XOR<SecuritiesCreateWithoutTradesInput, SecuritiesUncheckedCreateWithoutTradesInput>
  }

  export type SecuritiesUpdateWithoutTradesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesUncheckedUpdateWithoutTradesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUncheckedUpdateManyWithoutSecurityNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutSecurityNestedInput
  }

  export type ConditionsUpsertWithWhereUniqueWithoutTradeInput = {
    where: ConditionsWhereUniqueInput
    update: XOR<ConditionsUpdateWithoutTradeInput, ConditionsUncheckedUpdateWithoutTradeInput>
    create: XOR<ConditionsCreateWithoutTradeInput, ConditionsUncheckedCreateWithoutTradeInput>
  }

  export type ConditionsUpdateWithWhereUniqueWithoutTradeInput = {
    where: ConditionsWhereUniqueInput
    data: XOR<ConditionsUpdateWithoutTradeInput, ConditionsUncheckedUpdateWithoutTradeInput>
  }

  export type ConditionsUpdateManyWithWhereWithoutTradeInput = {
    where: ConditionsScalarWhereInput
    data: XOR<ConditionsUpdateManyMutationInput, ConditionsUncheckedUpdateManyWithoutConditionsInput>
  }

  export type ConditionsScalarWhereInput = {
    AND?: Enumerable<ConditionsScalarWhereInput>
    OR?: Enumerable<ConditionsScalarWhereInput>
    NOT?: Enumerable<ConditionsScalarWhereInput>
    id?: IntFilter | number
    tradeId?: IntFilter | number
    quoteId?: IntFilter | number
    condition?: StringFilter | string
    modifier?: IntFilter | number
    SIPMapping?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type ExchangesCreateWithoutAskQuotesInput = {
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
    Trades?: TradesCreateNestedManyWithoutExchangeInput
    BidQuotes?: QuotesCreateNestedManyWithoutBidExchangeInput
  }

  export type ExchangesUncheckedCreateWithoutAskQuotesInput = {
    id?: number
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
    Trades?: TradesUncheckedCreateNestedManyWithoutExchangeInput
    BidQuotes?: QuotesUncheckedCreateNestedManyWithoutBidExchangeInput
  }

  export type ExchangesCreateOrConnectWithoutAskQuotesInput = {
    where: ExchangesWhereUniqueInput
    create: XOR<ExchangesCreateWithoutAskQuotesInput, ExchangesUncheckedCreateWithoutAskQuotesInput>
  }

  export type ExchangesCreateWithoutBidQuotesInput = {
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
    Trades?: TradesCreateNestedManyWithoutExchangeInput
    AskQuotes?: QuotesCreateNestedManyWithoutAskExchangeInput
  }

  export type ExchangesUncheckedCreateWithoutBidQuotesInput = {
    id?: number
    name: string
    description?: string | null
    assetClass?: string | null
    locale?: string | null
    acronym?: string | null
    mic?: string | null
    operatingMic?: string | null
    participantId?: string | null
    url?: string | null
    Trades?: TradesUncheckedCreateNestedManyWithoutExchangeInput
    AskQuotes?: QuotesUncheckedCreateNestedManyWithoutAskExchangeInput
  }

  export type ExchangesCreateOrConnectWithoutBidQuotesInput = {
    where: ExchangesWhereUniqueInput
    create: XOR<ExchangesCreateWithoutBidQuotesInput, ExchangesUncheckedCreateWithoutBidQuotesInput>
  }

  export type SecuritiesCreateWithoutQuotesInput = {
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsCreateNestedManyWithoutSecurityInput
    Trades?: TradesCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesUncheckedCreateWithoutQuotesInput = {
    id?: number
    name?: string | null
    description?: string | null
    symbol?: string | null
    cusip?: string | null
    exchange?: string | null
    securityTypeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    companyName?: string | null
    sector?: string | null
    active?: boolean
    delistedCalendarDate?: Date | string | null
    companyDescription?: string | null
    url?: string | null
    sharesOutstanding?: number | null
    numberOfEmployees?: number | null
    SecurityDaily?: SecurityDailyUncheckedCreateNestedManyWithoutSecurityInput
    SecurityDividends?: SecurityDividendsUncheckedCreateNestedManyWithoutSecurityInput
    SecurityMinutely?: SecurityMinutelyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySecondly?: SecuritySecondlyUncheckedCreateNestedManyWithoutSecurityInput
    SecuritySplits?: SecuritySplitsUncheckedCreateNestedManyWithoutSecurityInput
    Trades?: TradesUncheckedCreateNestedManyWithoutSecurityInput
  }

  export type SecuritiesCreateOrConnectWithoutQuotesInput = {
    where: SecuritiesWhereUniqueInput
    create: XOR<SecuritiesCreateWithoutQuotesInput, SecuritiesUncheckedCreateWithoutQuotesInput>
  }

  export type ConditionsCreateWithoutQuoteInput = {
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
    Trade: TradesCreateNestedOneWithoutConditionsInput
  }

  export type ConditionsUncheckedCreateWithoutQuoteInput = {
    id?: number
    tradeId: number
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
  }

  export type ConditionsCreateOrConnectWithoutQuoteInput = {
    where: ConditionsWhereUniqueInput
    create: XOR<ConditionsCreateWithoutQuoteInput, ConditionsUncheckedCreateWithoutQuoteInput>
  }

  export type ConditionsCreateManyQuoteInputEnvelope = {
    data: Enumerable<ConditionsCreateManyQuoteInput>
    skipDuplicates?: boolean
  }

  export type ExchangesUpsertWithoutAskQuotesInput = {
    update: XOR<ExchangesUpdateWithoutAskQuotesInput, ExchangesUncheckedUpdateWithoutAskQuotesInput>
    create: XOR<ExchangesCreateWithoutAskQuotesInput, ExchangesUncheckedCreateWithoutAskQuotesInput>
  }

  export type ExchangesUpdateWithoutAskQuotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    Trades?: TradesUpdateManyWithoutExchangeNestedInput
    BidQuotes?: QuotesUpdateManyWithoutBidExchangeNestedInput
  }

  export type ExchangesUncheckedUpdateWithoutAskQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    Trades?: TradesUncheckedUpdateManyWithoutExchangeNestedInput
    BidQuotes?: QuotesUncheckedUpdateManyWithoutBidExchangeNestedInput
  }

  export type ExchangesUpsertWithoutBidQuotesInput = {
    update: XOR<ExchangesUpdateWithoutBidQuotesInput, ExchangesUncheckedUpdateWithoutBidQuotesInput>
    create: XOR<ExchangesCreateWithoutBidQuotesInput, ExchangesUncheckedCreateWithoutBidQuotesInput>
  }

  export type ExchangesUpdateWithoutBidQuotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    Trades?: TradesUpdateManyWithoutExchangeNestedInput
    AskQuotes?: QuotesUpdateManyWithoutAskExchangeNestedInput
  }

  export type ExchangesUncheckedUpdateWithoutBidQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetClass?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: NullableStringFieldUpdateOperationsInput | string | null
    operatingMic?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    Trades?: TradesUncheckedUpdateManyWithoutExchangeNestedInput
    AskQuotes?: QuotesUncheckedUpdateManyWithoutAskExchangeNestedInput
  }

  export type SecuritiesUpsertWithoutQuotesInput = {
    update: XOR<SecuritiesUpdateWithoutQuotesInput, SecuritiesUncheckedUpdateWithoutQuotesInput>
    create: XOR<SecuritiesCreateWithoutQuotesInput, SecuritiesUncheckedCreateWithoutQuotesInput>
  }

  export type SecuritiesUpdateWithoutQuotesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUpdateManyWithoutSecurityNestedInput
  }

  export type SecuritiesUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    cusip?: NullableStringFieldUpdateOperationsInput | string | null
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    securityTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    delistedCalendarDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    sharesOutstanding?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    SecurityDaily?: SecurityDailyUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityDividends?: SecurityDividendsUncheckedUpdateManyWithoutSecurityNestedInput
    SecurityMinutely?: SecurityMinutelyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySecondly?: SecuritySecondlyUncheckedUpdateManyWithoutSecurityNestedInput
    SecuritySplits?: SecuritySplitsUncheckedUpdateManyWithoutSecurityNestedInput
    Trades?: TradesUncheckedUpdateManyWithoutSecurityNestedInput
  }

  export type ConditionsUpsertWithWhereUniqueWithoutQuoteInput = {
    where: ConditionsWhereUniqueInput
    update: XOR<ConditionsUpdateWithoutQuoteInput, ConditionsUncheckedUpdateWithoutQuoteInput>
    create: XOR<ConditionsCreateWithoutQuoteInput, ConditionsUncheckedCreateWithoutQuoteInput>
  }

  export type ConditionsUpdateWithWhereUniqueWithoutQuoteInput = {
    where: ConditionsWhereUniqueInput
    data: XOR<ConditionsUpdateWithoutQuoteInput, ConditionsUncheckedUpdateWithoutQuoteInput>
  }

  export type ConditionsUpdateManyWithWhereWithoutQuoteInput = {
    where: ConditionsScalarWhereInput
    data: XOR<ConditionsUpdateManyMutationInput, ConditionsUncheckedUpdateManyWithoutConditionsInput>
  }

  export type TradesCreateWithoutConditionsInput = {
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    Exchange: ExchangesCreateNestedOneWithoutTradesInput
    Security: SecuritiesCreateNestedOneWithoutTradesInput
  }

  export type TradesUncheckedCreateWithoutConditionsInput = {
    id?: number
    securityId: number
    exchangeId: number
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TradesCreateOrConnectWithoutConditionsInput = {
    where: TradesWhereUniqueInput
    create: XOR<TradesCreateWithoutConditionsInput, TradesUncheckedCreateWithoutConditionsInput>
  }

  export type QuotesCreateWithoutConditionsInput = {
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    AskExchange: ExchangesCreateNestedOneWithoutAskQuotesInput
    BidExchange: ExchangesCreateNestedOneWithoutBidQuotesInput
    Security: SecuritiesCreateNestedOneWithoutQuotesInput
  }

  export type QuotesUncheckedCreateWithoutConditionsInput = {
    id?: number
    securityId: number
    bidExchangeId: number
    askExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type QuotesCreateOrConnectWithoutConditionsInput = {
    where: QuotesWhereUniqueInput
    create: XOR<QuotesCreateWithoutConditionsInput, QuotesUncheckedCreateWithoutConditionsInput>
  }

  export type TradesUpsertWithoutConditionsInput = {
    update: XOR<TradesUpdateWithoutConditionsInput, TradesUncheckedUpdateWithoutConditionsInput>
    create: XOR<TradesCreateWithoutConditionsInput, TradesUncheckedCreateWithoutConditionsInput>
  }

  export type TradesUpdateWithoutConditionsInput = {
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Exchange?: ExchangesUpdateOneRequiredWithoutTradesNestedInput
    Security?: SecuritiesUpdateOneRequiredWithoutTradesNestedInput
  }

  export type TradesUncheckedUpdateWithoutConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    exchangeId?: IntFieldUpdateOperationsInput | number
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUpsertWithoutConditionsInput = {
    update: XOR<QuotesUpdateWithoutConditionsInput, QuotesUncheckedUpdateWithoutConditionsInput>
    create: XOR<QuotesCreateWithoutConditionsInput, QuotesUncheckedCreateWithoutConditionsInput>
  }

  export type QuotesUpdateWithoutConditionsInput = {
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AskExchange?: ExchangesUpdateOneRequiredWithoutAskQuotesNestedInput
    BidExchange?: ExchangesUpdateOneRequiredWithoutBidQuotesNestedInput
    Security?: SecuritiesUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type QuotesUncheckedUpdateWithoutConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    bidExchangeId?: IntFieldUpdateOperationsInput | number
    askExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersCreateManyAccountInput = {
    id: string
    securityId: number
    strategyName?: string | null
    symbol: string
    name?: string | null
    type: string
    timeInForce: string
    quantity: Decimal | DecimalJsLike | number | string
    filledQuantity: Decimal | DecimalJsLike | number | string
    filledTime?: Date | string | null
    stopPrice?: Decimal | DecimalJsLike | number | string | null
    limitPrice?: Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    orderType?: string | null
    trailAmount?: Decimal | DecimalJsLike | number | string | null
    extendedHours?: boolean
    submittedAt?: Date | string | null
    expiredAt?: Date | string | null
    canceledAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type PositionsCreateManyAccountInput = {
    id: string
    price: Decimal | DecimalJsLike | number | string
    securityId: number
    strategyName?: string | null
    name?: string | null
    quantity: Decimal | DecimalJsLike | number | string
    marketValue?: Decimal | DecimalJsLike | number | string | null
    symbol: string
    exchange?: string | null
    positionPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    status?: string | null
    type: string
    sellLock: boolean
  }

  export type OrdersUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PositionOrders?: PositionOrdersUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PositionOrders?: PositionOrdersUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    timeInForce?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledQuantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    filledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    limitPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filledAveragePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    trailAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extendedHours?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PositionsUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
    PositionOrders?: PositionOrdersUpdateManyWithoutPositionNestedInput
  }

  export type PositionsUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
    PositionOrders?: PositionOrdersUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionsUncheckedUpdateManyWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    securityId?: IntFieldUpdateOperationsInput | number
    strategyName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    exchange?: NullableStringFieldUpdateOperationsInput | string | null
    positionPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    sellLock?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TradesCreateManyExchangeInput = {
    id?: number
    securityId: number
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type QuotesCreateManyAskExchangeInput = {
    id?: number
    securityId: number
    bidExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type QuotesCreateManyBidExchangeInput = {
    id?: number
    securityId: number
    askExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type TradesUpdateWithoutExchangeInput = {
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Security?: SecuritiesUpdateOneRequiredWithoutTradesNestedInput
    Conditions?: ConditionsUpdateManyWithoutTradeNestedInput
  }

  export type TradesUncheckedUpdateWithoutExchangeInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conditions?: ConditionsUncheckedUpdateManyWithoutTradeNestedInput
  }

  export type TradesUncheckedUpdateManyWithoutTradesInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUpdateWithoutAskExchangeInput = {
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BidExchange?: ExchangesUpdateOneRequiredWithoutBidQuotesNestedInput
    Security?: SecuritiesUpdateOneRequiredWithoutQuotesNestedInput
    Conditions?: ConditionsUpdateManyWithoutQuoteNestedInput
  }

  export type QuotesUncheckedUpdateWithoutAskExchangeInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    bidExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conditions?: ConditionsUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuotesUncheckedUpdateManyWithoutAskQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    bidExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUpdateWithoutBidExchangeInput = {
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AskExchange?: ExchangesUpdateOneRequiredWithoutAskQuotesNestedInput
    Security?: SecuritiesUpdateOneRequiredWithoutQuotesNestedInput
    Conditions?: ConditionsUpdateManyWithoutQuoteNestedInput
  }

  export type QuotesUncheckedUpdateWithoutBidExchangeInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    askExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conditions?: ConditionsUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuotesUncheckedUpdateManyWithoutBidQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    securityId?: IntFieldUpdateOperationsInput | number
    askExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionOrdersCreateManyOrderInput = {
    positionId: string
    intent: string
    createdAt?: Date | string
  }

  export type PositionOrdersUpdateWithoutOrderInput = {
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Position?: PositionsUpdateOneWithoutPositionOrdersNestedInput
  }

  export type PositionOrdersUncheckedUpdateWithoutOrderInput = {
    positionId?: StringFieldUpdateOperationsInput | string
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionOrdersUncheckedUpdateManyWithoutPositionOrdersInput = {
    positionId?: StringFieldUpdateOperationsInput | string
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionOrdersCreateManyPositionInput = {
    orderId: string
    intent: string
    createdAt?: Date | string
  }

  export type PositionOrdersUpdateWithoutPositionInput = {
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Order?: OrdersUpdateOneWithoutPositionOrdersNestedInput
  }

  export type PositionOrdersUncheckedUpdateWithoutPositionInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    intent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectorDailyCreateManySectorInput = {
    id?: number
    calendarDate: Date | string
    realtimeReturn: Decimal | DecimalJsLike | number | string
    oneDayReturn: Decimal | DecimalJsLike | number | string
    fiveDayReturn: Decimal | DecimalJsLike | number | string
    oneMonthReturn: Decimal | DecimalJsLike | number | string
    threeMonthReturn: Decimal | DecimalJsLike | number | string
    oneYearReturn: Decimal | DecimalJsLike | number | string
    threeYearReturn: Decimal | DecimalJsLike | number | string
    fiveYearReturn: Decimal | DecimalJsLike | number | string
    tenYearReturn: Decimal | DecimalJsLike | number | string
    ytdReturn: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SectorDailyUpdateWithoutSectorInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    realtimeReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorDailyUncheckedUpdateWithoutSectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    realtimeReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SectorDailyUncheckedUpdateManyWithoutSectorDailyInput = {
    id?: IntFieldUpdateOperationsInput | number
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    realtimeReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveDayReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeMonthReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    oneYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threeYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fiveYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenYearReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ytdReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDailyCreateManySecurityInput = {
    id?: number
    open?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    adjustedClose?: Decimal | DecimalJsLike | number | string | null
    marketCap?: Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: Decimal | DecimalJsLike | number | string | null
    peRatio?: Decimal | DecimalJsLike | number | string | null
    pbRatio?: Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: Decimal | DecimalJsLike | number | string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: Decimal | DecimalJsLike | number | string | null
    volume: number
    adjusted?: boolean
    calendarDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityDividendsCreateManySecurityInput = {
    id?: number
    expirationDate?: Date | string | null
    paymentDate: Date | string
    recordDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecurityMinutelyCreateManySecurityInput = {
    calendarDate: Date | string
    minute?: string | null
    label?: string | null
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    marketHigh?: Decimal | DecimalJsLike | number | string | null
    marketLow?: Decimal | DecimalJsLike | number | string | null
    marketAverage?: Decimal | DecimalJsLike | number | string | null
    marketVolume?: bigint | number | null
    marketNotional?: Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: bigint | number | null
    marketOpen?: Decimal | DecimalJsLike | number | string | null
    marketClose?: Decimal | DecimalJsLike | number | string | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    dateTime?: Date | string | null
  }

  export type SecuritySecondlyCreateManySecurityInput = {
    calendarDate: Date | string
    open?: Decimal | DecimalJsLike | number | string | null
    close?: Decimal | DecimalJsLike | number | string | null
    high?: Decimal | DecimalJsLike | number | string | null
    low?: Decimal | DecimalJsLike | number | string | null
    average?: Decimal | DecimalJsLike | number | string | null
    volume?: bigint | number | null
    notional?: Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: bigint | number | null
    changeOverTime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SecuritySplitsCreateManySecurityInput = {
    id?: number
    paymentDate: Date | string
    ratio: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    exercisedDate: Date | string
    declaredDate: Date | string
    toFactor: number
    fromFactor: number
    description?: string | null
  }

  export type TradesCreateManySecurityInput = {
    id?: number
    exchangeId: number
    tradeDate: Date | string
    price: Decimal | DecimalJsLike | number | string
    quantity: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type QuotesCreateManySecurityInput = {
    id?: number
    bidExchangeId: number
    askExchangeId: number
    bidPrice?: Decimal | DecimalJsLike | number | string | null
    askPrice?: Decimal | DecimalJsLike | number | string | null
    bidSize?: Decimal | DecimalJsLike | number | string | null
    askSize?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type SecurityDailyUpdateWithoutSecurityInput = {
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    peRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pbRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: IntFieldUpdateOperationsInput | number
    adjusted?: BoolFieldUpdateOperationsInput | boolean
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDailyUncheckedUpdateWithoutSecurityInput = {
    id?: IntFieldUpdateOperationsInput | number
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    peRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pbRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: IntFieldUpdateOperationsInput | number
    adjusted?: BoolFieldUpdateOperationsInput | boolean
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDailyUncheckedUpdateManyWithoutSecurityDailyInput = {
    id?: IntFieldUpdateOperationsInput | number
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adjustedClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketCap?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    enterpriseValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    peRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pbRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trailingOneYearPegRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    splitCoefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: IntFieldUpdateOperationsInput | number
    adjusted?: BoolFieldUpdateOperationsInput | boolean
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDividendsUpdateWithoutSecurityInput = {
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDividendsUncheckedUpdateWithoutSecurityInput = {
    id?: IntFieldUpdateOperationsInput | number
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityDividendsUncheckedUpdateManyWithoutSecurityDividendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityMinutelyUpdateWithoutSecurityInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minute?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketVolume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketNotional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketOpen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityMinutelyUncheckedUpdateWithoutSecurityInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minute?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketVolume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketNotional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketOpen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecurityMinutelyUncheckedUpdateManyWithoutSecurityMinutelyInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minute?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketVolume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketNotional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketNumberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    marketOpen?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketClose?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketChangeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritySecondlyUpdateWithoutSecurityInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritySecondlyUncheckedUpdateWithoutSecurityInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritySecondlyUncheckedUpdateManyWithoutSecuritySecondlyInput = {
    calendarDate?: DateTimeFieldUpdateOperationsInput | Date | string
    open?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    close?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    high?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    low?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    average?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    volume?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    notional?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    numberOfTrades?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    changeOverTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SecuritySplitsUpdateWithoutSecurityInput = {
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ratio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercisedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    declaredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toFactor?: IntFieldUpdateOperationsInput | number
    fromFactor?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecuritySplitsUncheckedUpdateWithoutSecurityInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ratio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercisedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    declaredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toFactor?: IntFieldUpdateOperationsInput | number
    fromFactor?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecuritySplitsUncheckedUpdateManyWithoutSecuritySplitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ratio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercisedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    declaredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toFactor?: IntFieldUpdateOperationsInput | number
    fromFactor?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TradesUpdateWithoutSecurityInput = {
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Exchange?: ExchangesUpdateOneRequiredWithoutTradesNestedInput
    Conditions?: ConditionsUpdateManyWithoutTradeNestedInput
  }

  export type TradesUncheckedUpdateWithoutSecurityInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchangeId?: IntFieldUpdateOperationsInput | number
    tradeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conditions?: ConditionsUncheckedUpdateManyWithoutTradeNestedInput
  }

  export type QuotesUpdateWithoutSecurityInput = {
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AskExchange?: ExchangesUpdateOneRequiredWithoutAskQuotesNestedInput
    BidExchange?: ExchangesUpdateOneRequiredWithoutBidQuotesNestedInput
    Conditions?: ConditionsUpdateManyWithoutQuoteNestedInput
  }

  export type QuotesUncheckedUpdateWithoutSecurityInput = {
    id?: IntFieldUpdateOperationsInput | number
    bidExchangeId?: IntFieldUpdateOperationsInput | number
    askExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conditions?: ConditionsUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuotesUncheckedUpdateManyWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    bidExchangeId?: IntFieldUpdateOperationsInput | number
    askExchangeId?: IntFieldUpdateOperationsInput | number
    bidPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bidSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    askSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrategyParametersCreateManyStrategyInput = {
    id?: number
    key: string
    value: string
    dataType?: string | null
  }

  export type StrategyParametersUpdateWithoutStrategyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategyParametersUncheckedUpdateWithoutStrategyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrategyParametersUncheckedUpdateManyWithoutStrategyParametersInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConditionsCreateManyTradeInput = {
    id?: number
    quoteId: number
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
  }

  export type ConditionsUpdateWithoutTradeInput = {
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Quote?: QuotesUpdateOneRequiredWithoutConditionsNestedInput
  }

  export type ConditionsUncheckedUpdateWithoutTradeInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionsUncheckedUpdateManyWithoutConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quoteId?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionsCreateManyQuoteInput = {
    id?: number
    tradeId: number
    condition: string
    modifier: number
    SIPMapping: string
    createdAt?: Date | string
  }

  export type ConditionsUpdateWithoutQuoteInput = {
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Trade?: TradesUpdateOneRequiredWithoutConditionsNestedInput
  }

  export type ConditionsUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    tradeId?: IntFieldUpdateOperationsInput | number
    condition?: StringFieldUpdateOperationsInput | string
    modifier?: IntFieldUpdateOperationsInput | number
    SIPMapping?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}